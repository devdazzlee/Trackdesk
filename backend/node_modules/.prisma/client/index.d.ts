
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model AffiliateProfile
 * 
 */
export type AffiliateProfile = $Result.DefaultSelection<Prisma.$AffiliateProfilePayload>
/**
 * Model AdminProfile
 * 
 */
export type AdminProfile = $Result.DefaultSelection<Prisma.$AdminProfilePayload>
/**
 * Model Offer
 * 
 */
export type Offer = $Result.DefaultSelection<Prisma.$OfferPayload>
/**
 * Model OfferApplication
 * 
 */
export type OfferApplication = $Result.DefaultSelection<Prisma.$OfferApplicationPayload>
/**
 * Model AffiliateLink
 * 
 */
export type AffiliateLink = $Result.DefaultSelection<Prisma.$AffiliateLinkPayload>
/**
 * Model Click
 * 
 */
export type Click = $Result.DefaultSelection<Prisma.$ClickPayload>
/**
 * Model Conversion
 * 
 */
export type Conversion = $Result.DefaultSelection<Prisma.$ConversionPayload>
/**
 * Model Commission
 * 
 */
export type Commission = $Result.DefaultSelection<Prisma.$CommissionPayload>
/**
 * Model Payout
 * 
 */
export type Payout = $Result.DefaultSelection<Prisma.$PayoutPayload>
/**
 * Model Creative
 * 
 */
export type Creative = $Result.DefaultSelection<Prisma.$CreativePayload>
/**
 * Model Coupon
 * 
 */
export type Coupon = $Result.DefaultSelection<Prisma.$CouponPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Activity
 * 
 */
export type Activity = $Result.DefaultSelection<Prisma.$ActivityPayload>
/**
 * Model Webhook
 * 
 */
export type Webhook = $Result.DefaultSelection<Prisma.$WebhookPayload>
/**
 * Model TrafficRule
 * 
 */
export type TrafficRule = $Result.DefaultSelection<Prisma.$TrafficRulePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  ADMIN: 'ADMIN',
  AFFILIATE: 'AFFILIATE',
  MANAGER: 'MANAGER'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const UserStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  SUSPENDED: 'SUSPENDED',
  PENDING: 'PENDING'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const PaymentMethod: {
  PAYPAL: 'PAYPAL',
  STRIPE: 'STRIPE',
  BANK_TRANSFER: 'BANK_TRANSFER',
  CRYPTO: 'CRYPTO',
  WISE: 'WISE'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const AffiliateTier: {
  BRONZE: 'BRONZE',
  SILVER: 'SILVER',
  GOLD: 'GOLD',
  PLATINUM: 'PLATINUM'
};

export type AffiliateTier = (typeof AffiliateTier)[keyof typeof AffiliateTier]


export const OfferStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  PAUSED: 'PAUSED',
  EXPIRED: 'EXPIRED'
};

export type OfferStatus = (typeof OfferStatus)[keyof typeof OfferStatus]


export const ApplicationStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type ApplicationStatus = (typeof ApplicationStatus)[keyof typeof ApplicationStatus]


export const ConversionStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  DECLINED: 'DECLINED',
  REFUNDED: 'REFUNDED'
};

export type ConversionStatus = (typeof ConversionStatus)[keyof typeof ConversionStatus]


export const CommissionStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  PAID: 'PAID',
  CANCELLED: 'CANCELLED'
};

export type CommissionStatus = (typeof CommissionStatus)[keyof typeof CommissionStatus]


export const PayoutStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type PayoutStatus = (typeof PayoutStatus)[keyof typeof PayoutStatus]


export const CreativeType: {
  BANNER: 'BANNER',
  LOGO: 'LOGO',
  SOCIAL_MEDIA: 'SOCIAL_MEDIA',
  EMAIL_TEMPLATE: 'EMAIL_TEMPLATE',
  VIDEO: 'VIDEO'
};

export type CreativeType = (typeof CreativeType)[keyof typeof CreativeType]


export const CouponStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  EXPIRED: 'EXPIRED'
};

export type CouponStatus = (typeof CouponStatus)[keyof typeof CouponStatus]


export const NotificationType: {
  INFO: 'INFO',
  SUCCESS: 'SUCCESS',
  WARNING: 'WARNING',
  ERROR: 'ERROR',
  SYSTEM: 'SYSTEM'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const WebhookStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  ERROR: 'ERROR'
};

export type WebhookStatus = (typeof WebhookStatus)[keyof typeof WebhookStatus]


export const RuleType: {
  IP_BLOCKING: 'IP_BLOCKING',
  RATE_LIMITING: 'RATE_LIMITING',
  BOT_DETECTION: 'BOT_DETECTION',
  GEO_BLOCKING: 'GEO_BLOCKING',
  DEVICE_BLOCKING: 'DEVICE_BLOCKING'
};

export type RuleType = (typeof RuleType)[keyof typeof RuleType]


export const RuleAction: {
  BLOCK: 'BLOCK',
  ALLOW: 'ALLOW',
  REDIRECT: 'REDIRECT',
  CAPTCHA: 'CAPTCHA'
};

export type RuleAction = (typeof RuleAction)[keyof typeof RuleAction]


export const RuleStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  TESTING: 'TESTING'
};

export type RuleStatus = (typeof RuleStatus)[keyof typeof RuleStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type AffiliateTier = $Enums.AffiliateTier

export const AffiliateTier: typeof $Enums.AffiliateTier

export type OfferStatus = $Enums.OfferStatus

export const OfferStatus: typeof $Enums.OfferStatus

export type ApplicationStatus = $Enums.ApplicationStatus

export const ApplicationStatus: typeof $Enums.ApplicationStatus

export type ConversionStatus = $Enums.ConversionStatus

export const ConversionStatus: typeof $Enums.ConversionStatus

export type CommissionStatus = $Enums.CommissionStatus

export const CommissionStatus: typeof $Enums.CommissionStatus

export type PayoutStatus = $Enums.PayoutStatus

export const PayoutStatus: typeof $Enums.PayoutStatus

export type CreativeType = $Enums.CreativeType

export const CreativeType: typeof $Enums.CreativeType

export type CouponStatus = $Enums.CouponStatus

export const CouponStatus: typeof $Enums.CouponStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type WebhookStatus = $Enums.WebhookStatus

export const WebhookStatus: typeof $Enums.WebhookStatus

export type RuleType = $Enums.RuleType

export const RuleType: typeof $Enums.RuleType

export type RuleAction = $Enums.RuleAction

export const RuleAction: typeof $Enums.RuleAction

export type RuleStatus = $Enums.RuleStatus

export const RuleStatus: typeof $Enums.RuleStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.affiliateProfile`: Exposes CRUD operations for the **AffiliateProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AffiliateProfiles
    * const affiliateProfiles = await prisma.affiliateProfile.findMany()
    * ```
    */
  get affiliateProfile(): Prisma.AffiliateProfileDelegate<ExtArgs>;

  /**
   * `prisma.adminProfile`: Exposes CRUD operations for the **AdminProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminProfiles
    * const adminProfiles = await prisma.adminProfile.findMany()
    * ```
    */
  get adminProfile(): Prisma.AdminProfileDelegate<ExtArgs>;

  /**
   * `prisma.offer`: Exposes CRUD operations for the **Offer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Offers
    * const offers = await prisma.offer.findMany()
    * ```
    */
  get offer(): Prisma.OfferDelegate<ExtArgs>;

  /**
   * `prisma.offerApplication`: Exposes CRUD operations for the **OfferApplication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OfferApplications
    * const offerApplications = await prisma.offerApplication.findMany()
    * ```
    */
  get offerApplication(): Prisma.OfferApplicationDelegate<ExtArgs>;

  /**
   * `prisma.affiliateLink`: Exposes CRUD operations for the **AffiliateLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AffiliateLinks
    * const affiliateLinks = await prisma.affiliateLink.findMany()
    * ```
    */
  get affiliateLink(): Prisma.AffiliateLinkDelegate<ExtArgs>;

  /**
   * `prisma.click`: Exposes CRUD operations for the **Click** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clicks
    * const clicks = await prisma.click.findMany()
    * ```
    */
  get click(): Prisma.ClickDelegate<ExtArgs>;

  /**
   * `prisma.conversion`: Exposes CRUD operations for the **Conversion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversions
    * const conversions = await prisma.conversion.findMany()
    * ```
    */
  get conversion(): Prisma.ConversionDelegate<ExtArgs>;

  /**
   * `prisma.commission`: Exposes CRUD operations for the **Commission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Commissions
    * const commissions = await prisma.commission.findMany()
    * ```
    */
  get commission(): Prisma.CommissionDelegate<ExtArgs>;

  /**
   * `prisma.payout`: Exposes CRUD operations for the **Payout** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payouts
    * const payouts = await prisma.payout.findMany()
    * ```
    */
  get payout(): Prisma.PayoutDelegate<ExtArgs>;

  /**
   * `prisma.creative`: Exposes CRUD operations for the **Creative** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Creatives
    * const creatives = await prisma.creative.findMany()
    * ```
    */
  get creative(): Prisma.CreativeDelegate<ExtArgs>;

  /**
   * `prisma.coupon`: Exposes CRUD operations for the **Coupon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Coupons
    * const coupons = await prisma.coupon.findMany()
    * ```
    */
  get coupon(): Prisma.CouponDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.activity`: Exposes CRUD operations for the **Activity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activities
    * const activities = await prisma.activity.findMany()
    * ```
    */
  get activity(): Prisma.ActivityDelegate<ExtArgs>;

  /**
   * `prisma.webhook`: Exposes CRUD operations for the **Webhook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Webhooks
    * const webhooks = await prisma.webhook.findMany()
    * ```
    */
  get webhook(): Prisma.WebhookDelegate<ExtArgs>;

  /**
   * `prisma.trafficRule`: Exposes CRUD operations for the **TrafficRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrafficRules
    * const trafficRules = await prisma.trafficRule.findMany()
    * ```
    */
  get trafficRule(): Prisma.TrafficRuleDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Session: 'Session',
    AffiliateProfile: 'AffiliateProfile',
    AdminProfile: 'AdminProfile',
    Offer: 'Offer',
    OfferApplication: 'OfferApplication',
    AffiliateLink: 'AffiliateLink',
    Click: 'Click',
    Conversion: 'Conversion',
    Commission: 'Commission',
    Payout: 'Payout',
    Creative: 'Creative',
    Coupon: 'Coupon',
    Notification: 'Notification',
    Activity: 'Activity',
    Webhook: 'Webhook',
    TrafficRule: 'TrafficRule'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "session" | "affiliateProfile" | "adminProfile" | "offer" | "offerApplication" | "affiliateLink" | "click" | "conversion" | "commission" | "payout" | "creative" | "coupon" | "notification" | "activity" | "webhook" | "trafficRule"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      AffiliateProfile: {
        payload: Prisma.$AffiliateProfilePayload<ExtArgs>
        fields: Prisma.AffiliateProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AffiliateProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AffiliateProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProfilePayload>
          }
          findFirst: {
            args: Prisma.AffiliateProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AffiliateProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProfilePayload>
          }
          findMany: {
            args: Prisma.AffiliateProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProfilePayload>[]
          }
          create: {
            args: Prisma.AffiliateProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProfilePayload>
          }
          createMany: {
            args: Prisma.AffiliateProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AffiliateProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProfilePayload>[]
          }
          delete: {
            args: Prisma.AffiliateProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProfilePayload>
          }
          update: {
            args: Prisma.AffiliateProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProfilePayload>
          }
          deleteMany: {
            args: Prisma.AffiliateProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AffiliateProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AffiliateProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProfilePayload>
          }
          aggregate: {
            args: Prisma.AffiliateProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAffiliateProfile>
          }
          groupBy: {
            args: Prisma.AffiliateProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<AffiliateProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.AffiliateProfileCountArgs<ExtArgs>
            result: $Utils.Optional<AffiliateProfileCountAggregateOutputType> | number
          }
        }
      }
      AdminProfile: {
        payload: Prisma.$AdminProfilePayload<ExtArgs>
        fields: Prisma.AdminProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminProfilePayload>
          }
          findFirst: {
            args: Prisma.AdminProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminProfilePayload>
          }
          findMany: {
            args: Prisma.AdminProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminProfilePayload>[]
          }
          create: {
            args: Prisma.AdminProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminProfilePayload>
          }
          createMany: {
            args: Prisma.AdminProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminProfilePayload>[]
          }
          delete: {
            args: Prisma.AdminProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminProfilePayload>
          }
          update: {
            args: Prisma.AdminProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminProfilePayload>
          }
          deleteMany: {
            args: Prisma.AdminProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminProfilePayload>
          }
          aggregate: {
            args: Prisma.AdminProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminProfile>
          }
          groupBy: {
            args: Prisma.AdminProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminProfileCountArgs<ExtArgs>
            result: $Utils.Optional<AdminProfileCountAggregateOutputType> | number
          }
        }
      }
      Offer: {
        payload: Prisma.$OfferPayload<ExtArgs>
        fields: Prisma.OfferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OfferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OfferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          findFirst: {
            args: Prisma.OfferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OfferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          findMany: {
            args: Prisma.OfferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>[]
          }
          create: {
            args: Prisma.OfferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          createMany: {
            args: Prisma.OfferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OfferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>[]
          }
          delete: {
            args: Prisma.OfferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          update: {
            args: Prisma.OfferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          deleteMany: {
            args: Prisma.OfferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OfferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OfferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferPayload>
          }
          aggregate: {
            args: Prisma.OfferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOffer>
          }
          groupBy: {
            args: Prisma.OfferGroupByArgs<ExtArgs>
            result: $Utils.Optional<OfferGroupByOutputType>[]
          }
          count: {
            args: Prisma.OfferCountArgs<ExtArgs>
            result: $Utils.Optional<OfferCountAggregateOutputType> | number
          }
        }
      }
      OfferApplication: {
        payload: Prisma.$OfferApplicationPayload<ExtArgs>
        fields: Prisma.OfferApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OfferApplicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OfferApplicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferApplicationPayload>
          }
          findFirst: {
            args: Prisma.OfferApplicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OfferApplicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferApplicationPayload>
          }
          findMany: {
            args: Prisma.OfferApplicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferApplicationPayload>[]
          }
          create: {
            args: Prisma.OfferApplicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferApplicationPayload>
          }
          createMany: {
            args: Prisma.OfferApplicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OfferApplicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferApplicationPayload>[]
          }
          delete: {
            args: Prisma.OfferApplicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferApplicationPayload>
          }
          update: {
            args: Prisma.OfferApplicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferApplicationPayload>
          }
          deleteMany: {
            args: Prisma.OfferApplicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OfferApplicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OfferApplicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OfferApplicationPayload>
          }
          aggregate: {
            args: Prisma.OfferApplicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOfferApplication>
          }
          groupBy: {
            args: Prisma.OfferApplicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OfferApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OfferApplicationCountArgs<ExtArgs>
            result: $Utils.Optional<OfferApplicationCountAggregateOutputType> | number
          }
        }
      }
      AffiliateLink: {
        payload: Prisma.$AffiliateLinkPayload<ExtArgs>
        fields: Prisma.AffiliateLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AffiliateLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AffiliateLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateLinkPayload>
          }
          findFirst: {
            args: Prisma.AffiliateLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AffiliateLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateLinkPayload>
          }
          findMany: {
            args: Prisma.AffiliateLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateLinkPayload>[]
          }
          create: {
            args: Prisma.AffiliateLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateLinkPayload>
          }
          createMany: {
            args: Prisma.AffiliateLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AffiliateLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateLinkPayload>[]
          }
          delete: {
            args: Prisma.AffiliateLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateLinkPayload>
          }
          update: {
            args: Prisma.AffiliateLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateLinkPayload>
          }
          deleteMany: {
            args: Prisma.AffiliateLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AffiliateLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AffiliateLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateLinkPayload>
          }
          aggregate: {
            args: Prisma.AffiliateLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAffiliateLink>
          }
          groupBy: {
            args: Prisma.AffiliateLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<AffiliateLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.AffiliateLinkCountArgs<ExtArgs>
            result: $Utils.Optional<AffiliateLinkCountAggregateOutputType> | number
          }
        }
      }
      Click: {
        payload: Prisma.$ClickPayload<ExtArgs>
        fields: Prisma.ClickFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClickFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClickPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClickFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClickPayload>
          }
          findFirst: {
            args: Prisma.ClickFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClickPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClickFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClickPayload>
          }
          findMany: {
            args: Prisma.ClickFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClickPayload>[]
          }
          create: {
            args: Prisma.ClickCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClickPayload>
          }
          createMany: {
            args: Prisma.ClickCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClickCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClickPayload>[]
          }
          delete: {
            args: Prisma.ClickDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClickPayload>
          }
          update: {
            args: Prisma.ClickUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClickPayload>
          }
          deleteMany: {
            args: Prisma.ClickDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClickUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClickUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClickPayload>
          }
          aggregate: {
            args: Prisma.ClickAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClick>
          }
          groupBy: {
            args: Prisma.ClickGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClickGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClickCountArgs<ExtArgs>
            result: $Utils.Optional<ClickCountAggregateOutputType> | number
          }
        }
      }
      Conversion: {
        payload: Prisma.$ConversionPayload<ExtArgs>
        fields: Prisma.ConversionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionPayload>
          }
          findFirst: {
            args: Prisma.ConversionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionPayload>
          }
          findMany: {
            args: Prisma.ConversionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionPayload>[]
          }
          create: {
            args: Prisma.ConversionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionPayload>
          }
          createMany: {
            args: Prisma.ConversionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionPayload>[]
          }
          delete: {
            args: Prisma.ConversionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionPayload>
          }
          update: {
            args: Prisma.ConversionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionPayload>
          }
          deleteMany: {
            args: Prisma.ConversionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConversionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionPayload>
          }
          aggregate: {
            args: Prisma.ConversionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversion>
          }
          groupBy: {
            args: Prisma.ConversionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversionCountArgs<ExtArgs>
            result: $Utils.Optional<ConversionCountAggregateOutputType> | number
          }
        }
      }
      Commission: {
        payload: Prisma.$CommissionPayload<ExtArgs>
        fields: Prisma.CommissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionPayload>
          }
          findFirst: {
            args: Prisma.CommissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionPayload>
          }
          findMany: {
            args: Prisma.CommissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionPayload>[]
          }
          create: {
            args: Prisma.CommissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionPayload>
          }
          createMany: {
            args: Prisma.CommissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionPayload>[]
          }
          delete: {
            args: Prisma.CommissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionPayload>
          }
          update: {
            args: Prisma.CommissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionPayload>
          }
          deleteMany: {
            args: Prisma.CommissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionPayload>
          }
          aggregate: {
            args: Prisma.CommissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommission>
          }
          groupBy: {
            args: Prisma.CommissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommissionCountArgs<ExtArgs>
            result: $Utils.Optional<CommissionCountAggregateOutputType> | number
          }
        }
      }
      Payout: {
        payload: Prisma.$PayoutPayload<ExtArgs>
        fields: Prisma.PayoutFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PayoutFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PayoutFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload>
          }
          findFirst: {
            args: Prisma.PayoutFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PayoutFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload>
          }
          findMany: {
            args: Prisma.PayoutFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload>[]
          }
          create: {
            args: Prisma.PayoutCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload>
          }
          createMany: {
            args: Prisma.PayoutCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PayoutCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload>[]
          }
          delete: {
            args: Prisma.PayoutDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload>
          }
          update: {
            args: Prisma.PayoutUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload>
          }
          deleteMany: {
            args: Prisma.PayoutDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PayoutUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PayoutUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload>
          }
          aggregate: {
            args: Prisma.PayoutAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayout>
          }
          groupBy: {
            args: Prisma.PayoutGroupByArgs<ExtArgs>
            result: $Utils.Optional<PayoutGroupByOutputType>[]
          }
          count: {
            args: Prisma.PayoutCountArgs<ExtArgs>
            result: $Utils.Optional<PayoutCountAggregateOutputType> | number
          }
        }
      }
      Creative: {
        payload: Prisma.$CreativePayload<ExtArgs>
        fields: Prisma.CreativeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreativeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreativePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreativeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreativePayload>
          }
          findFirst: {
            args: Prisma.CreativeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreativePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreativeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreativePayload>
          }
          findMany: {
            args: Prisma.CreativeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreativePayload>[]
          }
          create: {
            args: Prisma.CreativeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreativePayload>
          }
          createMany: {
            args: Prisma.CreativeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreativeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreativePayload>[]
          }
          delete: {
            args: Prisma.CreativeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreativePayload>
          }
          update: {
            args: Prisma.CreativeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreativePayload>
          }
          deleteMany: {
            args: Prisma.CreativeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreativeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CreativeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreativePayload>
          }
          aggregate: {
            args: Prisma.CreativeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreative>
          }
          groupBy: {
            args: Prisma.CreativeGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreativeGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreativeCountArgs<ExtArgs>
            result: $Utils.Optional<CreativeCountAggregateOutputType> | number
          }
        }
      }
      Coupon: {
        payload: Prisma.$CouponPayload<ExtArgs>
        fields: Prisma.CouponFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CouponFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CouponFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          findFirst: {
            args: Prisma.CouponFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CouponFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          findMany: {
            args: Prisma.CouponFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>[]
          }
          create: {
            args: Prisma.CouponCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          createMany: {
            args: Prisma.CouponCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CouponCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>[]
          }
          delete: {
            args: Prisma.CouponDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          update: {
            args: Prisma.CouponUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          deleteMany: {
            args: Prisma.CouponDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CouponUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CouponUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          aggregate: {
            args: Prisma.CouponAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoupon>
          }
          groupBy: {
            args: Prisma.CouponGroupByArgs<ExtArgs>
            result: $Utils.Optional<CouponGroupByOutputType>[]
          }
          count: {
            args: Prisma.CouponCountArgs<ExtArgs>
            result: $Utils.Optional<CouponCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Activity: {
        payload: Prisma.$ActivityPayload<ExtArgs>
        fields: Prisma.ActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findFirst: {
            args: Prisma.ActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          findMany: {
            args: Prisma.ActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          create: {
            args: Prisma.ActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          createMany: {
            args: Prisma.ActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>[]
          }
          delete: {
            args: Prisma.ActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          update: {
            args: Prisma.ActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          deleteMany: {
            args: Prisma.ActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityPayload>
          }
          aggregate: {
            args: Prisma.ActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivity>
          }
          groupBy: {
            args: Prisma.ActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityCountAggregateOutputType> | number
          }
        }
      }
      Webhook: {
        payload: Prisma.$WebhookPayload<ExtArgs>
        fields: Prisma.WebhookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          findFirst: {
            args: Prisma.WebhookFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          findMany: {
            args: Prisma.WebhookFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>[]
          }
          create: {
            args: Prisma.WebhookCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          createMany: {
            args: Prisma.WebhookCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebhookCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>[]
          }
          delete: {
            args: Prisma.WebhookDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          update: {
            args: Prisma.WebhookUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          deleteMany: {
            args: Prisma.WebhookDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WebhookUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookPayload>
          }
          aggregate: {
            args: Prisma.WebhookAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhook>
          }
          groupBy: {
            args: Prisma.WebhookGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookCountAggregateOutputType> | number
          }
        }
      }
      TrafficRule: {
        payload: Prisma.$TrafficRulePayload<ExtArgs>
        fields: Prisma.TrafficRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrafficRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrafficRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrafficRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrafficRulePayload>
          }
          findFirst: {
            args: Prisma.TrafficRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrafficRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrafficRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrafficRulePayload>
          }
          findMany: {
            args: Prisma.TrafficRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrafficRulePayload>[]
          }
          create: {
            args: Prisma.TrafficRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrafficRulePayload>
          }
          createMany: {
            args: Prisma.TrafficRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrafficRuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrafficRulePayload>[]
          }
          delete: {
            args: Prisma.TrafficRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrafficRulePayload>
          }
          update: {
            args: Prisma.TrafficRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrafficRulePayload>
          }
          deleteMany: {
            args: Prisma.TrafficRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrafficRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TrafficRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrafficRulePayload>
          }
          aggregate: {
            args: Prisma.TrafficRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrafficRule>
          }
          groupBy: {
            args: Prisma.TrafficRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrafficRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrafficRuleCountArgs<ExtArgs>
            result: $Utils.Optional<TrafficRuleCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
    notifications: number
    activities: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    activities?: boolean | UserCountOutputTypeCountActivitiesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
  }


  /**
   * Count Type AffiliateProfileCountOutputType
   */

  export type AffiliateProfileCountOutputType = {
    clicks: number
    conversions: number
    commissions: number
    payouts: number
    links: number
    coupons: number
    applications: number
  }

  export type AffiliateProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clicks?: boolean | AffiliateProfileCountOutputTypeCountClicksArgs
    conversions?: boolean | AffiliateProfileCountOutputTypeCountConversionsArgs
    commissions?: boolean | AffiliateProfileCountOutputTypeCountCommissionsArgs
    payouts?: boolean | AffiliateProfileCountOutputTypeCountPayoutsArgs
    links?: boolean | AffiliateProfileCountOutputTypeCountLinksArgs
    coupons?: boolean | AffiliateProfileCountOutputTypeCountCouponsArgs
    applications?: boolean | AffiliateProfileCountOutputTypeCountApplicationsArgs
  }

  // Custom InputTypes
  /**
   * AffiliateProfileCountOutputType without action
   */
  export type AffiliateProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProfileCountOutputType
     */
    select?: AffiliateProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AffiliateProfileCountOutputType without action
   */
  export type AffiliateProfileCountOutputTypeCountClicksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClickWhereInput
  }

  /**
   * AffiliateProfileCountOutputType without action
   */
  export type AffiliateProfileCountOutputTypeCountConversionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversionWhereInput
  }

  /**
   * AffiliateProfileCountOutputType without action
   */
  export type AffiliateProfileCountOutputTypeCountCommissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommissionWhereInput
  }

  /**
   * AffiliateProfileCountOutputType without action
   */
  export type AffiliateProfileCountOutputTypeCountPayoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayoutWhereInput
  }

  /**
   * AffiliateProfileCountOutputType without action
   */
  export type AffiliateProfileCountOutputTypeCountLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliateLinkWhereInput
  }

  /**
   * AffiliateProfileCountOutputType without action
   */
  export type AffiliateProfileCountOutputTypeCountCouponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CouponWhereInput
  }

  /**
   * AffiliateProfileCountOutputType without action
   */
  export type AffiliateProfileCountOutputTypeCountApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferApplicationWhereInput
  }


  /**
   * Count Type OfferCountOutputType
   */

  export type OfferCountOutputType = {
    applications: number
    conversions: number
    links: number
    creatives: number
  }

  export type OfferCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applications?: boolean | OfferCountOutputTypeCountApplicationsArgs
    conversions?: boolean | OfferCountOutputTypeCountConversionsArgs
    links?: boolean | OfferCountOutputTypeCountLinksArgs
    creatives?: boolean | OfferCountOutputTypeCountCreativesArgs
  }

  // Custom InputTypes
  /**
   * OfferCountOutputType without action
   */
  export type OfferCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferCountOutputType
     */
    select?: OfferCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OfferCountOutputType without action
   */
  export type OfferCountOutputTypeCountApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferApplicationWhereInput
  }

  /**
   * OfferCountOutputType without action
   */
  export type OfferCountOutputTypeCountConversionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversionWhereInput
  }

  /**
   * OfferCountOutputType without action
   */
  export type OfferCountOutputTypeCountLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliateLinkWhereInput
  }

  /**
   * OfferCountOutputType without action
   */
  export type OfferCountOutputTypeCountCreativesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreativeWhereInput
  }


  /**
   * Count Type AffiliateLinkCountOutputType
   */

  export type AffiliateLinkCountOutputType = {
    clickRecords: number
  }

  export type AffiliateLinkCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clickRecords?: boolean | AffiliateLinkCountOutputTypeCountClickRecordsArgs
  }

  // Custom InputTypes
  /**
   * AffiliateLinkCountOutputType without action
   */
  export type AffiliateLinkCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLinkCountOutputType
     */
    select?: AffiliateLinkCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AffiliateLinkCountOutputType without action
   */
  export type AffiliateLinkCountOutputTypeCountClickRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClickWhereInput
  }


  /**
   * Count Type PayoutCountOutputType
   */

  export type PayoutCountOutputType = {
    commissions: number
  }

  export type PayoutCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    commissions?: boolean | PayoutCountOutputTypeCountCommissionsArgs
  }

  // Custom InputTypes
  /**
   * PayoutCountOutputType without action
   */
  export type PayoutCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayoutCountOutputType
     */
    select?: PayoutCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PayoutCountOutputType without action
   */
  export type PayoutCountOutputTypeCountCommissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommissionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.UserRole | null
    status: $Enums.UserStatus | null
    avatar: string | null
    phone: string | null
    timezone: string | null
    language: string | null
    twoFactorEnabled: boolean | null
    twoFactorSecret: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.UserRole | null
    status: $Enums.UserStatus | null
    avatar: string | null
    phone: string | null
    timezone: string | null
    language: string | null
    twoFactorEnabled: boolean | null
    twoFactorSecret: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    firstName: number
    lastName: number
    role: number
    status: number
    avatar: number
    phone: number
    timezone: number
    language: number
    twoFactorEnabled: number
    twoFactorSecret: number
    createdAt: number
    updatedAt: number
    lastLoginAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    role?: true
    status?: true
    avatar?: true
    phone?: true
    timezone?: true
    language?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    role?: true
    status?: true
    avatar?: true
    phone?: true
    timezone?: true
    language?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    role?: true
    status?: true
    avatar?: true
    phone?: true
    timezone?: true
    language?: true
    twoFactorEnabled?: true
    twoFactorSecret?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    status: $Enums.UserStatus
    avatar: string | null
    phone: string | null
    timezone: string
    language: string
    twoFactorEnabled: boolean
    twoFactorSecret: string | null
    createdAt: Date
    updatedAt: Date
    lastLoginAt: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    status?: boolean
    avatar?: boolean
    phone?: boolean
    timezone?: boolean
    language?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
    affiliateProfile?: boolean | User$affiliateProfileArgs<ExtArgs>
    adminProfile?: boolean | User$adminProfileArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    activities?: boolean | User$activitiesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    status?: boolean
    avatar?: boolean
    phone?: boolean
    timezone?: boolean
    language?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    status?: boolean
    avatar?: boolean
    phone?: boolean
    timezone?: boolean
    language?: boolean
    twoFactorEnabled?: boolean
    twoFactorSecret?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliateProfile?: boolean | User$affiliateProfileArgs<ExtArgs>
    adminProfile?: boolean | User$adminProfileArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    activities?: boolean | User$activitiesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      affiliateProfile: Prisma.$AffiliateProfilePayload<ExtArgs> | null
      adminProfile: Prisma.$AdminProfilePayload<ExtArgs> | null
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      activities: Prisma.$ActivityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      firstName: string
      lastName: string
      role: $Enums.UserRole
      status: $Enums.UserStatus
      avatar: string | null
      phone: string | null
      timezone: string
      language: string
      twoFactorEnabled: boolean
      twoFactorSecret: string | null
      createdAt: Date
      updatedAt: Date
      lastLoginAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    affiliateProfile<T extends User$affiliateProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$affiliateProfileArgs<ExtArgs>>): Prisma__AffiliateProfileClient<$Result.GetResult<Prisma.$AffiliateProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    adminProfile<T extends User$adminProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$adminProfileArgs<ExtArgs>>): Prisma__AdminProfileClient<$Result.GetResult<Prisma.$AdminProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    activities<T extends User$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly status: FieldRef<"User", 'UserStatus'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly timezone: FieldRef<"User", 'String'>
    readonly language: FieldRef<"User", 'String'>
    readonly twoFactorEnabled: FieldRef<"User", 'Boolean'>
    readonly twoFactorSecret: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.affiliateProfile
   */
  export type User$affiliateProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProfile
     */
    select?: AffiliateProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProfileInclude<ExtArgs> | null
    where?: AffiliateProfileWhereInput
  }

  /**
   * User.adminProfile
   */
  export type User$adminProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminProfile
     */
    select?: AdminProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminProfileInclude<ExtArgs> | null
    where?: AdminProfileWhereInput
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.activities
   */
  export type User$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    cursor?: ActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    token: string
    expiresAt: Date
    createdAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly token: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model AffiliateProfile
   */

  export type AggregateAffiliateProfile = {
    _count: AffiliateProfileCountAggregateOutputType | null
    _avg: AffiliateProfileAvgAggregateOutputType | null
    _sum: AffiliateProfileSumAggregateOutputType | null
    _min: AffiliateProfileMinAggregateOutputType | null
    _max: AffiliateProfileMaxAggregateOutputType | null
  }

  export type AffiliateProfileAvgAggregateOutputType = {
    commissionRate: number | null
    totalEarnings: number | null
    totalClicks: number | null
    totalConversions: number | null
    conversionRate: number | null
  }

  export type AffiliateProfileSumAggregateOutputType = {
    commissionRate: number | null
    totalEarnings: number | null
    totalClicks: number | null
    totalConversions: number | null
    conversionRate: number | null
  }

  export type AffiliateProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    companyName: string | null
    website: string | null
    paymentMethod: $Enums.PaymentMethod | null
    paymentEmail: string | null
    taxId: string | null
    tier: $Enums.AffiliateTier | null
    commissionRate: number | null
    totalEarnings: number | null
    totalClicks: number | null
    totalConversions: number | null
    conversionRate: number | null
    lastActivityAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AffiliateProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    companyName: string | null
    website: string | null
    paymentMethod: $Enums.PaymentMethod | null
    paymentEmail: string | null
    taxId: string | null
    tier: $Enums.AffiliateTier | null
    commissionRate: number | null
    totalEarnings: number | null
    totalClicks: number | null
    totalConversions: number | null
    conversionRate: number | null
    lastActivityAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AffiliateProfileCountAggregateOutputType = {
    id: number
    userId: number
    companyName: number
    website: number
    socialMedia: number
    paymentMethod: number
    paymentEmail: number
    taxId: number
    address: number
    tier: number
    commissionRate: number
    totalEarnings: number
    totalClicks: number
    totalConversions: number
    conversionRate: number
    lastActivityAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AffiliateProfileAvgAggregateInputType = {
    commissionRate?: true
    totalEarnings?: true
    totalClicks?: true
    totalConversions?: true
    conversionRate?: true
  }

  export type AffiliateProfileSumAggregateInputType = {
    commissionRate?: true
    totalEarnings?: true
    totalClicks?: true
    totalConversions?: true
    conversionRate?: true
  }

  export type AffiliateProfileMinAggregateInputType = {
    id?: true
    userId?: true
    companyName?: true
    website?: true
    paymentMethod?: true
    paymentEmail?: true
    taxId?: true
    tier?: true
    commissionRate?: true
    totalEarnings?: true
    totalClicks?: true
    totalConversions?: true
    conversionRate?: true
    lastActivityAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AffiliateProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    companyName?: true
    website?: true
    paymentMethod?: true
    paymentEmail?: true
    taxId?: true
    tier?: true
    commissionRate?: true
    totalEarnings?: true
    totalClicks?: true
    totalConversions?: true
    conversionRate?: true
    lastActivityAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AffiliateProfileCountAggregateInputType = {
    id?: true
    userId?: true
    companyName?: true
    website?: true
    socialMedia?: true
    paymentMethod?: true
    paymentEmail?: true
    taxId?: true
    address?: true
    tier?: true
    commissionRate?: true
    totalEarnings?: true
    totalClicks?: true
    totalConversions?: true
    conversionRate?: true
    lastActivityAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AffiliateProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AffiliateProfile to aggregate.
     */
    where?: AffiliateProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateProfiles to fetch.
     */
    orderBy?: AffiliateProfileOrderByWithRelationInput | AffiliateProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AffiliateProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AffiliateProfiles
    **/
    _count?: true | AffiliateProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AffiliateProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AffiliateProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AffiliateProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AffiliateProfileMaxAggregateInputType
  }

  export type GetAffiliateProfileAggregateType<T extends AffiliateProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateAffiliateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAffiliateProfile[P]>
      : GetScalarType<T[P], AggregateAffiliateProfile[P]>
  }




  export type AffiliateProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliateProfileWhereInput
    orderBy?: AffiliateProfileOrderByWithAggregationInput | AffiliateProfileOrderByWithAggregationInput[]
    by: AffiliateProfileScalarFieldEnum[] | AffiliateProfileScalarFieldEnum
    having?: AffiliateProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AffiliateProfileCountAggregateInputType | true
    _avg?: AffiliateProfileAvgAggregateInputType
    _sum?: AffiliateProfileSumAggregateInputType
    _min?: AffiliateProfileMinAggregateInputType
    _max?: AffiliateProfileMaxAggregateInputType
  }

  export type AffiliateProfileGroupByOutputType = {
    id: string
    userId: string
    companyName: string | null
    website: string | null
    socialMedia: JsonValue | null
    paymentMethod: $Enums.PaymentMethod
    paymentEmail: string | null
    taxId: string | null
    address: JsonValue | null
    tier: $Enums.AffiliateTier
    commissionRate: number
    totalEarnings: number
    totalClicks: number
    totalConversions: number
    conversionRate: number
    lastActivityAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: AffiliateProfileCountAggregateOutputType | null
    _avg: AffiliateProfileAvgAggregateOutputType | null
    _sum: AffiliateProfileSumAggregateOutputType | null
    _min: AffiliateProfileMinAggregateOutputType | null
    _max: AffiliateProfileMaxAggregateOutputType | null
  }

  type GetAffiliateProfileGroupByPayload<T extends AffiliateProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AffiliateProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AffiliateProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AffiliateProfileGroupByOutputType[P]>
            : GetScalarType<T[P], AffiliateProfileGroupByOutputType[P]>
        }
      >
    >


  export type AffiliateProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyName?: boolean
    website?: boolean
    socialMedia?: boolean
    paymentMethod?: boolean
    paymentEmail?: boolean
    taxId?: boolean
    address?: boolean
    tier?: boolean
    commissionRate?: boolean
    totalEarnings?: boolean
    totalClicks?: boolean
    totalConversions?: boolean
    conversionRate?: boolean
    lastActivityAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    clicks?: boolean | AffiliateProfile$clicksArgs<ExtArgs>
    conversions?: boolean | AffiliateProfile$conversionsArgs<ExtArgs>
    commissions?: boolean | AffiliateProfile$commissionsArgs<ExtArgs>
    payouts?: boolean | AffiliateProfile$payoutsArgs<ExtArgs>
    links?: boolean | AffiliateProfile$linksArgs<ExtArgs>
    coupons?: boolean | AffiliateProfile$couponsArgs<ExtArgs>
    applications?: boolean | AffiliateProfile$applicationsArgs<ExtArgs>
    _count?: boolean | AffiliateProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["affiliateProfile"]>

  export type AffiliateProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyName?: boolean
    website?: boolean
    socialMedia?: boolean
    paymentMethod?: boolean
    paymentEmail?: boolean
    taxId?: boolean
    address?: boolean
    tier?: boolean
    commissionRate?: boolean
    totalEarnings?: boolean
    totalClicks?: boolean
    totalConversions?: boolean
    conversionRate?: boolean
    lastActivityAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["affiliateProfile"]>

  export type AffiliateProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    companyName?: boolean
    website?: boolean
    socialMedia?: boolean
    paymentMethod?: boolean
    paymentEmail?: boolean
    taxId?: boolean
    address?: boolean
    tier?: boolean
    commissionRate?: boolean
    totalEarnings?: boolean
    totalClicks?: boolean
    totalConversions?: boolean
    conversionRate?: boolean
    lastActivityAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AffiliateProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    clicks?: boolean | AffiliateProfile$clicksArgs<ExtArgs>
    conversions?: boolean | AffiliateProfile$conversionsArgs<ExtArgs>
    commissions?: boolean | AffiliateProfile$commissionsArgs<ExtArgs>
    payouts?: boolean | AffiliateProfile$payoutsArgs<ExtArgs>
    links?: boolean | AffiliateProfile$linksArgs<ExtArgs>
    coupons?: boolean | AffiliateProfile$couponsArgs<ExtArgs>
    applications?: boolean | AffiliateProfile$applicationsArgs<ExtArgs>
    _count?: boolean | AffiliateProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AffiliateProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AffiliateProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AffiliateProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      clicks: Prisma.$ClickPayload<ExtArgs>[]
      conversions: Prisma.$ConversionPayload<ExtArgs>[]
      commissions: Prisma.$CommissionPayload<ExtArgs>[]
      payouts: Prisma.$PayoutPayload<ExtArgs>[]
      links: Prisma.$AffiliateLinkPayload<ExtArgs>[]
      coupons: Prisma.$CouponPayload<ExtArgs>[]
      applications: Prisma.$OfferApplicationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      companyName: string | null
      website: string | null
      socialMedia: Prisma.JsonValue | null
      paymentMethod: $Enums.PaymentMethod
      paymentEmail: string | null
      taxId: string | null
      address: Prisma.JsonValue | null
      tier: $Enums.AffiliateTier
      commissionRate: number
      totalEarnings: number
      totalClicks: number
      totalConversions: number
      conversionRate: number
      lastActivityAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["affiliateProfile"]>
    composites: {}
  }

  type AffiliateProfileGetPayload<S extends boolean | null | undefined | AffiliateProfileDefaultArgs> = $Result.GetResult<Prisma.$AffiliateProfilePayload, S>

  type AffiliateProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AffiliateProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AffiliateProfileCountAggregateInputType | true
    }

  export interface AffiliateProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AffiliateProfile'], meta: { name: 'AffiliateProfile' } }
    /**
     * Find zero or one AffiliateProfile that matches the filter.
     * @param {AffiliateProfileFindUniqueArgs} args - Arguments to find a AffiliateProfile
     * @example
     * // Get one AffiliateProfile
     * const affiliateProfile = await prisma.affiliateProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AffiliateProfileFindUniqueArgs>(args: SelectSubset<T, AffiliateProfileFindUniqueArgs<ExtArgs>>): Prisma__AffiliateProfileClient<$Result.GetResult<Prisma.$AffiliateProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AffiliateProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AffiliateProfileFindUniqueOrThrowArgs} args - Arguments to find a AffiliateProfile
     * @example
     * // Get one AffiliateProfile
     * const affiliateProfile = await prisma.affiliateProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AffiliateProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, AffiliateProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AffiliateProfileClient<$Result.GetResult<Prisma.$AffiliateProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AffiliateProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateProfileFindFirstArgs} args - Arguments to find a AffiliateProfile
     * @example
     * // Get one AffiliateProfile
     * const affiliateProfile = await prisma.affiliateProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AffiliateProfileFindFirstArgs>(args?: SelectSubset<T, AffiliateProfileFindFirstArgs<ExtArgs>>): Prisma__AffiliateProfileClient<$Result.GetResult<Prisma.$AffiliateProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AffiliateProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateProfileFindFirstOrThrowArgs} args - Arguments to find a AffiliateProfile
     * @example
     * // Get one AffiliateProfile
     * const affiliateProfile = await prisma.affiliateProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AffiliateProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, AffiliateProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__AffiliateProfileClient<$Result.GetResult<Prisma.$AffiliateProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AffiliateProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AffiliateProfiles
     * const affiliateProfiles = await prisma.affiliateProfile.findMany()
     * 
     * // Get first 10 AffiliateProfiles
     * const affiliateProfiles = await prisma.affiliateProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const affiliateProfileWithIdOnly = await prisma.affiliateProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AffiliateProfileFindManyArgs>(args?: SelectSubset<T, AffiliateProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AffiliateProfile.
     * @param {AffiliateProfileCreateArgs} args - Arguments to create a AffiliateProfile.
     * @example
     * // Create one AffiliateProfile
     * const AffiliateProfile = await prisma.affiliateProfile.create({
     *   data: {
     *     // ... data to create a AffiliateProfile
     *   }
     * })
     * 
     */
    create<T extends AffiliateProfileCreateArgs>(args: SelectSubset<T, AffiliateProfileCreateArgs<ExtArgs>>): Prisma__AffiliateProfileClient<$Result.GetResult<Prisma.$AffiliateProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AffiliateProfiles.
     * @param {AffiliateProfileCreateManyArgs} args - Arguments to create many AffiliateProfiles.
     * @example
     * // Create many AffiliateProfiles
     * const affiliateProfile = await prisma.affiliateProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AffiliateProfileCreateManyArgs>(args?: SelectSubset<T, AffiliateProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AffiliateProfiles and returns the data saved in the database.
     * @param {AffiliateProfileCreateManyAndReturnArgs} args - Arguments to create many AffiliateProfiles.
     * @example
     * // Create many AffiliateProfiles
     * const affiliateProfile = await prisma.affiliateProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AffiliateProfiles and only return the `id`
     * const affiliateProfileWithIdOnly = await prisma.affiliateProfile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AffiliateProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, AffiliateProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AffiliateProfile.
     * @param {AffiliateProfileDeleteArgs} args - Arguments to delete one AffiliateProfile.
     * @example
     * // Delete one AffiliateProfile
     * const AffiliateProfile = await prisma.affiliateProfile.delete({
     *   where: {
     *     // ... filter to delete one AffiliateProfile
     *   }
     * })
     * 
     */
    delete<T extends AffiliateProfileDeleteArgs>(args: SelectSubset<T, AffiliateProfileDeleteArgs<ExtArgs>>): Prisma__AffiliateProfileClient<$Result.GetResult<Prisma.$AffiliateProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AffiliateProfile.
     * @param {AffiliateProfileUpdateArgs} args - Arguments to update one AffiliateProfile.
     * @example
     * // Update one AffiliateProfile
     * const affiliateProfile = await prisma.affiliateProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AffiliateProfileUpdateArgs>(args: SelectSubset<T, AffiliateProfileUpdateArgs<ExtArgs>>): Prisma__AffiliateProfileClient<$Result.GetResult<Prisma.$AffiliateProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AffiliateProfiles.
     * @param {AffiliateProfileDeleteManyArgs} args - Arguments to filter AffiliateProfiles to delete.
     * @example
     * // Delete a few AffiliateProfiles
     * const { count } = await prisma.affiliateProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AffiliateProfileDeleteManyArgs>(args?: SelectSubset<T, AffiliateProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AffiliateProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AffiliateProfiles
     * const affiliateProfile = await prisma.affiliateProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AffiliateProfileUpdateManyArgs>(args: SelectSubset<T, AffiliateProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AffiliateProfile.
     * @param {AffiliateProfileUpsertArgs} args - Arguments to update or create a AffiliateProfile.
     * @example
     * // Update or create a AffiliateProfile
     * const affiliateProfile = await prisma.affiliateProfile.upsert({
     *   create: {
     *     // ... data to create a AffiliateProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AffiliateProfile we want to update
     *   }
     * })
     */
    upsert<T extends AffiliateProfileUpsertArgs>(args: SelectSubset<T, AffiliateProfileUpsertArgs<ExtArgs>>): Prisma__AffiliateProfileClient<$Result.GetResult<Prisma.$AffiliateProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AffiliateProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateProfileCountArgs} args - Arguments to filter AffiliateProfiles to count.
     * @example
     * // Count the number of AffiliateProfiles
     * const count = await prisma.affiliateProfile.count({
     *   where: {
     *     // ... the filter for the AffiliateProfiles we want to count
     *   }
     * })
    **/
    count<T extends AffiliateProfileCountArgs>(
      args?: Subset<T, AffiliateProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AffiliateProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AffiliateProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AffiliateProfileAggregateArgs>(args: Subset<T, AffiliateProfileAggregateArgs>): Prisma.PrismaPromise<GetAffiliateProfileAggregateType<T>>

    /**
     * Group by AffiliateProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AffiliateProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AffiliateProfileGroupByArgs['orderBy'] }
        : { orderBy?: AffiliateProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AffiliateProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAffiliateProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AffiliateProfile model
   */
  readonly fields: AffiliateProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AffiliateProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AffiliateProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    clicks<T extends AffiliateProfile$clicksArgs<ExtArgs> = {}>(args?: Subset<T, AffiliateProfile$clicksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClickPayload<ExtArgs>, T, "findMany"> | Null>
    conversions<T extends AffiliateProfile$conversionsArgs<ExtArgs> = {}>(args?: Subset<T, AffiliateProfile$conversionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversionPayload<ExtArgs>, T, "findMany"> | Null>
    commissions<T extends AffiliateProfile$commissionsArgs<ExtArgs> = {}>(args?: Subset<T, AffiliateProfile$commissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommissionPayload<ExtArgs>, T, "findMany"> | Null>
    payouts<T extends AffiliateProfile$payoutsArgs<ExtArgs> = {}>(args?: Subset<T, AffiliateProfile$payoutsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "findMany"> | Null>
    links<T extends AffiliateProfile$linksArgs<ExtArgs> = {}>(args?: Subset<T, AffiliateProfile$linksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateLinkPayload<ExtArgs>, T, "findMany"> | Null>
    coupons<T extends AffiliateProfile$couponsArgs<ExtArgs> = {}>(args?: Subset<T, AffiliateProfile$couponsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findMany"> | Null>
    applications<T extends AffiliateProfile$applicationsArgs<ExtArgs> = {}>(args?: Subset<T, AffiliateProfile$applicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferApplicationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AffiliateProfile model
   */ 
  interface AffiliateProfileFieldRefs {
    readonly id: FieldRef<"AffiliateProfile", 'String'>
    readonly userId: FieldRef<"AffiliateProfile", 'String'>
    readonly companyName: FieldRef<"AffiliateProfile", 'String'>
    readonly website: FieldRef<"AffiliateProfile", 'String'>
    readonly socialMedia: FieldRef<"AffiliateProfile", 'Json'>
    readonly paymentMethod: FieldRef<"AffiliateProfile", 'PaymentMethod'>
    readonly paymentEmail: FieldRef<"AffiliateProfile", 'String'>
    readonly taxId: FieldRef<"AffiliateProfile", 'String'>
    readonly address: FieldRef<"AffiliateProfile", 'Json'>
    readonly tier: FieldRef<"AffiliateProfile", 'AffiliateTier'>
    readonly commissionRate: FieldRef<"AffiliateProfile", 'Float'>
    readonly totalEarnings: FieldRef<"AffiliateProfile", 'Float'>
    readonly totalClicks: FieldRef<"AffiliateProfile", 'Int'>
    readonly totalConversions: FieldRef<"AffiliateProfile", 'Int'>
    readonly conversionRate: FieldRef<"AffiliateProfile", 'Float'>
    readonly lastActivityAt: FieldRef<"AffiliateProfile", 'DateTime'>
    readonly createdAt: FieldRef<"AffiliateProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"AffiliateProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AffiliateProfile findUnique
   */
  export type AffiliateProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProfile
     */
    select?: AffiliateProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProfileInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateProfile to fetch.
     */
    where: AffiliateProfileWhereUniqueInput
  }

  /**
   * AffiliateProfile findUniqueOrThrow
   */
  export type AffiliateProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProfile
     */
    select?: AffiliateProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProfileInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateProfile to fetch.
     */
    where: AffiliateProfileWhereUniqueInput
  }

  /**
   * AffiliateProfile findFirst
   */
  export type AffiliateProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProfile
     */
    select?: AffiliateProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProfileInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateProfile to fetch.
     */
    where?: AffiliateProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateProfiles to fetch.
     */
    orderBy?: AffiliateProfileOrderByWithRelationInput | AffiliateProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AffiliateProfiles.
     */
    cursor?: AffiliateProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AffiliateProfiles.
     */
    distinct?: AffiliateProfileScalarFieldEnum | AffiliateProfileScalarFieldEnum[]
  }

  /**
   * AffiliateProfile findFirstOrThrow
   */
  export type AffiliateProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProfile
     */
    select?: AffiliateProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProfileInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateProfile to fetch.
     */
    where?: AffiliateProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateProfiles to fetch.
     */
    orderBy?: AffiliateProfileOrderByWithRelationInput | AffiliateProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AffiliateProfiles.
     */
    cursor?: AffiliateProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AffiliateProfiles.
     */
    distinct?: AffiliateProfileScalarFieldEnum | AffiliateProfileScalarFieldEnum[]
  }

  /**
   * AffiliateProfile findMany
   */
  export type AffiliateProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProfile
     */
    select?: AffiliateProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProfileInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateProfiles to fetch.
     */
    where?: AffiliateProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateProfiles to fetch.
     */
    orderBy?: AffiliateProfileOrderByWithRelationInput | AffiliateProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AffiliateProfiles.
     */
    cursor?: AffiliateProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateProfiles.
     */
    skip?: number
    distinct?: AffiliateProfileScalarFieldEnum | AffiliateProfileScalarFieldEnum[]
  }

  /**
   * AffiliateProfile create
   */
  export type AffiliateProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProfile
     */
    select?: AffiliateProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a AffiliateProfile.
     */
    data: XOR<AffiliateProfileCreateInput, AffiliateProfileUncheckedCreateInput>
  }

  /**
   * AffiliateProfile createMany
   */
  export type AffiliateProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AffiliateProfiles.
     */
    data: AffiliateProfileCreateManyInput | AffiliateProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AffiliateProfile createManyAndReturn
   */
  export type AffiliateProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProfile
     */
    select?: AffiliateProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AffiliateProfiles.
     */
    data: AffiliateProfileCreateManyInput | AffiliateProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AffiliateProfile update
   */
  export type AffiliateProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProfile
     */
    select?: AffiliateProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a AffiliateProfile.
     */
    data: XOR<AffiliateProfileUpdateInput, AffiliateProfileUncheckedUpdateInput>
    /**
     * Choose, which AffiliateProfile to update.
     */
    where: AffiliateProfileWhereUniqueInput
  }

  /**
   * AffiliateProfile updateMany
   */
  export type AffiliateProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AffiliateProfiles.
     */
    data: XOR<AffiliateProfileUpdateManyMutationInput, AffiliateProfileUncheckedUpdateManyInput>
    /**
     * Filter which AffiliateProfiles to update
     */
    where?: AffiliateProfileWhereInput
  }

  /**
   * AffiliateProfile upsert
   */
  export type AffiliateProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProfile
     */
    select?: AffiliateProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the AffiliateProfile to update in case it exists.
     */
    where: AffiliateProfileWhereUniqueInput
    /**
     * In case the AffiliateProfile found by the `where` argument doesn't exist, create a new AffiliateProfile with this data.
     */
    create: XOR<AffiliateProfileCreateInput, AffiliateProfileUncheckedCreateInput>
    /**
     * In case the AffiliateProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AffiliateProfileUpdateInput, AffiliateProfileUncheckedUpdateInput>
  }

  /**
   * AffiliateProfile delete
   */
  export type AffiliateProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProfile
     */
    select?: AffiliateProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProfileInclude<ExtArgs> | null
    /**
     * Filter which AffiliateProfile to delete.
     */
    where: AffiliateProfileWhereUniqueInput
  }

  /**
   * AffiliateProfile deleteMany
   */
  export type AffiliateProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AffiliateProfiles to delete
     */
    where?: AffiliateProfileWhereInput
  }

  /**
   * AffiliateProfile.clicks
   */
  export type AffiliateProfile$clicksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Click
     */
    select?: ClickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClickInclude<ExtArgs> | null
    where?: ClickWhereInput
    orderBy?: ClickOrderByWithRelationInput | ClickOrderByWithRelationInput[]
    cursor?: ClickWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClickScalarFieldEnum | ClickScalarFieldEnum[]
  }

  /**
   * AffiliateProfile.conversions
   */
  export type AffiliateProfile$conversionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversion
     */
    select?: ConversionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversionInclude<ExtArgs> | null
    where?: ConversionWhereInput
    orderBy?: ConversionOrderByWithRelationInput | ConversionOrderByWithRelationInput[]
    cursor?: ConversionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversionScalarFieldEnum | ConversionScalarFieldEnum[]
  }

  /**
   * AffiliateProfile.commissions
   */
  export type AffiliateProfile$commissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commission
     */
    select?: CommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionInclude<ExtArgs> | null
    where?: CommissionWhereInput
    orderBy?: CommissionOrderByWithRelationInput | CommissionOrderByWithRelationInput[]
    cursor?: CommissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommissionScalarFieldEnum | CommissionScalarFieldEnum[]
  }

  /**
   * AffiliateProfile.payouts
   */
  export type AffiliateProfile$payoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutInclude<ExtArgs> | null
    where?: PayoutWhereInput
    orderBy?: PayoutOrderByWithRelationInput | PayoutOrderByWithRelationInput[]
    cursor?: PayoutWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayoutScalarFieldEnum | PayoutScalarFieldEnum[]
  }

  /**
   * AffiliateProfile.links
   */
  export type AffiliateProfile$linksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLink
     */
    select?: AffiliateLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateLinkInclude<ExtArgs> | null
    where?: AffiliateLinkWhereInput
    orderBy?: AffiliateLinkOrderByWithRelationInput | AffiliateLinkOrderByWithRelationInput[]
    cursor?: AffiliateLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AffiliateLinkScalarFieldEnum | AffiliateLinkScalarFieldEnum[]
  }

  /**
   * AffiliateProfile.coupons
   */
  export type AffiliateProfile$couponsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    where?: CouponWhereInput
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    cursor?: CouponWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * AffiliateProfile.applications
   */
  export type AffiliateProfile$applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferApplication
     */
    select?: OfferApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferApplicationInclude<ExtArgs> | null
    where?: OfferApplicationWhereInput
    orderBy?: OfferApplicationOrderByWithRelationInput | OfferApplicationOrderByWithRelationInput[]
    cursor?: OfferApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferApplicationScalarFieldEnum | OfferApplicationScalarFieldEnum[]
  }

  /**
   * AffiliateProfile without action
   */
  export type AffiliateProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProfile
     */
    select?: AffiliateProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProfileInclude<ExtArgs> | null
  }


  /**
   * Model AdminProfile
   */

  export type AggregateAdminProfile = {
    _count: AdminProfileCountAggregateOutputType | null
    _min: AdminProfileMinAggregateOutputType | null
    _max: AdminProfileMaxAggregateOutputType | null
  }

  export type AdminProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    department: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    department: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminProfileCountAggregateOutputType = {
    id: number
    userId: number
    permissions: number
    department: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminProfileMinAggregateInputType = {
    id?: true
    userId?: true
    department?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    department?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminProfileCountAggregateInputType = {
    id?: true
    userId?: true
    permissions?: true
    department?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminProfile to aggregate.
     */
    where?: AdminProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminProfiles to fetch.
     */
    orderBy?: AdminProfileOrderByWithRelationInput | AdminProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminProfiles
    **/
    _count?: true | AdminProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminProfileMaxAggregateInputType
  }

  export type GetAdminProfileAggregateType<T extends AdminProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminProfile[P]>
      : GetScalarType<T[P], AggregateAdminProfile[P]>
  }




  export type AdminProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminProfileWhereInput
    orderBy?: AdminProfileOrderByWithAggregationInput | AdminProfileOrderByWithAggregationInput[]
    by: AdminProfileScalarFieldEnum[] | AdminProfileScalarFieldEnum
    having?: AdminProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminProfileCountAggregateInputType | true
    _min?: AdminProfileMinAggregateInputType
    _max?: AdminProfileMaxAggregateInputType
  }

  export type AdminProfileGroupByOutputType = {
    id: string
    userId: string
    permissions: string[]
    department: string | null
    createdAt: Date
    updatedAt: Date
    _count: AdminProfileCountAggregateOutputType | null
    _min: AdminProfileMinAggregateOutputType | null
    _max: AdminProfileMaxAggregateOutputType | null
  }

  type GetAdminProfileGroupByPayload<T extends AdminProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminProfileGroupByOutputType[P]>
            : GetScalarType<T[P], AdminProfileGroupByOutputType[P]>
        }
      >
    >


  export type AdminProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    permissions?: boolean
    department?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminProfile"]>

  export type AdminProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    permissions?: boolean
    department?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminProfile"]>

  export type AdminProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    permissions?: boolean
    department?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AdminProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      permissions: string[]
      department: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["adminProfile"]>
    composites: {}
  }

  type AdminProfileGetPayload<S extends boolean | null | undefined | AdminProfileDefaultArgs> = $Result.GetResult<Prisma.$AdminProfilePayload, S>

  type AdminProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminProfileCountAggregateInputType | true
    }

  export interface AdminProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminProfile'], meta: { name: 'AdminProfile' } }
    /**
     * Find zero or one AdminProfile that matches the filter.
     * @param {AdminProfileFindUniqueArgs} args - Arguments to find a AdminProfile
     * @example
     * // Get one AdminProfile
     * const adminProfile = await prisma.adminProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminProfileFindUniqueArgs>(args: SelectSubset<T, AdminProfileFindUniqueArgs<ExtArgs>>): Prisma__AdminProfileClient<$Result.GetResult<Prisma.$AdminProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdminProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminProfileFindUniqueOrThrowArgs} args - Arguments to find a AdminProfile
     * @example
     * // Get one AdminProfile
     * const adminProfile = await prisma.adminProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminProfileClient<$Result.GetResult<Prisma.$AdminProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdminProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminProfileFindFirstArgs} args - Arguments to find a AdminProfile
     * @example
     * // Get one AdminProfile
     * const adminProfile = await prisma.adminProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminProfileFindFirstArgs>(args?: SelectSubset<T, AdminProfileFindFirstArgs<ExtArgs>>): Prisma__AdminProfileClient<$Result.GetResult<Prisma.$AdminProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdminProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminProfileFindFirstOrThrowArgs} args - Arguments to find a AdminProfile
     * @example
     * // Get one AdminProfile
     * const adminProfile = await prisma.adminProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminProfileClient<$Result.GetResult<Prisma.$AdminProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdminProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminProfiles
     * const adminProfiles = await prisma.adminProfile.findMany()
     * 
     * // Get first 10 AdminProfiles
     * const adminProfiles = await prisma.adminProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminProfileWithIdOnly = await prisma.adminProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminProfileFindManyArgs>(args?: SelectSubset<T, AdminProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdminProfile.
     * @param {AdminProfileCreateArgs} args - Arguments to create a AdminProfile.
     * @example
     * // Create one AdminProfile
     * const AdminProfile = await prisma.adminProfile.create({
     *   data: {
     *     // ... data to create a AdminProfile
     *   }
     * })
     * 
     */
    create<T extends AdminProfileCreateArgs>(args: SelectSubset<T, AdminProfileCreateArgs<ExtArgs>>): Prisma__AdminProfileClient<$Result.GetResult<Prisma.$AdminProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdminProfiles.
     * @param {AdminProfileCreateManyArgs} args - Arguments to create many AdminProfiles.
     * @example
     * // Create many AdminProfiles
     * const adminProfile = await prisma.adminProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminProfileCreateManyArgs>(args?: SelectSubset<T, AdminProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminProfiles and returns the data saved in the database.
     * @param {AdminProfileCreateManyAndReturnArgs} args - Arguments to create many AdminProfiles.
     * @example
     * // Create many AdminProfiles
     * const adminProfile = await prisma.adminProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminProfiles and only return the `id`
     * const adminProfileWithIdOnly = await prisma.adminProfile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AdminProfile.
     * @param {AdminProfileDeleteArgs} args - Arguments to delete one AdminProfile.
     * @example
     * // Delete one AdminProfile
     * const AdminProfile = await prisma.adminProfile.delete({
     *   where: {
     *     // ... filter to delete one AdminProfile
     *   }
     * })
     * 
     */
    delete<T extends AdminProfileDeleteArgs>(args: SelectSubset<T, AdminProfileDeleteArgs<ExtArgs>>): Prisma__AdminProfileClient<$Result.GetResult<Prisma.$AdminProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdminProfile.
     * @param {AdminProfileUpdateArgs} args - Arguments to update one AdminProfile.
     * @example
     * // Update one AdminProfile
     * const adminProfile = await prisma.adminProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminProfileUpdateArgs>(args: SelectSubset<T, AdminProfileUpdateArgs<ExtArgs>>): Prisma__AdminProfileClient<$Result.GetResult<Prisma.$AdminProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdminProfiles.
     * @param {AdminProfileDeleteManyArgs} args - Arguments to filter AdminProfiles to delete.
     * @example
     * // Delete a few AdminProfiles
     * const { count } = await prisma.adminProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminProfileDeleteManyArgs>(args?: SelectSubset<T, AdminProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminProfiles
     * const adminProfile = await prisma.adminProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminProfileUpdateManyArgs>(args: SelectSubset<T, AdminProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminProfile.
     * @param {AdminProfileUpsertArgs} args - Arguments to update or create a AdminProfile.
     * @example
     * // Update or create a AdminProfile
     * const adminProfile = await prisma.adminProfile.upsert({
     *   create: {
     *     // ... data to create a AdminProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminProfile we want to update
     *   }
     * })
     */
    upsert<T extends AdminProfileUpsertArgs>(args: SelectSubset<T, AdminProfileUpsertArgs<ExtArgs>>): Prisma__AdminProfileClient<$Result.GetResult<Prisma.$AdminProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdminProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminProfileCountArgs} args - Arguments to filter AdminProfiles to count.
     * @example
     * // Count the number of AdminProfiles
     * const count = await prisma.adminProfile.count({
     *   where: {
     *     // ... the filter for the AdminProfiles we want to count
     *   }
     * })
    **/
    count<T extends AdminProfileCountArgs>(
      args?: Subset<T, AdminProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminProfileAggregateArgs>(args: Subset<T, AdminProfileAggregateArgs>): Prisma.PrismaPromise<GetAdminProfileAggregateType<T>>

    /**
     * Group by AdminProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminProfileGroupByArgs['orderBy'] }
        : { orderBy?: AdminProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminProfile model
   */
  readonly fields: AdminProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminProfile model
   */ 
  interface AdminProfileFieldRefs {
    readonly id: FieldRef<"AdminProfile", 'String'>
    readonly userId: FieldRef<"AdminProfile", 'String'>
    readonly permissions: FieldRef<"AdminProfile", 'String[]'>
    readonly department: FieldRef<"AdminProfile", 'String'>
    readonly createdAt: FieldRef<"AdminProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"AdminProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminProfile findUnique
   */
  export type AdminProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminProfile
     */
    select?: AdminProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminProfileInclude<ExtArgs> | null
    /**
     * Filter, which AdminProfile to fetch.
     */
    where: AdminProfileWhereUniqueInput
  }

  /**
   * AdminProfile findUniqueOrThrow
   */
  export type AdminProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminProfile
     */
    select?: AdminProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminProfileInclude<ExtArgs> | null
    /**
     * Filter, which AdminProfile to fetch.
     */
    where: AdminProfileWhereUniqueInput
  }

  /**
   * AdminProfile findFirst
   */
  export type AdminProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminProfile
     */
    select?: AdminProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminProfileInclude<ExtArgs> | null
    /**
     * Filter, which AdminProfile to fetch.
     */
    where?: AdminProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminProfiles to fetch.
     */
    orderBy?: AdminProfileOrderByWithRelationInput | AdminProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminProfiles.
     */
    cursor?: AdminProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminProfiles.
     */
    distinct?: AdminProfileScalarFieldEnum | AdminProfileScalarFieldEnum[]
  }

  /**
   * AdminProfile findFirstOrThrow
   */
  export type AdminProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminProfile
     */
    select?: AdminProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminProfileInclude<ExtArgs> | null
    /**
     * Filter, which AdminProfile to fetch.
     */
    where?: AdminProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminProfiles to fetch.
     */
    orderBy?: AdminProfileOrderByWithRelationInput | AdminProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminProfiles.
     */
    cursor?: AdminProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminProfiles.
     */
    distinct?: AdminProfileScalarFieldEnum | AdminProfileScalarFieldEnum[]
  }

  /**
   * AdminProfile findMany
   */
  export type AdminProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminProfile
     */
    select?: AdminProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminProfileInclude<ExtArgs> | null
    /**
     * Filter, which AdminProfiles to fetch.
     */
    where?: AdminProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminProfiles to fetch.
     */
    orderBy?: AdminProfileOrderByWithRelationInput | AdminProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminProfiles.
     */
    cursor?: AdminProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminProfiles.
     */
    skip?: number
    distinct?: AdminProfileScalarFieldEnum | AdminProfileScalarFieldEnum[]
  }

  /**
   * AdminProfile create
   */
  export type AdminProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminProfile
     */
    select?: AdminProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminProfile.
     */
    data: XOR<AdminProfileCreateInput, AdminProfileUncheckedCreateInput>
  }

  /**
   * AdminProfile createMany
   */
  export type AdminProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminProfiles.
     */
    data: AdminProfileCreateManyInput | AdminProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminProfile createManyAndReturn
   */
  export type AdminProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminProfile
     */
    select?: AdminProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AdminProfiles.
     */
    data: AdminProfileCreateManyInput | AdminProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminProfile update
   */
  export type AdminProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminProfile
     */
    select?: AdminProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminProfile.
     */
    data: XOR<AdminProfileUpdateInput, AdminProfileUncheckedUpdateInput>
    /**
     * Choose, which AdminProfile to update.
     */
    where: AdminProfileWhereUniqueInput
  }

  /**
   * AdminProfile updateMany
   */
  export type AdminProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminProfiles.
     */
    data: XOR<AdminProfileUpdateManyMutationInput, AdminProfileUncheckedUpdateManyInput>
    /**
     * Filter which AdminProfiles to update
     */
    where?: AdminProfileWhereInput
  }

  /**
   * AdminProfile upsert
   */
  export type AdminProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminProfile
     */
    select?: AdminProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminProfile to update in case it exists.
     */
    where: AdminProfileWhereUniqueInput
    /**
     * In case the AdminProfile found by the `where` argument doesn't exist, create a new AdminProfile with this data.
     */
    create: XOR<AdminProfileCreateInput, AdminProfileUncheckedCreateInput>
    /**
     * In case the AdminProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminProfileUpdateInput, AdminProfileUncheckedUpdateInput>
  }

  /**
   * AdminProfile delete
   */
  export type AdminProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminProfile
     */
    select?: AdminProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminProfileInclude<ExtArgs> | null
    /**
     * Filter which AdminProfile to delete.
     */
    where: AdminProfileWhereUniqueInput
  }

  /**
   * AdminProfile deleteMany
   */
  export type AdminProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminProfiles to delete
     */
    where?: AdminProfileWhereInput
  }

  /**
   * AdminProfile without action
   */
  export type AdminProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminProfile
     */
    select?: AdminProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminProfileInclude<ExtArgs> | null
  }


  /**
   * Model Offer
   */

  export type AggregateOffer = {
    _count: OfferCountAggregateOutputType | null
    _avg: OfferAvgAggregateOutputType | null
    _sum: OfferSumAggregateOutputType | null
    _min: OfferMinAggregateOutputType | null
    _max: OfferMaxAggregateOutputType | null
  }

  export type OfferAvgAggregateOutputType = {
    commissionRate: number | null
    totalClicks: number | null
    totalConversions: number | null
    totalRevenue: number | null
    totalCommissions: number | null
  }

  export type OfferSumAggregateOutputType = {
    commissionRate: number | null
    totalClicks: number | null
    totalConversions: number | null
    totalRevenue: number | null
    totalCommissions: number | null
  }

  export type OfferMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: string | null
    commissionRate: number | null
    status: $Enums.OfferStatus | null
    startDate: Date | null
    endDate: Date | null
    terms: string | null
    requirements: string | null
    totalClicks: number | null
    totalConversions: number | null
    totalRevenue: number | null
    totalCommissions: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OfferMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: string | null
    commissionRate: number | null
    status: $Enums.OfferStatus | null
    startDate: Date | null
    endDate: Date | null
    terms: string | null
    requirements: string | null
    totalClicks: number | null
    totalConversions: number | null
    totalRevenue: number | null
    totalCommissions: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OfferCountAggregateOutputType = {
    id: number
    name: number
    description: number
    category: number
    commissionRate: number
    status: number
    startDate: number
    endDate: number
    terms: number
    requirements: number
    totalClicks: number
    totalConversions: number
    totalRevenue: number
    totalCommissions: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OfferAvgAggregateInputType = {
    commissionRate?: true
    totalClicks?: true
    totalConversions?: true
    totalRevenue?: true
    totalCommissions?: true
  }

  export type OfferSumAggregateInputType = {
    commissionRate?: true
    totalClicks?: true
    totalConversions?: true
    totalRevenue?: true
    totalCommissions?: true
  }

  export type OfferMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    commissionRate?: true
    status?: true
    startDate?: true
    endDate?: true
    terms?: true
    requirements?: true
    totalClicks?: true
    totalConversions?: true
    totalRevenue?: true
    totalCommissions?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OfferMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    commissionRate?: true
    status?: true
    startDate?: true
    endDate?: true
    terms?: true
    requirements?: true
    totalClicks?: true
    totalConversions?: true
    totalRevenue?: true
    totalCommissions?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OfferCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    commissionRate?: true
    status?: true
    startDate?: true
    endDate?: true
    terms?: true
    requirements?: true
    totalClicks?: true
    totalConversions?: true
    totalRevenue?: true
    totalCommissions?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OfferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Offer to aggregate.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Offers
    **/
    _count?: true | OfferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OfferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OfferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OfferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OfferMaxAggregateInputType
  }

  export type GetOfferAggregateType<T extends OfferAggregateArgs> = {
        [P in keyof T & keyof AggregateOffer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOffer[P]>
      : GetScalarType<T[P], AggregateOffer[P]>
  }




  export type OfferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferWhereInput
    orderBy?: OfferOrderByWithAggregationInput | OfferOrderByWithAggregationInput[]
    by: OfferScalarFieldEnum[] | OfferScalarFieldEnum
    having?: OfferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OfferCountAggregateInputType | true
    _avg?: OfferAvgAggregateInputType
    _sum?: OfferSumAggregateInputType
    _min?: OfferMinAggregateInputType
    _max?: OfferMaxAggregateInputType
  }

  export type OfferGroupByOutputType = {
    id: string
    name: string
    description: string
    category: string
    commissionRate: number
    status: $Enums.OfferStatus
    startDate: Date
    endDate: Date | null
    terms: string | null
    requirements: string | null
    totalClicks: number
    totalConversions: number
    totalRevenue: number
    totalCommissions: number
    createdAt: Date
    updatedAt: Date
    _count: OfferCountAggregateOutputType | null
    _avg: OfferAvgAggregateOutputType | null
    _sum: OfferSumAggregateOutputType | null
    _min: OfferMinAggregateOutputType | null
    _max: OfferMaxAggregateOutputType | null
  }

  type GetOfferGroupByPayload<T extends OfferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OfferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OfferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OfferGroupByOutputType[P]>
            : GetScalarType<T[P], OfferGroupByOutputType[P]>
        }
      >
    >


  export type OfferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    commissionRate?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    terms?: boolean
    requirements?: boolean
    totalClicks?: boolean
    totalConversions?: boolean
    totalRevenue?: boolean
    totalCommissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    applications?: boolean | Offer$applicationsArgs<ExtArgs>
    conversions?: boolean | Offer$conversionsArgs<ExtArgs>
    links?: boolean | Offer$linksArgs<ExtArgs>
    creatives?: boolean | Offer$creativesArgs<ExtArgs>
    _count?: boolean | OfferCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offer"]>

  export type OfferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    commissionRate?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    terms?: boolean
    requirements?: boolean
    totalClicks?: boolean
    totalConversions?: boolean
    totalRevenue?: boolean
    totalCommissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["offer"]>

  export type OfferSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    commissionRate?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    terms?: boolean
    requirements?: boolean
    totalClicks?: boolean
    totalConversions?: boolean
    totalRevenue?: boolean
    totalCommissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OfferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applications?: boolean | Offer$applicationsArgs<ExtArgs>
    conversions?: boolean | Offer$conversionsArgs<ExtArgs>
    links?: boolean | Offer$linksArgs<ExtArgs>
    creatives?: boolean | Offer$creativesArgs<ExtArgs>
    _count?: boolean | OfferCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OfferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OfferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Offer"
    objects: {
      applications: Prisma.$OfferApplicationPayload<ExtArgs>[]
      conversions: Prisma.$ConversionPayload<ExtArgs>[]
      links: Prisma.$AffiliateLinkPayload<ExtArgs>[]
      creatives: Prisma.$CreativePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      category: string
      commissionRate: number
      status: $Enums.OfferStatus
      startDate: Date
      endDate: Date | null
      terms: string | null
      requirements: string | null
      totalClicks: number
      totalConversions: number
      totalRevenue: number
      totalCommissions: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["offer"]>
    composites: {}
  }

  type OfferGetPayload<S extends boolean | null | undefined | OfferDefaultArgs> = $Result.GetResult<Prisma.$OfferPayload, S>

  type OfferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OfferFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OfferCountAggregateInputType | true
    }

  export interface OfferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Offer'], meta: { name: 'Offer' } }
    /**
     * Find zero or one Offer that matches the filter.
     * @param {OfferFindUniqueArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OfferFindUniqueArgs>(args: SelectSubset<T, OfferFindUniqueArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Offer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OfferFindUniqueOrThrowArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OfferFindUniqueOrThrowArgs>(args: SelectSubset<T, OfferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Offer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferFindFirstArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OfferFindFirstArgs>(args?: SelectSubset<T, OfferFindFirstArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Offer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferFindFirstOrThrowArgs} args - Arguments to find a Offer
     * @example
     * // Get one Offer
     * const offer = await prisma.offer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OfferFindFirstOrThrowArgs>(args?: SelectSubset<T, OfferFindFirstOrThrowArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Offers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Offers
     * const offers = await prisma.offer.findMany()
     * 
     * // Get first 10 Offers
     * const offers = await prisma.offer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offerWithIdOnly = await prisma.offer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OfferFindManyArgs>(args?: SelectSubset<T, OfferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Offer.
     * @param {OfferCreateArgs} args - Arguments to create a Offer.
     * @example
     * // Create one Offer
     * const Offer = await prisma.offer.create({
     *   data: {
     *     // ... data to create a Offer
     *   }
     * })
     * 
     */
    create<T extends OfferCreateArgs>(args: SelectSubset<T, OfferCreateArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Offers.
     * @param {OfferCreateManyArgs} args - Arguments to create many Offers.
     * @example
     * // Create many Offers
     * const offer = await prisma.offer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OfferCreateManyArgs>(args?: SelectSubset<T, OfferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Offers and returns the data saved in the database.
     * @param {OfferCreateManyAndReturnArgs} args - Arguments to create many Offers.
     * @example
     * // Create many Offers
     * const offer = await prisma.offer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Offers and only return the `id`
     * const offerWithIdOnly = await prisma.offer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OfferCreateManyAndReturnArgs>(args?: SelectSubset<T, OfferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Offer.
     * @param {OfferDeleteArgs} args - Arguments to delete one Offer.
     * @example
     * // Delete one Offer
     * const Offer = await prisma.offer.delete({
     *   where: {
     *     // ... filter to delete one Offer
     *   }
     * })
     * 
     */
    delete<T extends OfferDeleteArgs>(args: SelectSubset<T, OfferDeleteArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Offer.
     * @param {OfferUpdateArgs} args - Arguments to update one Offer.
     * @example
     * // Update one Offer
     * const offer = await prisma.offer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OfferUpdateArgs>(args: SelectSubset<T, OfferUpdateArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Offers.
     * @param {OfferDeleteManyArgs} args - Arguments to filter Offers to delete.
     * @example
     * // Delete a few Offers
     * const { count } = await prisma.offer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OfferDeleteManyArgs>(args?: SelectSubset<T, OfferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Offers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Offers
     * const offer = await prisma.offer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OfferUpdateManyArgs>(args: SelectSubset<T, OfferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Offer.
     * @param {OfferUpsertArgs} args - Arguments to update or create a Offer.
     * @example
     * // Update or create a Offer
     * const offer = await prisma.offer.upsert({
     *   create: {
     *     // ... data to create a Offer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Offer we want to update
     *   }
     * })
     */
    upsert<T extends OfferUpsertArgs>(args: SelectSubset<T, OfferUpsertArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Offers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferCountArgs} args - Arguments to filter Offers to count.
     * @example
     * // Count the number of Offers
     * const count = await prisma.offer.count({
     *   where: {
     *     // ... the filter for the Offers we want to count
     *   }
     * })
    **/
    count<T extends OfferCountArgs>(
      args?: Subset<T, OfferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OfferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Offer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OfferAggregateArgs>(args: Subset<T, OfferAggregateArgs>): Prisma.PrismaPromise<GetOfferAggregateType<T>>

    /**
     * Group by Offer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OfferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OfferGroupByArgs['orderBy'] }
        : { orderBy?: OfferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OfferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOfferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Offer model
   */
  readonly fields: OfferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Offer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OfferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    applications<T extends Offer$applicationsArgs<ExtArgs> = {}>(args?: Subset<T, Offer$applicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferApplicationPayload<ExtArgs>, T, "findMany"> | Null>
    conversions<T extends Offer$conversionsArgs<ExtArgs> = {}>(args?: Subset<T, Offer$conversionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversionPayload<ExtArgs>, T, "findMany"> | Null>
    links<T extends Offer$linksArgs<ExtArgs> = {}>(args?: Subset<T, Offer$linksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateLinkPayload<ExtArgs>, T, "findMany"> | Null>
    creatives<T extends Offer$creativesArgs<ExtArgs> = {}>(args?: Subset<T, Offer$creativesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreativePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Offer model
   */ 
  interface OfferFieldRefs {
    readonly id: FieldRef<"Offer", 'String'>
    readonly name: FieldRef<"Offer", 'String'>
    readonly description: FieldRef<"Offer", 'String'>
    readonly category: FieldRef<"Offer", 'String'>
    readonly commissionRate: FieldRef<"Offer", 'Float'>
    readonly status: FieldRef<"Offer", 'OfferStatus'>
    readonly startDate: FieldRef<"Offer", 'DateTime'>
    readonly endDate: FieldRef<"Offer", 'DateTime'>
    readonly terms: FieldRef<"Offer", 'String'>
    readonly requirements: FieldRef<"Offer", 'String'>
    readonly totalClicks: FieldRef<"Offer", 'Int'>
    readonly totalConversions: FieldRef<"Offer", 'Int'>
    readonly totalRevenue: FieldRef<"Offer", 'Float'>
    readonly totalCommissions: FieldRef<"Offer", 'Float'>
    readonly createdAt: FieldRef<"Offer", 'DateTime'>
    readonly updatedAt: FieldRef<"Offer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Offer findUnique
   */
  export type OfferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offer to fetch.
     */
    where: OfferWhereUniqueInput
  }

  /**
   * Offer findUniqueOrThrow
   */
  export type OfferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offer to fetch.
     */
    where: OfferWhereUniqueInput
  }

  /**
   * Offer findFirst
   */
  export type OfferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offer to fetch.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Offers.
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Offers.
     */
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[]
  }

  /**
   * Offer findFirstOrThrow
   */
  export type OfferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offer to fetch.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Offers.
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Offers.
     */
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[]
  }

  /**
   * Offer findMany
   */
  export type OfferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter, which Offers to fetch.
     */
    where?: OfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Offers to fetch.
     */
    orderBy?: OfferOrderByWithRelationInput | OfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Offers.
     */
    cursor?: OfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Offers.
     */
    skip?: number
    distinct?: OfferScalarFieldEnum | OfferScalarFieldEnum[]
  }

  /**
   * Offer create
   */
  export type OfferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * The data needed to create a Offer.
     */
    data: XOR<OfferCreateInput, OfferUncheckedCreateInput>
  }

  /**
   * Offer createMany
   */
  export type OfferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Offers.
     */
    data: OfferCreateManyInput | OfferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Offer createManyAndReturn
   */
  export type OfferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Offers.
     */
    data: OfferCreateManyInput | OfferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Offer update
   */
  export type OfferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * The data needed to update a Offer.
     */
    data: XOR<OfferUpdateInput, OfferUncheckedUpdateInput>
    /**
     * Choose, which Offer to update.
     */
    where: OfferWhereUniqueInput
  }

  /**
   * Offer updateMany
   */
  export type OfferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Offers.
     */
    data: XOR<OfferUpdateManyMutationInput, OfferUncheckedUpdateManyInput>
    /**
     * Filter which Offers to update
     */
    where?: OfferWhereInput
  }

  /**
   * Offer upsert
   */
  export type OfferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * The filter to search for the Offer to update in case it exists.
     */
    where: OfferWhereUniqueInput
    /**
     * In case the Offer found by the `where` argument doesn't exist, create a new Offer with this data.
     */
    create: XOR<OfferCreateInput, OfferUncheckedCreateInput>
    /**
     * In case the Offer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OfferUpdateInput, OfferUncheckedUpdateInput>
  }

  /**
   * Offer delete
   */
  export type OfferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    /**
     * Filter which Offer to delete.
     */
    where: OfferWhereUniqueInput
  }

  /**
   * Offer deleteMany
   */
  export type OfferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Offers to delete
     */
    where?: OfferWhereInput
  }

  /**
   * Offer.applications
   */
  export type Offer$applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferApplication
     */
    select?: OfferApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferApplicationInclude<ExtArgs> | null
    where?: OfferApplicationWhereInput
    orderBy?: OfferApplicationOrderByWithRelationInput | OfferApplicationOrderByWithRelationInput[]
    cursor?: OfferApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OfferApplicationScalarFieldEnum | OfferApplicationScalarFieldEnum[]
  }

  /**
   * Offer.conversions
   */
  export type Offer$conversionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversion
     */
    select?: ConversionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversionInclude<ExtArgs> | null
    where?: ConversionWhereInput
    orderBy?: ConversionOrderByWithRelationInput | ConversionOrderByWithRelationInput[]
    cursor?: ConversionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversionScalarFieldEnum | ConversionScalarFieldEnum[]
  }

  /**
   * Offer.links
   */
  export type Offer$linksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLink
     */
    select?: AffiliateLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateLinkInclude<ExtArgs> | null
    where?: AffiliateLinkWhereInput
    orderBy?: AffiliateLinkOrderByWithRelationInput | AffiliateLinkOrderByWithRelationInput[]
    cursor?: AffiliateLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AffiliateLinkScalarFieldEnum | AffiliateLinkScalarFieldEnum[]
  }

  /**
   * Offer.creatives
   */
  export type Offer$creativesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creative
     */
    select?: CreativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeInclude<ExtArgs> | null
    where?: CreativeWhereInput
    orderBy?: CreativeOrderByWithRelationInput | CreativeOrderByWithRelationInput[]
    cursor?: CreativeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreativeScalarFieldEnum | CreativeScalarFieldEnum[]
  }

  /**
   * Offer without action
   */
  export type OfferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
  }


  /**
   * Model OfferApplication
   */

  export type AggregateOfferApplication = {
    _count: OfferApplicationCountAggregateOutputType | null
    _min: OfferApplicationMinAggregateOutputType | null
    _max: OfferApplicationMaxAggregateOutputType | null
  }

  export type OfferApplicationMinAggregateOutputType = {
    id: string | null
    affiliateId: string | null
    offerId: string | null
    status: $Enums.ApplicationStatus | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OfferApplicationMaxAggregateOutputType = {
    id: string | null
    affiliateId: string | null
    offerId: string | null
    status: $Enums.ApplicationStatus | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OfferApplicationCountAggregateOutputType = {
    id: number
    affiliateId: number
    offerId: number
    status: number
    message: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OfferApplicationMinAggregateInputType = {
    id?: true
    affiliateId?: true
    offerId?: true
    status?: true
    message?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OfferApplicationMaxAggregateInputType = {
    id?: true
    affiliateId?: true
    offerId?: true
    status?: true
    message?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OfferApplicationCountAggregateInputType = {
    id?: true
    affiliateId?: true
    offerId?: true
    status?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OfferApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OfferApplication to aggregate.
     */
    where?: OfferApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferApplications to fetch.
     */
    orderBy?: OfferApplicationOrderByWithRelationInput | OfferApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OfferApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OfferApplications
    **/
    _count?: true | OfferApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OfferApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OfferApplicationMaxAggregateInputType
  }

  export type GetOfferApplicationAggregateType<T extends OfferApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateOfferApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOfferApplication[P]>
      : GetScalarType<T[P], AggregateOfferApplication[P]>
  }




  export type OfferApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OfferApplicationWhereInput
    orderBy?: OfferApplicationOrderByWithAggregationInput | OfferApplicationOrderByWithAggregationInput[]
    by: OfferApplicationScalarFieldEnum[] | OfferApplicationScalarFieldEnum
    having?: OfferApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OfferApplicationCountAggregateInputType | true
    _min?: OfferApplicationMinAggregateInputType
    _max?: OfferApplicationMaxAggregateInputType
  }

  export type OfferApplicationGroupByOutputType = {
    id: string
    affiliateId: string
    offerId: string
    status: $Enums.ApplicationStatus
    message: string | null
    createdAt: Date
    updatedAt: Date
    _count: OfferApplicationCountAggregateOutputType | null
    _min: OfferApplicationMinAggregateOutputType | null
    _max: OfferApplicationMaxAggregateOutputType | null
  }

  type GetOfferApplicationGroupByPayload<T extends OfferApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OfferApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OfferApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OfferApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], OfferApplicationGroupByOutputType[P]>
        }
      >
    >


  export type OfferApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    affiliateId?: boolean
    offerId?: boolean
    status?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    affiliate?: boolean | AffiliateProfileDefaultArgs<ExtArgs>
    offer?: boolean | OfferDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offerApplication"]>

  export type OfferApplicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    affiliateId?: boolean
    offerId?: boolean
    status?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    affiliate?: boolean | AffiliateProfileDefaultArgs<ExtArgs>
    offer?: boolean | OfferDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offerApplication"]>

  export type OfferApplicationSelectScalar = {
    id?: boolean
    affiliateId?: boolean
    offerId?: boolean
    status?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OfferApplicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliate?: boolean | AffiliateProfileDefaultArgs<ExtArgs>
    offer?: boolean | OfferDefaultArgs<ExtArgs>
  }
  export type OfferApplicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliate?: boolean | AffiliateProfileDefaultArgs<ExtArgs>
    offer?: boolean | OfferDefaultArgs<ExtArgs>
  }

  export type $OfferApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OfferApplication"
    objects: {
      affiliate: Prisma.$AffiliateProfilePayload<ExtArgs>
      offer: Prisma.$OfferPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      affiliateId: string
      offerId: string
      status: $Enums.ApplicationStatus
      message: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["offerApplication"]>
    composites: {}
  }

  type OfferApplicationGetPayload<S extends boolean | null | undefined | OfferApplicationDefaultArgs> = $Result.GetResult<Prisma.$OfferApplicationPayload, S>

  type OfferApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OfferApplicationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OfferApplicationCountAggregateInputType | true
    }

  export interface OfferApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OfferApplication'], meta: { name: 'OfferApplication' } }
    /**
     * Find zero or one OfferApplication that matches the filter.
     * @param {OfferApplicationFindUniqueArgs} args - Arguments to find a OfferApplication
     * @example
     * // Get one OfferApplication
     * const offerApplication = await prisma.offerApplication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OfferApplicationFindUniqueArgs>(args: SelectSubset<T, OfferApplicationFindUniqueArgs<ExtArgs>>): Prisma__OfferApplicationClient<$Result.GetResult<Prisma.$OfferApplicationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OfferApplication that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OfferApplicationFindUniqueOrThrowArgs} args - Arguments to find a OfferApplication
     * @example
     * // Get one OfferApplication
     * const offerApplication = await prisma.offerApplication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OfferApplicationFindUniqueOrThrowArgs>(args: SelectSubset<T, OfferApplicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OfferApplicationClient<$Result.GetResult<Prisma.$OfferApplicationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OfferApplication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferApplicationFindFirstArgs} args - Arguments to find a OfferApplication
     * @example
     * // Get one OfferApplication
     * const offerApplication = await prisma.offerApplication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OfferApplicationFindFirstArgs>(args?: SelectSubset<T, OfferApplicationFindFirstArgs<ExtArgs>>): Prisma__OfferApplicationClient<$Result.GetResult<Prisma.$OfferApplicationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OfferApplication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferApplicationFindFirstOrThrowArgs} args - Arguments to find a OfferApplication
     * @example
     * // Get one OfferApplication
     * const offerApplication = await prisma.offerApplication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OfferApplicationFindFirstOrThrowArgs>(args?: SelectSubset<T, OfferApplicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OfferApplicationClient<$Result.GetResult<Prisma.$OfferApplicationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OfferApplications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OfferApplications
     * const offerApplications = await prisma.offerApplication.findMany()
     * 
     * // Get first 10 OfferApplications
     * const offerApplications = await prisma.offerApplication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offerApplicationWithIdOnly = await prisma.offerApplication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OfferApplicationFindManyArgs>(args?: SelectSubset<T, OfferApplicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferApplicationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OfferApplication.
     * @param {OfferApplicationCreateArgs} args - Arguments to create a OfferApplication.
     * @example
     * // Create one OfferApplication
     * const OfferApplication = await prisma.offerApplication.create({
     *   data: {
     *     // ... data to create a OfferApplication
     *   }
     * })
     * 
     */
    create<T extends OfferApplicationCreateArgs>(args: SelectSubset<T, OfferApplicationCreateArgs<ExtArgs>>): Prisma__OfferApplicationClient<$Result.GetResult<Prisma.$OfferApplicationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OfferApplications.
     * @param {OfferApplicationCreateManyArgs} args - Arguments to create many OfferApplications.
     * @example
     * // Create many OfferApplications
     * const offerApplication = await prisma.offerApplication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OfferApplicationCreateManyArgs>(args?: SelectSubset<T, OfferApplicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OfferApplications and returns the data saved in the database.
     * @param {OfferApplicationCreateManyAndReturnArgs} args - Arguments to create many OfferApplications.
     * @example
     * // Create many OfferApplications
     * const offerApplication = await prisma.offerApplication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OfferApplications and only return the `id`
     * const offerApplicationWithIdOnly = await prisma.offerApplication.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OfferApplicationCreateManyAndReturnArgs>(args?: SelectSubset<T, OfferApplicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OfferApplicationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OfferApplication.
     * @param {OfferApplicationDeleteArgs} args - Arguments to delete one OfferApplication.
     * @example
     * // Delete one OfferApplication
     * const OfferApplication = await prisma.offerApplication.delete({
     *   where: {
     *     // ... filter to delete one OfferApplication
     *   }
     * })
     * 
     */
    delete<T extends OfferApplicationDeleteArgs>(args: SelectSubset<T, OfferApplicationDeleteArgs<ExtArgs>>): Prisma__OfferApplicationClient<$Result.GetResult<Prisma.$OfferApplicationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OfferApplication.
     * @param {OfferApplicationUpdateArgs} args - Arguments to update one OfferApplication.
     * @example
     * // Update one OfferApplication
     * const offerApplication = await prisma.offerApplication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OfferApplicationUpdateArgs>(args: SelectSubset<T, OfferApplicationUpdateArgs<ExtArgs>>): Prisma__OfferApplicationClient<$Result.GetResult<Prisma.$OfferApplicationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OfferApplications.
     * @param {OfferApplicationDeleteManyArgs} args - Arguments to filter OfferApplications to delete.
     * @example
     * // Delete a few OfferApplications
     * const { count } = await prisma.offerApplication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OfferApplicationDeleteManyArgs>(args?: SelectSubset<T, OfferApplicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OfferApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OfferApplications
     * const offerApplication = await prisma.offerApplication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OfferApplicationUpdateManyArgs>(args: SelectSubset<T, OfferApplicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OfferApplication.
     * @param {OfferApplicationUpsertArgs} args - Arguments to update or create a OfferApplication.
     * @example
     * // Update or create a OfferApplication
     * const offerApplication = await prisma.offerApplication.upsert({
     *   create: {
     *     // ... data to create a OfferApplication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OfferApplication we want to update
     *   }
     * })
     */
    upsert<T extends OfferApplicationUpsertArgs>(args: SelectSubset<T, OfferApplicationUpsertArgs<ExtArgs>>): Prisma__OfferApplicationClient<$Result.GetResult<Prisma.$OfferApplicationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OfferApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferApplicationCountArgs} args - Arguments to filter OfferApplications to count.
     * @example
     * // Count the number of OfferApplications
     * const count = await prisma.offerApplication.count({
     *   where: {
     *     // ... the filter for the OfferApplications we want to count
     *   }
     * })
    **/
    count<T extends OfferApplicationCountArgs>(
      args?: Subset<T, OfferApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OfferApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OfferApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OfferApplicationAggregateArgs>(args: Subset<T, OfferApplicationAggregateArgs>): Prisma.PrismaPromise<GetOfferApplicationAggregateType<T>>

    /**
     * Group by OfferApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OfferApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OfferApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OfferApplicationGroupByArgs['orderBy'] }
        : { orderBy?: OfferApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OfferApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOfferApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OfferApplication model
   */
  readonly fields: OfferApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OfferApplication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OfferApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    affiliate<T extends AffiliateProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AffiliateProfileDefaultArgs<ExtArgs>>): Prisma__AffiliateProfileClient<$Result.GetResult<Prisma.$AffiliateProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    offer<T extends OfferDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OfferDefaultArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OfferApplication model
   */ 
  interface OfferApplicationFieldRefs {
    readonly id: FieldRef<"OfferApplication", 'String'>
    readonly affiliateId: FieldRef<"OfferApplication", 'String'>
    readonly offerId: FieldRef<"OfferApplication", 'String'>
    readonly status: FieldRef<"OfferApplication", 'ApplicationStatus'>
    readonly message: FieldRef<"OfferApplication", 'String'>
    readonly createdAt: FieldRef<"OfferApplication", 'DateTime'>
    readonly updatedAt: FieldRef<"OfferApplication", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OfferApplication findUnique
   */
  export type OfferApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferApplication
     */
    select?: OfferApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferApplicationInclude<ExtArgs> | null
    /**
     * Filter, which OfferApplication to fetch.
     */
    where: OfferApplicationWhereUniqueInput
  }

  /**
   * OfferApplication findUniqueOrThrow
   */
  export type OfferApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferApplication
     */
    select?: OfferApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferApplicationInclude<ExtArgs> | null
    /**
     * Filter, which OfferApplication to fetch.
     */
    where: OfferApplicationWhereUniqueInput
  }

  /**
   * OfferApplication findFirst
   */
  export type OfferApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferApplication
     */
    select?: OfferApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferApplicationInclude<ExtArgs> | null
    /**
     * Filter, which OfferApplication to fetch.
     */
    where?: OfferApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferApplications to fetch.
     */
    orderBy?: OfferApplicationOrderByWithRelationInput | OfferApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OfferApplications.
     */
    cursor?: OfferApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OfferApplications.
     */
    distinct?: OfferApplicationScalarFieldEnum | OfferApplicationScalarFieldEnum[]
  }

  /**
   * OfferApplication findFirstOrThrow
   */
  export type OfferApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferApplication
     */
    select?: OfferApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferApplicationInclude<ExtArgs> | null
    /**
     * Filter, which OfferApplication to fetch.
     */
    where?: OfferApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferApplications to fetch.
     */
    orderBy?: OfferApplicationOrderByWithRelationInput | OfferApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OfferApplications.
     */
    cursor?: OfferApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OfferApplications.
     */
    distinct?: OfferApplicationScalarFieldEnum | OfferApplicationScalarFieldEnum[]
  }

  /**
   * OfferApplication findMany
   */
  export type OfferApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferApplication
     */
    select?: OfferApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferApplicationInclude<ExtArgs> | null
    /**
     * Filter, which OfferApplications to fetch.
     */
    where?: OfferApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OfferApplications to fetch.
     */
    orderBy?: OfferApplicationOrderByWithRelationInput | OfferApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OfferApplications.
     */
    cursor?: OfferApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OfferApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OfferApplications.
     */
    skip?: number
    distinct?: OfferApplicationScalarFieldEnum | OfferApplicationScalarFieldEnum[]
  }

  /**
   * OfferApplication create
   */
  export type OfferApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferApplication
     */
    select?: OfferApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferApplicationInclude<ExtArgs> | null
    /**
     * The data needed to create a OfferApplication.
     */
    data: XOR<OfferApplicationCreateInput, OfferApplicationUncheckedCreateInput>
  }

  /**
   * OfferApplication createMany
   */
  export type OfferApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OfferApplications.
     */
    data: OfferApplicationCreateManyInput | OfferApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OfferApplication createManyAndReturn
   */
  export type OfferApplicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferApplication
     */
    select?: OfferApplicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OfferApplications.
     */
    data: OfferApplicationCreateManyInput | OfferApplicationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferApplicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OfferApplication update
   */
  export type OfferApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferApplication
     */
    select?: OfferApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferApplicationInclude<ExtArgs> | null
    /**
     * The data needed to update a OfferApplication.
     */
    data: XOR<OfferApplicationUpdateInput, OfferApplicationUncheckedUpdateInput>
    /**
     * Choose, which OfferApplication to update.
     */
    where: OfferApplicationWhereUniqueInput
  }

  /**
   * OfferApplication updateMany
   */
  export type OfferApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OfferApplications.
     */
    data: XOR<OfferApplicationUpdateManyMutationInput, OfferApplicationUncheckedUpdateManyInput>
    /**
     * Filter which OfferApplications to update
     */
    where?: OfferApplicationWhereInput
  }

  /**
   * OfferApplication upsert
   */
  export type OfferApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferApplication
     */
    select?: OfferApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferApplicationInclude<ExtArgs> | null
    /**
     * The filter to search for the OfferApplication to update in case it exists.
     */
    where: OfferApplicationWhereUniqueInput
    /**
     * In case the OfferApplication found by the `where` argument doesn't exist, create a new OfferApplication with this data.
     */
    create: XOR<OfferApplicationCreateInput, OfferApplicationUncheckedCreateInput>
    /**
     * In case the OfferApplication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OfferApplicationUpdateInput, OfferApplicationUncheckedUpdateInput>
  }

  /**
   * OfferApplication delete
   */
  export type OfferApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferApplication
     */
    select?: OfferApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferApplicationInclude<ExtArgs> | null
    /**
     * Filter which OfferApplication to delete.
     */
    where: OfferApplicationWhereUniqueInput
  }

  /**
   * OfferApplication deleteMany
   */
  export type OfferApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OfferApplications to delete
     */
    where?: OfferApplicationWhereInput
  }

  /**
   * OfferApplication without action
   */
  export type OfferApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OfferApplication
     */
    select?: OfferApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferApplicationInclude<ExtArgs> | null
  }


  /**
   * Model AffiliateLink
   */

  export type AggregateAffiliateLink = {
    _count: AffiliateLinkCountAggregateOutputType | null
    _avg: AffiliateLinkAvgAggregateOutputType | null
    _sum: AffiliateLinkSumAggregateOutputType | null
    _min: AffiliateLinkMinAggregateOutputType | null
    _max: AffiliateLinkMaxAggregateOutputType | null
  }

  export type AffiliateLinkAvgAggregateOutputType = {
    clicks: number | null
    conversions: number | null
    earnings: number | null
  }

  export type AffiliateLinkSumAggregateOutputType = {
    clicks: number | null
    conversions: number | null
    earnings: number | null
  }

  export type AffiliateLinkMinAggregateOutputType = {
    id: string | null
    affiliateId: string | null
    offerId: string | null
    originalUrl: string | null
    shortUrl: string | null
    customSlug: string | null
    clicks: number | null
    conversions: number | null
    earnings: number | null
    isActive: boolean | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AffiliateLinkMaxAggregateOutputType = {
    id: string | null
    affiliateId: string | null
    offerId: string | null
    originalUrl: string | null
    shortUrl: string | null
    customSlug: string | null
    clicks: number | null
    conversions: number | null
    earnings: number | null
    isActive: boolean | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AffiliateLinkCountAggregateOutputType = {
    id: number
    affiliateId: number
    offerId: number
    originalUrl: number
    shortUrl: number
    customSlug: number
    clicks: number
    conversions: number
    earnings: number
    isActive: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AffiliateLinkAvgAggregateInputType = {
    clicks?: true
    conversions?: true
    earnings?: true
  }

  export type AffiliateLinkSumAggregateInputType = {
    clicks?: true
    conversions?: true
    earnings?: true
  }

  export type AffiliateLinkMinAggregateInputType = {
    id?: true
    affiliateId?: true
    offerId?: true
    originalUrl?: true
    shortUrl?: true
    customSlug?: true
    clicks?: true
    conversions?: true
    earnings?: true
    isActive?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AffiliateLinkMaxAggregateInputType = {
    id?: true
    affiliateId?: true
    offerId?: true
    originalUrl?: true
    shortUrl?: true
    customSlug?: true
    clicks?: true
    conversions?: true
    earnings?: true
    isActive?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AffiliateLinkCountAggregateInputType = {
    id?: true
    affiliateId?: true
    offerId?: true
    originalUrl?: true
    shortUrl?: true
    customSlug?: true
    clicks?: true
    conversions?: true
    earnings?: true
    isActive?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AffiliateLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AffiliateLink to aggregate.
     */
    where?: AffiliateLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateLinks to fetch.
     */
    orderBy?: AffiliateLinkOrderByWithRelationInput | AffiliateLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AffiliateLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AffiliateLinks
    **/
    _count?: true | AffiliateLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AffiliateLinkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AffiliateLinkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AffiliateLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AffiliateLinkMaxAggregateInputType
  }

  export type GetAffiliateLinkAggregateType<T extends AffiliateLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateAffiliateLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAffiliateLink[P]>
      : GetScalarType<T[P], AggregateAffiliateLink[P]>
  }




  export type AffiliateLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliateLinkWhereInput
    orderBy?: AffiliateLinkOrderByWithAggregationInput | AffiliateLinkOrderByWithAggregationInput[]
    by: AffiliateLinkScalarFieldEnum[] | AffiliateLinkScalarFieldEnum
    having?: AffiliateLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AffiliateLinkCountAggregateInputType | true
    _avg?: AffiliateLinkAvgAggregateInputType
    _sum?: AffiliateLinkSumAggregateInputType
    _min?: AffiliateLinkMinAggregateInputType
    _max?: AffiliateLinkMaxAggregateInputType
  }

  export type AffiliateLinkGroupByOutputType = {
    id: string
    affiliateId: string
    offerId: string | null
    originalUrl: string
    shortUrl: string
    customSlug: string | null
    clicks: number
    conversions: number
    earnings: number
    isActive: boolean
    expiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: AffiliateLinkCountAggregateOutputType | null
    _avg: AffiliateLinkAvgAggregateOutputType | null
    _sum: AffiliateLinkSumAggregateOutputType | null
    _min: AffiliateLinkMinAggregateOutputType | null
    _max: AffiliateLinkMaxAggregateOutputType | null
  }

  type GetAffiliateLinkGroupByPayload<T extends AffiliateLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AffiliateLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AffiliateLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AffiliateLinkGroupByOutputType[P]>
            : GetScalarType<T[P], AffiliateLinkGroupByOutputType[P]>
        }
      >
    >


  export type AffiliateLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    affiliateId?: boolean
    offerId?: boolean
    originalUrl?: boolean
    shortUrl?: boolean
    customSlug?: boolean
    clicks?: boolean
    conversions?: boolean
    earnings?: boolean
    isActive?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    affiliate?: boolean | AffiliateProfileDefaultArgs<ExtArgs>
    offer?: boolean | AffiliateLink$offerArgs<ExtArgs>
    clickRecords?: boolean | AffiliateLink$clickRecordsArgs<ExtArgs>
    _count?: boolean | AffiliateLinkCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["affiliateLink"]>

  export type AffiliateLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    affiliateId?: boolean
    offerId?: boolean
    originalUrl?: boolean
    shortUrl?: boolean
    customSlug?: boolean
    clicks?: boolean
    conversions?: boolean
    earnings?: boolean
    isActive?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    affiliate?: boolean | AffiliateProfileDefaultArgs<ExtArgs>
    offer?: boolean | AffiliateLink$offerArgs<ExtArgs>
  }, ExtArgs["result"]["affiliateLink"]>

  export type AffiliateLinkSelectScalar = {
    id?: boolean
    affiliateId?: boolean
    offerId?: boolean
    originalUrl?: boolean
    shortUrl?: boolean
    customSlug?: boolean
    clicks?: boolean
    conversions?: boolean
    earnings?: boolean
    isActive?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AffiliateLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliate?: boolean | AffiliateProfileDefaultArgs<ExtArgs>
    offer?: boolean | AffiliateLink$offerArgs<ExtArgs>
    clickRecords?: boolean | AffiliateLink$clickRecordsArgs<ExtArgs>
    _count?: boolean | AffiliateLinkCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AffiliateLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliate?: boolean | AffiliateProfileDefaultArgs<ExtArgs>
    offer?: boolean | AffiliateLink$offerArgs<ExtArgs>
  }

  export type $AffiliateLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AffiliateLink"
    objects: {
      affiliate: Prisma.$AffiliateProfilePayload<ExtArgs>
      offer: Prisma.$OfferPayload<ExtArgs> | null
      clickRecords: Prisma.$ClickPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      affiliateId: string
      offerId: string | null
      originalUrl: string
      shortUrl: string
      customSlug: string | null
      clicks: number
      conversions: number
      earnings: number
      isActive: boolean
      expiresAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["affiliateLink"]>
    composites: {}
  }

  type AffiliateLinkGetPayload<S extends boolean | null | undefined | AffiliateLinkDefaultArgs> = $Result.GetResult<Prisma.$AffiliateLinkPayload, S>

  type AffiliateLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AffiliateLinkFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AffiliateLinkCountAggregateInputType | true
    }

  export interface AffiliateLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AffiliateLink'], meta: { name: 'AffiliateLink' } }
    /**
     * Find zero or one AffiliateLink that matches the filter.
     * @param {AffiliateLinkFindUniqueArgs} args - Arguments to find a AffiliateLink
     * @example
     * // Get one AffiliateLink
     * const affiliateLink = await prisma.affiliateLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AffiliateLinkFindUniqueArgs>(args: SelectSubset<T, AffiliateLinkFindUniqueArgs<ExtArgs>>): Prisma__AffiliateLinkClient<$Result.GetResult<Prisma.$AffiliateLinkPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AffiliateLink that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AffiliateLinkFindUniqueOrThrowArgs} args - Arguments to find a AffiliateLink
     * @example
     * // Get one AffiliateLink
     * const affiliateLink = await prisma.affiliateLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AffiliateLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, AffiliateLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AffiliateLinkClient<$Result.GetResult<Prisma.$AffiliateLinkPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AffiliateLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateLinkFindFirstArgs} args - Arguments to find a AffiliateLink
     * @example
     * // Get one AffiliateLink
     * const affiliateLink = await prisma.affiliateLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AffiliateLinkFindFirstArgs>(args?: SelectSubset<T, AffiliateLinkFindFirstArgs<ExtArgs>>): Prisma__AffiliateLinkClient<$Result.GetResult<Prisma.$AffiliateLinkPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AffiliateLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateLinkFindFirstOrThrowArgs} args - Arguments to find a AffiliateLink
     * @example
     * // Get one AffiliateLink
     * const affiliateLink = await prisma.affiliateLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AffiliateLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, AffiliateLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__AffiliateLinkClient<$Result.GetResult<Prisma.$AffiliateLinkPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AffiliateLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AffiliateLinks
     * const affiliateLinks = await prisma.affiliateLink.findMany()
     * 
     * // Get first 10 AffiliateLinks
     * const affiliateLinks = await prisma.affiliateLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const affiliateLinkWithIdOnly = await prisma.affiliateLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AffiliateLinkFindManyArgs>(args?: SelectSubset<T, AffiliateLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateLinkPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AffiliateLink.
     * @param {AffiliateLinkCreateArgs} args - Arguments to create a AffiliateLink.
     * @example
     * // Create one AffiliateLink
     * const AffiliateLink = await prisma.affiliateLink.create({
     *   data: {
     *     // ... data to create a AffiliateLink
     *   }
     * })
     * 
     */
    create<T extends AffiliateLinkCreateArgs>(args: SelectSubset<T, AffiliateLinkCreateArgs<ExtArgs>>): Prisma__AffiliateLinkClient<$Result.GetResult<Prisma.$AffiliateLinkPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AffiliateLinks.
     * @param {AffiliateLinkCreateManyArgs} args - Arguments to create many AffiliateLinks.
     * @example
     * // Create many AffiliateLinks
     * const affiliateLink = await prisma.affiliateLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AffiliateLinkCreateManyArgs>(args?: SelectSubset<T, AffiliateLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AffiliateLinks and returns the data saved in the database.
     * @param {AffiliateLinkCreateManyAndReturnArgs} args - Arguments to create many AffiliateLinks.
     * @example
     * // Create many AffiliateLinks
     * const affiliateLink = await prisma.affiliateLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AffiliateLinks and only return the `id`
     * const affiliateLinkWithIdOnly = await prisma.affiliateLink.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AffiliateLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, AffiliateLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateLinkPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AffiliateLink.
     * @param {AffiliateLinkDeleteArgs} args - Arguments to delete one AffiliateLink.
     * @example
     * // Delete one AffiliateLink
     * const AffiliateLink = await prisma.affiliateLink.delete({
     *   where: {
     *     // ... filter to delete one AffiliateLink
     *   }
     * })
     * 
     */
    delete<T extends AffiliateLinkDeleteArgs>(args: SelectSubset<T, AffiliateLinkDeleteArgs<ExtArgs>>): Prisma__AffiliateLinkClient<$Result.GetResult<Prisma.$AffiliateLinkPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AffiliateLink.
     * @param {AffiliateLinkUpdateArgs} args - Arguments to update one AffiliateLink.
     * @example
     * // Update one AffiliateLink
     * const affiliateLink = await prisma.affiliateLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AffiliateLinkUpdateArgs>(args: SelectSubset<T, AffiliateLinkUpdateArgs<ExtArgs>>): Prisma__AffiliateLinkClient<$Result.GetResult<Prisma.$AffiliateLinkPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AffiliateLinks.
     * @param {AffiliateLinkDeleteManyArgs} args - Arguments to filter AffiliateLinks to delete.
     * @example
     * // Delete a few AffiliateLinks
     * const { count } = await prisma.affiliateLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AffiliateLinkDeleteManyArgs>(args?: SelectSubset<T, AffiliateLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AffiliateLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AffiliateLinks
     * const affiliateLink = await prisma.affiliateLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AffiliateLinkUpdateManyArgs>(args: SelectSubset<T, AffiliateLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AffiliateLink.
     * @param {AffiliateLinkUpsertArgs} args - Arguments to update or create a AffiliateLink.
     * @example
     * // Update or create a AffiliateLink
     * const affiliateLink = await prisma.affiliateLink.upsert({
     *   create: {
     *     // ... data to create a AffiliateLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AffiliateLink we want to update
     *   }
     * })
     */
    upsert<T extends AffiliateLinkUpsertArgs>(args: SelectSubset<T, AffiliateLinkUpsertArgs<ExtArgs>>): Prisma__AffiliateLinkClient<$Result.GetResult<Prisma.$AffiliateLinkPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AffiliateLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateLinkCountArgs} args - Arguments to filter AffiliateLinks to count.
     * @example
     * // Count the number of AffiliateLinks
     * const count = await prisma.affiliateLink.count({
     *   where: {
     *     // ... the filter for the AffiliateLinks we want to count
     *   }
     * })
    **/
    count<T extends AffiliateLinkCountArgs>(
      args?: Subset<T, AffiliateLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AffiliateLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AffiliateLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AffiliateLinkAggregateArgs>(args: Subset<T, AffiliateLinkAggregateArgs>): Prisma.PrismaPromise<GetAffiliateLinkAggregateType<T>>

    /**
     * Group by AffiliateLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AffiliateLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AffiliateLinkGroupByArgs['orderBy'] }
        : { orderBy?: AffiliateLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AffiliateLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAffiliateLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AffiliateLink model
   */
  readonly fields: AffiliateLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AffiliateLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AffiliateLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    affiliate<T extends AffiliateProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AffiliateProfileDefaultArgs<ExtArgs>>): Prisma__AffiliateProfileClient<$Result.GetResult<Prisma.$AffiliateProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    offer<T extends AffiliateLink$offerArgs<ExtArgs> = {}>(args?: Subset<T, AffiliateLink$offerArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    clickRecords<T extends AffiliateLink$clickRecordsArgs<ExtArgs> = {}>(args?: Subset<T, AffiliateLink$clickRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClickPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AffiliateLink model
   */ 
  interface AffiliateLinkFieldRefs {
    readonly id: FieldRef<"AffiliateLink", 'String'>
    readonly affiliateId: FieldRef<"AffiliateLink", 'String'>
    readonly offerId: FieldRef<"AffiliateLink", 'String'>
    readonly originalUrl: FieldRef<"AffiliateLink", 'String'>
    readonly shortUrl: FieldRef<"AffiliateLink", 'String'>
    readonly customSlug: FieldRef<"AffiliateLink", 'String'>
    readonly clicks: FieldRef<"AffiliateLink", 'Int'>
    readonly conversions: FieldRef<"AffiliateLink", 'Int'>
    readonly earnings: FieldRef<"AffiliateLink", 'Float'>
    readonly isActive: FieldRef<"AffiliateLink", 'Boolean'>
    readonly expiresAt: FieldRef<"AffiliateLink", 'DateTime'>
    readonly createdAt: FieldRef<"AffiliateLink", 'DateTime'>
    readonly updatedAt: FieldRef<"AffiliateLink", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AffiliateLink findUnique
   */
  export type AffiliateLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLink
     */
    select?: AffiliateLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateLinkInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateLink to fetch.
     */
    where: AffiliateLinkWhereUniqueInput
  }

  /**
   * AffiliateLink findUniqueOrThrow
   */
  export type AffiliateLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLink
     */
    select?: AffiliateLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateLinkInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateLink to fetch.
     */
    where: AffiliateLinkWhereUniqueInput
  }

  /**
   * AffiliateLink findFirst
   */
  export type AffiliateLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLink
     */
    select?: AffiliateLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateLinkInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateLink to fetch.
     */
    where?: AffiliateLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateLinks to fetch.
     */
    orderBy?: AffiliateLinkOrderByWithRelationInput | AffiliateLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AffiliateLinks.
     */
    cursor?: AffiliateLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AffiliateLinks.
     */
    distinct?: AffiliateLinkScalarFieldEnum | AffiliateLinkScalarFieldEnum[]
  }

  /**
   * AffiliateLink findFirstOrThrow
   */
  export type AffiliateLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLink
     */
    select?: AffiliateLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateLinkInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateLink to fetch.
     */
    where?: AffiliateLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateLinks to fetch.
     */
    orderBy?: AffiliateLinkOrderByWithRelationInput | AffiliateLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AffiliateLinks.
     */
    cursor?: AffiliateLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AffiliateLinks.
     */
    distinct?: AffiliateLinkScalarFieldEnum | AffiliateLinkScalarFieldEnum[]
  }

  /**
   * AffiliateLink findMany
   */
  export type AffiliateLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLink
     */
    select?: AffiliateLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateLinkInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateLinks to fetch.
     */
    where?: AffiliateLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateLinks to fetch.
     */
    orderBy?: AffiliateLinkOrderByWithRelationInput | AffiliateLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AffiliateLinks.
     */
    cursor?: AffiliateLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateLinks.
     */
    skip?: number
    distinct?: AffiliateLinkScalarFieldEnum | AffiliateLinkScalarFieldEnum[]
  }

  /**
   * AffiliateLink create
   */
  export type AffiliateLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLink
     */
    select?: AffiliateLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a AffiliateLink.
     */
    data: XOR<AffiliateLinkCreateInput, AffiliateLinkUncheckedCreateInput>
  }

  /**
   * AffiliateLink createMany
   */
  export type AffiliateLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AffiliateLinks.
     */
    data: AffiliateLinkCreateManyInput | AffiliateLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AffiliateLink createManyAndReturn
   */
  export type AffiliateLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLink
     */
    select?: AffiliateLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AffiliateLinks.
     */
    data: AffiliateLinkCreateManyInput | AffiliateLinkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateLinkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AffiliateLink update
   */
  export type AffiliateLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLink
     */
    select?: AffiliateLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a AffiliateLink.
     */
    data: XOR<AffiliateLinkUpdateInput, AffiliateLinkUncheckedUpdateInput>
    /**
     * Choose, which AffiliateLink to update.
     */
    where: AffiliateLinkWhereUniqueInput
  }

  /**
   * AffiliateLink updateMany
   */
  export type AffiliateLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AffiliateLinks.
     */
    data: XOR<AffiliateLinkUpdateManyMutationInput, AffiliateLinkUncheckedUpdateManyInput>
    /**
     * Filter which AffiliateLinks to update
     */
    where?: AffiliateLinkWhereInput
  }

  /**
   * AffiliateLink upsert
   */
  export type AffiliateLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLink
     */
    select?: AffiliateLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the AffiliateLink to update in case it exists.
     */
    where: AffiliateLinkWhereUniqueInput
    /**
     * In case the AffiliateLink found by the `where` argument doesn't exist, create a new AffiliateLink with this data.
     */
    create: XOR<AffiliateLinkCreateInput, AffiliateLinkUncheckedCreateInput>
    /**
     * In case the AffiliateLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AffiliateLinkUpdateInput, AffiliateLinkUncheckedUpdateInput>
  }

  /**
   * AffiliateLink delete
   */
  export type AffiliateLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLink
     */
    select?: AffiliateLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateLinkInclude<ExtArgs> | null
    /**
     * Filter which AffiliateLink to delete.
     */
    where: AffiliateLinkWhereUniqueInput
  }

  /**
   * AffiliateLink deleteMany
   */
  export type AffiliateLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AffiliateLinks to delete
     */
    where?: AffiliateLinkWhereInput
  }

  /**
   * AffiliateLink.offer
   */
  export type AffiliateLink$offerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Offer
     */
    select?: OfferSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OfferInclude<ExtArgs> | null
    where?: OfferWhereInput
  }

  /**
   * AffiliateLink.clickRecords
   */
  export type AffiliateLink$clickRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Click
     */
    select?: ClickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClickInclude<ExtArgs> | null
    where?: ClickWhereInput
    orderBy?: ClickOrderByWithRelationInput | ClickOrderByWithRelationInput[]
    cursor?: ClickWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClickScalarFieldEnum | ClickScalarFieldEnum[]
  }

  /**
   * AffiliateLink without action
   */
  export type AffiliateLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateLink
     */
    select?: AffiliateLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateLinkInclude<ExtArgs> | null
  }


  /**
   * Model Click
   */

  export type AggregateClick = {
    _count: ClickCountAggregateOutputType | null
    _min: ClickMinAggregateOutputType | null
    _max: ClickMaxAggregateOutputType | null
  }

  export type ClickMinAggregateOutputType = {
    id: string | null
    linkId: string | null
    affiliateId: string | null
    ipAddress: string | null
    userAgent: string | null
    referrer: string | null
    country: string | null
    city: string | null
    device: string | null
    browser: string | null
    os: string | null
    converted: boolean | null
    conversionId: string | null
    createdAt: Date | null
  }

  export type ClickMaxAggregateOutputType = {
    id: string | null
    linkId: string | null
    affiliateId: string | null
    ipAddress: string | null
    userAgent: string | null
    referrer: string | null
    country: string | null
    city: string | null
    device: string | null
    browser: string | null
    os: string | null
    converted: boolean | null
    conversionId: string | null
    createdAt: Date | null
  }

  export type ClickCountAggregateOutputType = {
    id: number
    linkId: number
    affiliateId: number
    ipAddress: number
    userAgent: number
    referrer: number
    country: number
    city: number
    device: number
    browser: number
    os: number
    converted: number
    conversionId: number
    createdAt: number
    _all: number
  }


  export type ClickMinAggregateInputType = {
    id?: true
    linkId?: true
    affiliateId?: true
    ipAddress?: true
    userAgent?: true
    referrer?: true
    country?: true
    city?: true
    device?: true
    browser?: true
    os?: true
    converted?: true
    conversionId?: true
    createdAt?: true
  }

  export type ClickMaxAggregateInputType = {
    id?: true
    linkId?: true
    affiliateId?: true
    ipAddress?: true
    userAgent?: true
    referrer?: true
    country?: true
    city?: true
    device?: true
    browser?: true
    os?: true
    converted?: true
    conversionId?: true
    createdAt?: true
  }

  export type ClickCountAggregateInputType = {
    id?: true
    linkId?: true
    affiliateId?: true
    ipAddress?: true
    userAgent?: true
    referrer?: true
    country?: true
    city?: true
    device?: true
    browser?: true
    os?: true
    converted?: true
    conversionId?: true
    createdAt?: true
    _all?: true
  }

  export type ClickAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Click to aggregate.
     */
    where?: ClickWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clicks to fetch.
     */
    orderBy?: ClickOrderByWithRelationInput | ClickOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClickWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clicks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clicks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clicks
    **/
    _count?: true | ClickCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClickMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClickMaxAggregateInputType
  }

  export type GetClickAggregateType<T extends ClickAggregateArgs> = {
        [P in keyof T & keyof AggregateClick]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClick[P]>
      : GetScalarType<T[P], AggregateClick[P]>
  }




  export type ClickGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClickWhereInput
    orderBy?: ClickOrderByWithAggregationInput | ClickOrderByWithAggregationInput[]
    by: ClickScalarFieldEnum[] | ClickScalarFieldEnum
    having?: ClickScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClickCountAggregateInputType | true
    _min?: ClickMinAggregateInputType
    _max?: ClickMaxAggregateInputType
  }

  export type ClickGroupByOutputType = {
    id: string
    linkId: string
    affiliateId: string
    ipAddress: string
    userAgent: string
    referrer: string | null
    country: string | null
    city: string | null
    device: string | null
    browser: string | null
    os: string | null
    converted: boolean
    conversionId: string | null
    createdAt: Date
    _count: ClickCountAggregateOutputType | null
    _min: ClickMinAggregateOutputType | null
    _max: ClickMaxAggregateOutputType | null
  }

  type GetClickGroupByPayload<T extends ClickGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClickGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClickGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClickGroupByOutputType[P]>
            : GetScalarType<T[P], ClickGroupByOutputType[P]>
        }
      >
    >


  export type ClickSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    linkId?: boolean
    affiliateId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    referrer?: boolean
    country?: boolean
    city?: boolean
    device?: boolean
    browser?: boolean
    os?: boolean
    converted?: boolean
    conversionId?: boolean
    createdAt?: boolean
    link?: boolean | AffiliateLinkDefaultArgs<ExtArgs>
    affiliate?: boolean | AffiliateProfileDefaultArgs<ExtArgs>
    conversion?: boolean | Click$conversionArgs<ExtArgs>
  }, ExtArgs["result"]["click"]>

  export type ClickSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    linkId?: boolean
    affiliateId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    referrer?: boolean
    country?: boolean
    city?: boolean
    device?: boolean
    browser?: boolean
    os?: boolean
    converted?: boolean
    conversionId?: boolean
    createdAt?: boolean
    link?: boolean | AffiliateLinkDefaultArgs<ExtArgs>
    affiliate?: boolean | AffiliateProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["click"]>

  export type ClickSelectScalar = {
    id?: boolean
    linkId?: boolean
    affiliateId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    referrer?: boolean
    country?: boolean
    city?: boolean
    device?: boolean
    browser?: boolean
    os?: boolean
    converted?: boolean
    conversionId?: boolean
    createdAt?: boolean
  }

  export type ClickInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    link?: boolean | AffiliateLinkDefaultArgs<ExtArgs>
    affiliate?: boolean | AffiliateProfileDefaultArgs<ExtArgs>
    conversion?: boolean | Click$conversionArgs<ExtArgs>
  }
  export type ClickIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    link?: boolean | AffiliateLinkDefaultArgs<ExtArgs>
    affiliate?: boolean | AffiliateProfileDefaultArgs<ExtArgs>
  }

  export type $ClickPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Click"
    objects: {
      link: Prisma.$AffiliateLinkPayload<ExtArgs>
      affiliate: Prisma.$AffiliateProfilePayload<ExtArgs>
      conversion: Prisma.$ConversionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      linkId: string
      affiliateId: string
      ipAddress: string
      userAgent: string
      referrer: string | null
      country: string | null
      city: string | null
      device: string | null
      browser: string | null
      os: string | null
      converted: boolean
      conversionId: string | null
      createdAt: Date
    }, ExtArgs["result"]["click"]>
    composites: {}
  }

  type ClickGetPayload<S extends boolean | null | undefined | ClickDefaultArgs> = $Result.GetResult<Prisma.$ClickPayload, S>

  type ClickCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClickFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClickCountAggregateInputType | true
    }

  export interface ClickDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Click'], meta: { name: 'Click' } }
    /**
     * Find zero or one Click that matches the filter.
     * @param {ClickFindUniqueArgs} args - Arguments to find a Click
     * @example
     * // Get one Click
     * const click = await prisma.click.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClickFindUniqueArgs>(args: SelectSubset<T, ClickFindUniqueArgs<ExtArgs>>): Prisma__ClickClient<$Result.GetResult<Prisma.$ClickPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Click that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClickFindUniqueOrThrowArgs} args - Arguments to find a Click
     * @example
     * // Get one Click
     * const click = await prisma.click.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClickFindUniqueOrThrowArgs>(args: SelectSubset<T, ClickFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClickClient<$Result.GetResult<Prisma.$ClickPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Click that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClickFindFirstArgs} args - Arguments to find a Click
     * @example
     * // Get one Click
     * const click = await prisma.click.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClickFindFirstArgs>(args?: SelectSubset<T, ClickFindFirstArgs<ExtArgs>>): Prisma__ClickClient<$Result.GetResult<Prisma.$ClickPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Click that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClickFindFirstOrThrowArgs} args - Arguments to find a Click
     * @example
     * // Get one Click
     * const click = await prisma.click.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClickFindFirstOrThrowArgs>(args?: SelectSubset<T, ClickFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClickClient<$Result.GetResult<Prisma.$ClickPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Clicks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClickFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clicks
     * const clicks = await prisma.click.findMany()
     * 
     * // Get first 10 Clicks
     * const clicks = await prisma.click.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clickWithIdOnly = await prisma.click.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClickFindManyArgs>(args?: SelectSubset<T, ClickFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClickPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Click.
     * @param {ClickCreateArgs} args - Arguments to create a Click.
     * @example
     * // Create one Click
     * const Click = await prisma.click.create({
     *   data: {
     *     // ... data to create a Click
     *   }
     * })
     * 
     */
    create<T extends ClickCreateArgs>(args: SelectSubset<T, ClickCreateArgs<ExtArgs>>): Prisma__ClickClient<$Result.GetResult<Prisma.$ClickPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Clicks.
     * @param {ClickCreateManyArgs} args - Arguments to create many Clicks.
     * @example
     * // Create many Clicks
     * const click = await prisma.click.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClickCreateManyArgs>(args?: SelectSubset<T, ClickCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clicks and returns the data saved in the database.
     * @param {ClickCreateManyAndReturnArgs} args - Arguments to create many Clicks.
     * @example
     * // Create many Clicks
     * const click = await prisma.click.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clicks and only return the `id`
     * const clickWithIdOnly = await prisma.click.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClickCreateManyAndReturnArgs>(args?: SelectSubset<T, ClickCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClickPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Click.
     * @param {ClickDeleteArgs} args - Arguments to delete one Click.
     * @example
     * // Delete one Click
     * const Click = await prisma.click.delete({
     *   where: {
     *     // ... filter to delete one Click
     *   }
     * })
     * 
     */
    delete<T extends ClickDeleteArgs>(args: SelectSubset<T, ClickDeleteArgs<ExtArgs>>): Prisma__ClickClient<$Result.GetResult<Prisma.$ClickPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Click.
     * @param {ClickUpdateArgs} args - Arguments to update one Click.
     * @example
     * // Update one Click
     * const click = await prisma.click.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClickUpdateArgs>(args: SelectSubset<T, ClickUpdateArgs<ExtArgs>>): Prisma__ClickClient<$Result.GetResult<Prisma.$ClickPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Clicks.
     * @param {ClickDeleteManyArgs} args - Arguments to filter Clicks to delete.
     * @example
     * // Delete a few Clicks
     * const { count } = await prisma.click.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClickDeleteManyArgs>(args?: SelectSubset<T, ClickDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clicks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClickUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clicks
     * const click = await prisma.click.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClickUpdateManyArgs>(args: SelectSubset<T, ClickUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Click.
     * @param {ClickUpsertArgs} args - Arguments to update or create a Click.
     * @example
     * // Update or create a Click
     * const click = await prisma.click.upsert({
     *   create: {
     *     // ... data to create a Click
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Click we want to update
     *   }
     * })
     */
    upsert<T extends ClickUpsertArgs>(args: SelectSubset<T, ClickUpsertArgs<ExtArgs>>): Prisma__ClickClient<$Result.GetResult<Prisma.$ClickPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Clicks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClickCountArgs} args - Arguments to filter Clicks to count.
     * @example
     * // Count the number of Clicks
     * const count = await prisma.click.count({
     *   where: {
     *     // ... the filter for the Clicks we want to count
     *   }
     * })
    **/
    count<T extends ClickCountArgs>(
      args?: Subset<T, ClickCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClickCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Click.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClickAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClickAggregateArgs>(args: Subset<T, ClickAggregateArgs>): Prisma.PrismaPromise<GetClickAggregateType<T>>

    /**
     * Group by Click.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClickGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClickGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClickGroupByArgs['orderBy'] }
        : { orderBy?: ClickGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClickGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClickGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Click model
   */
  readonly fields: ClickFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Click.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClickClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    link<T extends AffiliateLinkDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AffiliateLinkDefaultArgs<ExtArgs>>): Prisma__AffiliateLinkClient<$Result.GetResult<Prisma.$AffiliateLinkPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    affiliate<T extends AffiliateProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AffiliateProfileDefaultArgs<ExtArgs>>): Prisma__AffiliateProfileClient<$Result.GetResult<Prisma.$AffiliateProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    conversion<T extends Click$conversionArgs<ExtArgs> = {}>(args?: Subset<T, Click$conversionArgs<ExtArgs>>): Prisma__ConversionClient<$Result.GetResult<Prisma.$ConversionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Click model
   */ 
  interface ClickFieldRefs {
    readonly id: FieldRef<"Click", 'String'>
    readonly linkId: FieldRef<"Click", 'String'>
    readonly affiliateId: FieldRef<"Click", 'String'>
    readonly ipAddress: FieldRef<"Click", 'String'>
    readonly userAgent: FieldRef<"Click", 'String'>
    readonly referrer: FieldRef<"Click", 'String'>
    readonly country: FieldRef<"Click", 'String'>
    readonly city: FieldRef<"Click", 'String'>
    readonly device: FieldRef<"Click", 'String'>
    readonly browser: FieldRef<"Click", 'String'>
    readonly os: FieldRef<"Click", 'String'>
    readonly converted: FieldRef<"Click", 'Boolean'>
    readonly conversionId: FieldRef<"Click", 'String'>
    readonly createdAt: FieldRef<"Click", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Click findUnique
   */
  export type ClickFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Click
     */
    select?: ClickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClickInclude<ExtArgs> | null
    /**
     * Filter, which Click to fetch.
     */
    where: ClickWhereUniqueInput
  }

  /**
   * Click findUniqueOrThrow
   */
  export type ClickFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Click
     */
    select?: ClickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClickInclude<ExtArgs> | null
    /**
     * Filter, which Click to fetch.
     */
    where: ClickWhereUniqueInput
  }

  /**
   * Click findFirst
   */
  export type ClickFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Click
     */
    select?: ClickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClickInclude<ExtArgs> | null
    /**
     * Filter, which Click to fetch.
     */
    where?: ClickWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clicks to fetch.
     */
    orderBy?: ClickOrderByWithRelationInput | ClickOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clicks.
     */
    cursor?: ClickWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clicks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clicks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clicks.
     */
    distinct?: ClickScalarFieldEnum | ClickScalarFieldEnum[]
  }

  /**
   * Click findFirstOrThrow
   */
  export type ClickFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Click
     */
    select?: ClickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClickInclude<ExtArgs> | null
    /**
     * Filter, which Click to fetch.
     */
    where?: ClickWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clicks to fetch.
     */
    orderBy?: ClickOrderByWithRelationInput | ClickOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clicks.
     */
    cursor?: ClickWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clicks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clicks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clicks.
     */
    distinct?: ClickScalarFieldEnum | ClickScalarFieldEnum[]
  }

  /**
   * Click findMany
   */
  export type ClickFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Click
     */
    select?: ClickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClickInclude<ExtArgs> | null
    /**
     * Filter, which Clicks to fetch.
     */
    where?: ClickWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clicks to fetch.
     */
    orderBy?: ClickOrderByWithRelationInput | ClickOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clicks.
     */
    cursor?: ClickWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clicks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clicks.
     */
    skip?: number
    distinct?: ClickScalarFieldEnum | ClickScalarFieldEnum[]
  }

  /**
   * Click create
   */
  export type ClickCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Click
     */
    select?: ClickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClickInclude<ExtArgs> | null
    /**
     * The data needed to create a Click.
     */
    data: XOR<ClickCreateInput, ClickUncheckedCreateInput>
  }

  /**
   * Click createMany
   */
  export type ClickCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clicks.
     */
    data: ClickCreateManyInput | ClickCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Click createManyAndReturn
   */
  export type ClickCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Click
     */
    select?: ClickSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Clicks.
     */
    data: ClickCreateManyInput | ClickCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClickIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Click update
   */
  export type ClickUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Click
     */
    select?: ClickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClickInclude<ExtArgs> | null
    /**
     * The data needed to update a Click.
     */
    data: XOR<ClickUpdateInput, ClickUncheckedUpdateInput>
    /**
     * Choose, which Click to update.
     */
    where: ClickWhereUniqueInput
  }

  /**
   * Click updateMany
   */
  export type ClickUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clicks.
     */
    data: XOR<ClickUpdateManyMutationInput, ClickUncheckedUpdateManyInput>
    /**
     * Filter which Clicks to update
     */
    where?: ClickWhereInput
  }

  /**
   * Click upsert
   */
  export type ClickUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Click
     */
    select?: ClickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClickInclude<ExtArgs> | null
    /**
     * The filter to search for the Click to update in case it exists.
     */
    where: ClickWhereUniqueInput
    /**
     * In case the Click found by the `where` argument doesn't exist, create a new Click with this data.
     */
    create: XOR<ClickCreateInput, ClickUncheckedCreateInput>
    /**
     * In case the Click was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClickUpdateInput, ClickUncheckedUpdateInput>
  }

  /**
   * Click delete
   */
  export type ClickDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Click
     */
    select?: ClickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClickInclude<ExtArgs> | null
    /**
     * Filter which Click to delete.
     */
    where: ClickWhereUniqueInput
  }

  /**
   * Click deleteMany
   */
  export type ClickDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clicks to delete
     */
    where?: ClickWhereInput
  }

  /**
   * Click.conversion
   */
  export type Click$conversionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversion
     */
    select?: ConversionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversionInclude<ExtArgs> | null
    where?: ConversionWhereInput
  }

  /**
   * Click without action
   */
  export type ClickDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Click
     */
    select?: ClickSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClickInclude<ExtArgs> | null
  }


  /**
   * Model Conversion
   */

  export type AggregateConversion = {
    _count: ConversionCountAggregateOutputType | null
    _avg: ConversionAvgAggregateOutputType | null
    _sum: ConversionSumAggregateOutputType | null
    _min: ConversionMinAggregateOutputType | null
    _max: ConversionMaxAggregateOutputType | null
  }

  export type ConversionAvgAggregateOutputType = {
    customerValue: number | null
    commissionAmount: number | null
  }

  export type ConversionSumAggregateOutputType = {
    customerValue: number | null
    commissionAmount: number | null
  }

  export type ConversionMinAggregateOutputType = {
    id: string | null
    clickId: string | null
    affiliateId: string | null
    offerId: string | null
    customerEmail: string | null
    customerValue: number | null
    commissionAmount: number | null
    status: $Enums.ConversionStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversionMaxAggregateOutputType = {
    id: string | null
    clickId: string | null
    affiliateId: string | null
    offerId: string | null
    customerEmail: string | null
    customerValue: number | null
    commissionAmount: number | null
    status: $Enums.ConversionStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversionCountAggregateOutputType = {
    id: number
    clickId: number
    affiliateId: number
    offerId: number
    customerEmail: number
    customerValue: number
    commissionAmount: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConversionAvgAggregateInputType = {
    customerValue?: true
    commissionAmount?: true
  }

  export type ConversionSumAggregateInputType = {
    customerValue?: true
    commissionAmount?: true
  }

  export type ConversionMinAggregateInputType = {
    id?: true
    clickId?: true
    affiliateId?: true
    offerId?: true
    customerEmail?: true
    customerValue?: true
    commissionAmount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversionMaxAggregateInputType = {
    id?: true
    clickId?: true
    affiliateId?: true
    offerId?: true
    customerEmail?: true
    customerValue?: true
    commissionAmount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversionCountAggregateInputType = {
    id?: true
    clickId?: true
    affiliateId?: true
    offerId?: true
    customerEmail?: true
    customerValue?: true
    commissionAmount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConversionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversion to aggregate.
     */
    where?: ConversionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversions to fetch.
     */
    orderBy?: ConversionOrderByWithRelationInput | ConversionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conversions
    **/
    _count?: true | ConversionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConversionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConversionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversionMaxAggregateInputType
  }

  export type GetConversionAggregateType<T extends ConversionAggregateArgs> = {
        [P in keyof T & keyof AggregateConversion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversion[P]>
      : GetScalarType<T[P], AggregateConversion[P]>
  }




  export type ConversionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversionWhereInput
    orderBy?: ConversionOrderByWithAggregationInput | ConversionOrderByWithAggregationInput[]
    by: ConversionScalarFieldEnum[] | ConversionScalarFieldEnum
    having?: ConversionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversionCountAggregateInputType | true
    _avg?: ConversionAvgAggregateInputType
    _sum?: ConversionSumAggregateInputType
    _min?: ConversionMinAggregateInputType
    _max?: ConversionMaxAggregateInputType
  }

  export type ConversionGroupByOutputType = {
    id: string
    clickId: string
    affiliateId: string
    offerId: string
    customerEmail: string | null
    customerValue: number
    commissionAmount: number
    status: $Enums.ConversionStatus
    createdAt: Date
    updatedAt: Date
    _count: ConversionCountAggregateOutputType | null
    _avg: ConversionAvgAggregateOutputType | null
    _sum: ConversionSumAggregateOutputType | null
    _min: ConversionMinAggregateOutputType | null
    _max: ConversionMaxAggregateOutputType | null
  }

  type GetConversionGroupByPayload<T extends ConversionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversionGroupByOutputType[P]>
            : GetScalarType<T[P], ConversionGroupByOutputType[P]>
        }
      >
    >


  export type ConversionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clickId?: boolean
    affiliateId?: boolean
    offerId?: boolean
    customerEmail?: boolean
    customerValue?: boolean
    commissionAmount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    click?: boolean | ClickDefaultArgs<ExtArgs>
    affiliate?: boolean | AffiliateProfileDefaultArgs<ExtArgs>
    offer?: boolean | OfferDefaultArgs<ExtArgs>
    commission?: boolean | Conversion$commissionArgs<ExtArgs>
  }, ExtArgs["result"]["conversion"]>

  export type ConversionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clickId?: boolean
    affiliateId?: boolean
    offerId?: boolean
    customerEmail?: boolean
    customerValue?: boolean
    commissionAmount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    click?: boolean | ClickDefaultArgs<ExtArgs>
    affiliate?: boolean | AffiliateProfileDefaultArgs<ExtArgs>
    offer?: boolean | OfferDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversion"]>

  export type ConversionSelectScalar = {
    id?: boolean
    clickId?: boolean
    affiliateId?: boolean
    offerId?: boolean
    customerEmail?: boolean
    customerValue?: boolean
    commissionAmount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConversionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    click?: boolean | ClickDefaultArgs<ExtArgs>
    affiliate?: boolean | AffiliateProfileDefaultArgs<ExtArgs>
    offer?: boolean | OfferDefaultArgs<ExtArgs>
    commission?: boolean | Conversion$commissionArgs<ExtArgs>
  }
  export type ConversionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    click?: boolean | ClickDefaultArgs<ExtArgs>
    affiliate?: boolean | AffiliateProfileDefaultArgs<ExtArgs>
    offer?: boolean | OfferDefaultArgs<ExtArgs>
  }

  export type $ConversionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conversion"
    objects: {
      click: Prisma.$ClickPayload<ExtArgs>
      affiliate: Prisma.$AffiliateProfilePayload<ExtArgs>
      offer: Prisma.$OfferPayload<ExtArgs>
      commission: Prisma.$CommissionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clickId: string
      affiliateId: string
      offerId: string
      customerEmail: string | null
      customerValue: number
      commissionAmount: number
      status: $Enums.ConversionStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conversion"]>
    composites: {}
  }

  type ConversionGetPayload<S extends boolean | null | undefined | ConversionDefaultArgs> = $Result.GetResult<Prisma.$ConversionPayload, S>

  type ConversionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConversionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConversionCountAggregateInputType | true
    }

  export interface ConversionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conversion'], meta: { name: 'Conversion' } }
    /**
     * Find zero or one Conversion that matches the filter.
     * @param {ConversionFindUniqueArgs} args - Arguments to find a Conversion
     * @example
     * // Get one Conversion
     * const conversion = await prisma.conversion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversionFindUniqueArgs>(args: SelectSubset<T, ConversionFindUniqueArgs<ExtArgs>>): Prisma__ConversionClient<$Result.GetResult<Prisma.$ConversionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Conversion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConversionFindUniqueOrThrowArgs} args - Arguments to find a Conversion
     * @example
     * // Get one Conversion
     * const conversion = await prisma.conversion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversionFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversionClient<$Result.GetResult<Prisma.$ConversionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Conversion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversionFindFirstArgs} args - Arguments to find a Conversion
     * @example
     * // Get one Conversion
     * const conversion = await prisma.conversion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversionFindFirstArgs>(args?: SelectSubset<T, ConversionFindFirstArgs<ExtArgs>>): Prisma__ConversionClient<$Result.GetResult<Prisma.$ConversionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Conversion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversionFindFirstOrThrowArgs} args - Arguments to find a Conversion
     * @example
     * // Get one Conversion
     * const conversion = await prisma.conversion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversionFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversionClient<$Result.GetResult<Prisma.$ConversionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Conversions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversions
     * const conversions = await prisma.conversion.findMany()
     * 
     * // Get first 10 Conversions
     * const conversions = await prisma.conversion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversionWithIdOnly = await prisma.conversion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversionFindManyArgs>(args?: SelectSubset<T, ConversionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Conversion.
     * @param {ConversionCreateArgs} args - Arguments to create a Conversion.
     * @example
     * // Create one Conversion
     * const Conversion = await prisma.conversion.create({
     *   data: {
     *     // ... data to create a Conversion
     *   }
     * })
     * 
     */
    create<T extends ConversionCreateArgs>(args: SelectSubset<T, ConversionCreateArgs<ExtArgs>>): Prisma__ConversionClient<$Result.GetResult<Prisma.$ConversionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Conversions.
     * @param {ConversionCreateManyArgs} args - Arguments to create many Conversions.
     * @example
     * // Create many Conversions
     * const conversion = await prisma.conversion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversionCreateManyArgs>(args?: SelectSubset<T, ConversionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conversions and returns the data saved in the database.
     * @param {ConversionCreateManyAndReturnArgs} args - Arguments to create many Conversions.
     * @example
     * // Create many Conversions
     * const conversion = await prisma.conversion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conversions and only return the `id`
     * const conversionWithIdOnly = await prisma.conversion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversionCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Conversion.
     * @param {ConversionDeleteArgs} args - Arguments to delete one Conversion.
     * @example
     * // Delete one Conversion
     * const Conversion = await prisma.conversion.delete({
     *   where: {
     *     // ... filter to delete one Conversion
     *   }
     * })
     * 
     */
    delete<T extends ConversionDeleteArgs>(args: SelectSubset<T, ConversionDeleteArgs<ExtArgs>>): Prisma__ConversionClient<$Result.GetResult<Prisma.$ConversionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Conversion.
     * @param {ConversionUpdateArgs} args - Arguments to update one Conversion.
     * @example
     * // Update one Conversion
     * const conversion = await prisma.conversion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversionUpdateArgs>(args: SelectSubset<T, ConversionUpdateArgs<ExtArgs>>): Prisma__ConversionClient<$Result.GetResult<Prisma.$ConversionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Conversions.
     * @param {ConversionDeleteManyArgs} args - Arguments to filter Conversions to delete.
     * @example
     * // Delete a few Conversions
     * const { count } = await prisma.conversion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversionDeleteManyArgs>(args?: SelectSubset<T, ConversionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversions
     * const conversion = await prisma.conversion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversionUpdateManyArgs>(args: SelectSubset<T, ConversionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Conversion.
     * @param {ConversionUpsertArgs} args - Arguments to update or create a Conversion.
     * @example
     * // Update or create a Conversion
     * const conversion = await prisma.conversion.upsert({
     *   create: {
     *     // ... data to create a Conversion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversion we want to update
     *   }
     * })
     */
    upsert<T extends ConversionUpsertArgs>(args: SelectSubset<T, ConversionUpsertArgs<ExtArgs>>): Prisma__ConversionClient<$Result.GetResult<Prisma.$ConversionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Conversions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversionCountArgs} args - Arguments to filter Conversions to count.
     * @example
     * // Count the number of Conversions
     * const count = await prisma.conversion.count({
     *   where: {
     *     // ... the filter for the Conversions we want to count
     *   }
     * })
    **/
    count<T extends ConversionCountArgs>(
      args?: Subset<T, ConversionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversionAggregateArgs>(args: Subset<T, ConversionAggregateArgs>): Prisma.PrismaPromise<GetConversionAggregateType<T>>

    /**
     * Group by Conversion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversionGroupByArgs['orderBy'] }
        : { orderBy?: ConversionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conversion model
   */
  readonly fields: ConversionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conversion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    click<T extends ClickDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClickDefaultArgs<ExtArgs>>): Prisma__ClickClient<$Result.GetResult<Prisma.$ClickPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    affiliate<T extends AffiliateProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AffiliateProfileDefaultArgs<ExtArgs>>): Prisma__AffiliateProfileClient<$Result.GetResult<Prisma.$AffiliateProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    offer<T extends OfferDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OfferDefaultArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    commission<T extends Conversion$commissionArgs<ExtArgs> = {}>(args?: Subset<T, Conversion$commissionArgs<ExtArgs>>): Prisma__CommissionClient<$Result.GetResult<Prisma.$CommissionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conversion model
   */ 
  interface ConversionFieldRefs {
    readonly id: FieldRef<"Conversion", 'String'>
    readonly clickId: FieldRef<"Conversion", 'String'>
    readonly affiliateId: FieldRef<"Conversion", 'String'>
    readonly offerId: FieldRef<"Conversion", 'String'>
    readonly customerEmail: FieldRef<"Conversion", 'String'>
    readonly customerValue: FieldRef<"Conversion", 'Float'>
    readonly commissionAmount: FieldRef<"Conversion", 'Float'>
    readonly status: FieldRef<"Conversion", 'ConversionStatus'>
    readonly createdAt: FieldRef<"Conversion", 'DateTime'>
    readonly updatedAt: FieldRef<"Conversion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Conversion findUnique
   */
  export type ConversionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversion
     */
    select?: ConversionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversionInclude<ExtArgs> | null
    /**
     * Filter, which Conversion to fetch.
     */
    where: ConversionWhereUniqueInput
  }

  /**
   * Conversion findUniqueOrThrow
   */
  export type ConversionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversion
     */
    select?: ConversionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversionInclude<ExtArgs> | null
    /**
     * Filter, which Conversion to fetch.
     */
    where: ConversionWhereUniqueInput
  }

  /**
   * Conversion findFirst
   */
  export type ConversionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversion
     */
    select?: ConversionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversionInclude<ExtArgs> | null
    /**
     * Filter, which Conversion to fetch.
     */
    where?: ConversionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversions to fetch.
     */
    orderBy?: ConversionOrderByWithRelationInput | ConversionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversions.
     */
    cursor?: ConversionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversions.
     */
    distinct?: ConversionScalarFieldEnum | ConversionScalarFieldEnum[]
  }

  /**
   * Conversion findFirstOrThrow
   */
  export type ConversionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversion
     */
    select?: ConversionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversionInclude<ExtArgs> | null
    /**
     * Filter, which Conversion to fetch.
     */
    where?: ConversionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversions to fetch.
     */
    orderBy?: ConversionOrderByWithRelationInput | ConversionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversions.
     */
    cursor?: ConversionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversions.
     */
    distinct?: ConversionScalarFieldEnum | ConversionScalarFieldEnum[]
  }

  /**
   * Conversion findMany
   */
  export type ConversionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversion
     */
    select?: ConversionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversionInclude<ExtArgs> | null
    /**
     * Filter, which Conversions to fetch.
     */
    where?: ConversionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversions to fetch.
     */
    orderBy?: ConversionOrderByWithRelationInput | ConversionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conversions.
     */
    cursor?: ConversionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversions.
     */
    skip?: number
    distinct?: ConversionScalarFieldEnum | ConversionScalarFieldEnum[]
  }

  /**
   * Conversion create
   */
  export type ConversionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversion
     */
    select?: ConversionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversionInclude<ExtArgs> | null
    /**
     * The data needed to create a Conversion.
     */
    data: XOR<ConversionCreateInput, ConversionUncheckedCreateInput>
  }

  /**
   * Conversion createMany
   */
  export type ConversionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conversions.
     */
    data: ConversionCreateManyInput | ConversionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conversion createManyAndReturn
   */
  export type ConversionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversion
     */
    select?: ConversionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Conversions.
     */
    data: ConversionCreateManyInput | ConversionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversion update
   */
  export type ConversionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversion
     */
    select?: ConversionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversionInclude<ExtArgs> | null
    /**
     * The data needed to update a Conversion.
     */
    data: XOR<ConversionUpdateInput, ConversionUncheckedUpdateInput>
    /**
     * Choose, which Conversion to update.
     */
    where: ConversionWhereUniqueInput
  }

  /**
   * Conversion updateMany
   */
  export type ConversionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conversions.
     */
    data: XOR<ConversionUpdateManyMutationInput, ConversionUncheckedUpdateManyInput>
    /**
     * Filter which Conversions to update
     */
    where?: ConversionWhereInput
  }

  /**
   * Conversion upsert
   */
  export type ConversionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversion
     */
    select?: ConversionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversionInclude<ExtArgs> | null
    /**
     * The filter to search for the Conversion to update in case it exists.
     */
    where: ConversionWhereUniqueInput
    /**
     * In case the Conversion found by the `where` argument doesn't exist, create a new Conversion with this data.
     */
    create: XOR<ConversionCreateInput, ConversionUncheckedCreateInput>
    /**
     * In case the Conversion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversionUpdateInput, ConversionUncheckedUpdateInput>
  }

  /**
   * Conversion delete
   */
  export type ConversionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversion
     */
    select?: ConversionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversionInclude<ExtArgs> | null
    /**
     * Filter which Conversion to delete.
     */
    where: ConversionWhereUniqueInput
  }

  /**
   * Conversion deleteMany
   */
  export type ConversionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversions to delete
     */
    where?: ConversionWhereInput
  }

  /**
   * Conversion.commission
   */
  export type Conversion$commissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commission
     */
    select?: CommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionInclude<ExtArgs> | null
    where?: CommissionWhereInput
  }

  /**
   * Conversion without action
   */
  export type ConversionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversion
     */
    select?: ConversionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversionInclude<ExtArgs> | null
  }


  /**
   * Model Commission
   */

  export type AggregateCommission = {
    _count: CommissionCountAggregateOutputType | null
    _avg: CommissionAvgAggregateOutputType | null
    _sum: CommissionSumAggregateOutputType | null
    _min: CommissionMinAggregateOutputType | null
    _max: CommissionMaxAggregateOutputType | null
  }

  export type CommissionAvgAggregateOutputType = {
    amount: number | null
    rate: number | null
  }

  export type CommissionSumAggregateOutputType = {
    amount: number | null
    rate: number | null
  }

  export type CommissionMinAggregateOutputType = {
    id: string | null
    conversionId: string | null
    affiliateId: string | null
    payoutId: string | null
    amount: number | null
    rate: number | null
    status: $Enums.CommissionStatus | null
    payoutDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommissionMaxAggregateOutputType = {
    id: string | null
    conversionId: string | null
    affiliateId: string | null
    payoutId: string | null
    amount: number | null
    rate: number | null
    status: $Enums.CommissionStatus | null
    payoutDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommissionCountAggregateOutputType = {
    id: number
    conversionId: number
    affiliateId: number
    payoutId: number
    amount: number
    rate: number
    status: number
    payoutDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommissionAvgAggregateInputType = {
    amount?: true
    rate?: true
  }

  export type CommissionSumAggregateInputType = {
    amount?: true
    rate?: true
  }

  export type CommissionMinAggregateInputType = {
    id?: true
    conversionId?: true
    affiliateId?: true
    payoutId?: true
    amount?: true
    rate?: true
    status?: true
    payoutDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommissionMaxAggregateInputType = {
    id?: true
    conversionId?: true
    affiliateId?: true
    payoutId?: true
    amount?: true
    rate?: true
    status?: true
    payoutDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommissionCountAggregateInputType = {
    id?: true
    conversionId?: true
    affiliateId?: true
    payoutId?: true
    amount?: true
    rate?: true
    status?: true
    payoutDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Commission to aggregate.
     */
    where?: CommissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commissions to fetch.
     */
    orderBy?: CommissionOrderByWithRelationInput | CommissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Commissions
    **/
    _count?: true | CommissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommissionMaxAggregateInputType
  }

  export type GetCommissionAggregateType<T extends CommissionAggregateArgs> = {
        [P in keyof T & keyof AggregateCommission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommission[P]>
      : GetScalarType<T[P], AggregateCommission[P]>
  }




  export type CommissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommissionWhereInput
    orderBy?: CommissionOrderByWithAggregationInput | CommissionOrderByWithAggregationInput[]
    by: CommissionScalarFieldEnum[] | CommissionScalarFieldEnum
    having?: CommissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommissionCountAggregateInputType | true
    _avg?: CommissionAvgAggregateInputType
    _sum?: CommissionSumAggregateInputType
    _min?: CommissionMinAggregateInputType
    _max?: CommissionMaxAggregateInputType
  }

  export type CommissionGroupByOutputType = {
    id: string
    conversionId: string
    affiliateId: string
    payoutId: string | null
    amount: number
    rate: number
    status: $Enums.CommissionStatus
    payoutDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: CommissionCountAggregateOutputType | null
    _avg: CommissionAvgAggregateOutputType | null
    _sum: CommissionSumAggregateOutputType | null
    _min: CommissionMinAggregateOutputType | null
    _max: CommissionMaxAggregateOutputType | null
  }

  type GetCommissionGroupByPayload<T extends CommissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommissionGroupByOutputType[P]>
            : GetScalarType<T[P], CommissionGroupByOutputType[P]>
        }
      >
    >


  export type CommissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversionId?: boolean
    affiliateId?: boolean
    payoutId?: boolean
    amount?: boolean
    rate?: boolean
    status?: boolean
    payoutDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conversion?: boolean | ConversionDefaultArgs<ExtArgs>
    affiliate?: boolean | AffiliateProfileDefaultArgs<ExtArgs>
    payout?: boolean | Commission$payoutArgs<ExtArgs>
  }, ExtArgs["result"]["commission"]>

  export type CommissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversionId?: boolean
    affiliateId?: boolean
    payoutId?: boolean
    amount?: boolean
    rate?: boolean
    status?: boolean
    payoutDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conversion?: boolean | ConversionDefaultArgs<ExtArgs>
    affiliate?: boolean | AffiliateProfileDefaultArgs<ExtArgs>
    payout?: boolean | Commission$payoutArgs<ExtArgs>
  }, ExtArgs["result"]["commission"]>

  export type CommissionSelectScalar = {
    id?: boolean
    conversionId?: boolean
    affiliateId?: boolean
    payoutId?: boolean
    amount?: boolean
    rate?: boolean
    status?: boolean
    payoutDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversion?: boolean | ConversionDefaultArgs<ExtArgs>
    affiliate?: boolean | AffiliateProfileDefaultArgs<ExtArgs>
    payout?: boolean | Commission$payoutArgs<ExtArgs>
  }
  export type CommissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversion?: boolean | ConversionDefaultArgs<ExtArgs>
    affiliate?: boolean | AffiliateProfileDefaultArgs<ExtArgs>
    payout?: boolean | Commission$payoutArgs<ExtArgs>
  }

  export type $CommissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Commission"
    objects: {
      conversion: Prisma.$ConversionPayload<ExtArgs>
      affiliate: Prisma.$AffiliateProfilePayload<ExtArgs>
      payout: Prisma.$PayoutPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversionId: string
      affiliateId: string
      payoutId: string | null
      amount: number
      rate: number
      status: $Enums.CommissionStatus
      payoutDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["commission"]>
    composites: {}
  }

  type CommissionGetPayload<S extends boolean | null | undefined | CommissionDefaultArgs> = $Result.GetResult<Prisma.$CommissionPayload, S>

  type CommissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommissionCountAggregateInputType | true
    }

  export interface CommissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Commission'], meta: { name: 'Commission' } }
    /**
     * Find zero or one Commission that matches the filter.
     * @param {CommissionFindUniqueArgs} args - Arguments to find a Commission
     * @example
     * // Get one Commission
     * const commission = await prisma.commission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommissionFindUniqueArgs>(args: SelectSubset<T, CommissionFindUniqueArgs<ExtArgs>>): Prisma__CommissionClient<$Result.GetResult<Prisma.$CommissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Commission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommissionFindUniqueOrThrowArgs} args - Arguments to find a Commission
     * @example
     * // Get one Commission
     * const commission = await prisma.commission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommissionFindUniqueOrThrowArgs>(args: SelectSubset<T, CommissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommissionClient<$Result.GetResult<Prisma.$CommissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Commission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionFindFirstArgs} args - Arguments to find a Commission
     * @example
     * // Get one Commission
     * const commission = await prisma.commission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommissionFindFirstArgs>(args?: SelectSubset<T, CommissionFindFirstArgs<ExtArgs>>): Prisma__CommissionClient<$Result.GetResult<Prisma.$CommissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Commission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionFindFirstOrThrowArgs} args - Arguments to find a Commission
     * @example
     * // Get one Commission
     * const commission = await prisma.commission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommissionFindFirstOrThrowArgs>(args?: SelectSubset<T, CommissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommissionClient<$Result.GetResult<Prisma.$CommissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Commissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Commissions
     * const commissions = await prisma.commission.findMany()
     * 
     * // Get first 10 Commissions
     * const commissions = await prisma.commission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commissionWithIdOnly = await prisma.commission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommissionFindManyArgs>(args?: SelectSubset<T, CommissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Commission.
     * @param {CommissionCreateArgs} args - Arguments to create a Commission.
     * @example
     * // Create one Commission
     * const Commission = await prisma.commission.create({
     *   data: {
     *     // ... data to create a Commission
     *   }
     * })
     * 
     */
    create<T extends CommissionCreateArgs>(args: SelectSubset<T, CommissionCreateArgs<ExtArgs>>): Prisma__CommissionClient<$Result.GetResult<Prisma.$CommissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Commissions.
     * @param {CommissionCreateManyArgs} args - Arguments to create many Commissions.
     * @example
     * // Create many Commissions
     * const commission = await prisma.commission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommissionCreateManyArgs>(args?: SelectSubset<T, CommissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Commissions and returns the data saved in the database.
     * @param {CommissionCreateManyAndReturnArgs} args - Arguments to create many Commissions.
     * @example
     * // Create many Commissions
     * const commission = await prisma.commission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Commissions and only return the `id`
     * const commissionWithIdOnly = await prisma.commission.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommissionCreateManyAndReturnArgs>(args?: SelectSubset<T, CommissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommissionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Commission.
     * @param {CommissionDeleteArgs} args - Arguments to delete one Commission.
     * @example
     * // Delete one Commission
     * const Commission = await prisma.commission.delete({
     *   where: {
     *     // ... filter to delete one Commission
     *   }
     * })
     * 
     */
    delete<T extends CommissionDeleteArgs>(args: SelectSubset<T, CommissionDeleteArgs<ExtArgs>>): Prisma__CommissionClient<$Result.GetResult<Prisma.$CommissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Commission.
     * @param {CommissionUpdateArgs} args - Arguments to update one Commission.
     * @example
     * // Update one Commission
     * const commission = await prisma.commission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommissionUpdateArgs>(args: SelectSubset<T, CommissionUpdateArgs<ExtArgs>>): Prisma__CommissionClient<$Result.GetResult<Prisma.$CommissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Commissions.
     * @param {CommissionDeleteManyArgs} args - Arguments to filter Commissions to delete.
     * @example
     * // Delete a few Commissions
     * const { count } = await prisma.commission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommissionDeleteManyArgs>(args?: SelectSubset<T, CommissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Commissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Commissions
     * const commission = await prisma.commission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommissionUpdateManyArgs>(args: SelectSubset<T, CommissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Commission.
     * @param {CommissionUpsertArgs} args - Arguments to update or create a Commission.
     * @example
     * // Update or create a Commission
     * const commission = await prisma.commission.upsert({
     *   create: {
     *     // ... data to create a Commission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Commission we want to update
     *   }
     * })
     */
    upsert<T extends CommissionUpsertArgs>(args: SelectSubset<T, CommissionUpsertArgs<ExtArgs>>): Prisma__CommissionClient<$Result.GetResult<Prisma.$CommissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Commissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionCountArgs} args - Arguments to filter Commissions to count.
     * @example
     * // Count the number of Commissions
     * const count = await prisma.commission.count({
     *   where: {
     *     // ... the filter for the Commissions we want to count
     *   }
     * })
    **/
    count<T extends CommissionCountArgs>(
      args?: Subset<T, CommissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Commission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommissionAggregateArgs>(args: Subset<T, CommissionAggregateArgs>): Prisma.PrismaPromise<GetCommissionAggregateType<T>>

    /**
     * Group by Commission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommissionGroupByArgs['orderBy'] }
        : { orderBy?: CommissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Commission model
   */
  readonly fields: CommissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Commission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversion<T extends ConversionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversionDefaultArgs<ExtArgs>>): Prisma__ConversionClient<$Result.GetResult<Prisma.$ConversionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    affiliate<T extends AffiliateProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AffiliateProfileDefaultArgs<ExtArgs>>): Prisma__AffiliateProfileClient<$Result.GetResult<Prisma.$AffiliateProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    payout<T extends Commission$payoutArgs<ExtArgs> = {}>(args?: Subset<T, Commission$payoutArgs<ExtArgs>>): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Commission model
   */ 
  interface CommissionFieldRefs {
    readonly id: FieldRef<"Commission", 'String'>
    readonly conversionId: FieldRef<"Commission", 'String'>
    readonly affiliateId: FieldRef<"Commission", 'String'>
    readonly payoutId: FieldRef<"Commission", 'String'>
    readonly amount: FieldRef<"Commission", 'Float'>
    readonly rate: FieldRef<"Commission", 'Float'>
    readonly status: FieldRef<"Commission", 'CommissionStatus'>
    readonly payoutDate: FieldRef<"Commission", 'DateTime'>
    readonly createdAt: FieldRef<"Commission", 'DateTime'>
    readonly updatedAt: FieldRef<"Commission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Commission findUnique
   */
  export type CommissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commission
     */
    select?: CommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionInclude<ExtArgs> | null
    /**
     * Filter, which Commission to fetch.
     */
    where: CommissionWhereUniqueInput
  }

  /**
   * Commission findUniqueOrThrow
   */
  export type CommissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commission
     */
    select?: CommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionInclude<ExtArgs> | null
    /**
     * Filter, which Commission to fetch.
     */
    where: CommissionWhereUniqueInput
  }

  /**
   * Commission findFirst
   */
  export type CommissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commission
     */
    select?: CommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionInclude<ExtArgs> | null
    /**
     * Filter, which Commission to fetch.
     */
    where?: CommissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commissions to fetch.
     */
    orderBy?: CommissionOrderByWithRelationInput | CommissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Commissions.
     */
    cursor?: CommissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Commissions.
     */
    distinct?: CommissionScalarFieldEnum | CommissionScalarFieldEnum[]
  }

  /**
   * Commission findFirstOrThrow
   */
  export type CommissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commission
     */
    select?: CommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionInclude<ExtArgs> | null
    /**
     * Filter, which Commission to fetch.
     */
    where?: CommissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commissions to fetch.
     */
    orderBy?: CommissionOrderByWithRelationInput | CommissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Commissions.
     */
    cursor?: CommissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Commissions.
     */
    distinct?: CommissionScalarFieldEnum | CommissionScalarFieldEnum[]
  }

  /**
   * Commission findMany
   */
  export type CommissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commission
     */
    select?: CommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionInclude<ExtArgs> | null
    /**
     * Filter, which Commissions to fetch.
     */
    where?: CommissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commissions to fetch.
     */
    orderBy?: CommissionOrderByWithRelationInput | CommissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Commissions.
     */
    cursor?: CommissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commissions.
     */
    skip?: number
    distinct?: CommissionScalarFieldEnum | CommissionScalarFieldEnum[]
  }

  /**
   * Commission create
   */
  export type CommissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commission
     */
    select?: CommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Commission.
     */
    data: XOR<CommissionCreateInput, CommissionUncheckedCreateInput>
  }

  /**
   * Commission createMany
   */
  export type CommissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Commissions.
     */
    data: CommissionCreateManyInput | CommissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Commission createManyAndReturn
   */
  export type CommissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commission
     */
    select?: CommissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Commissions.
     */
    data: CommissionCreateManyInput | CommissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Commission update
   */
  export type CommissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commission
     */
    select?: CommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Commission.
     */
    data: XOR<CommissionUpdateInput, CommissionUncheckedUpdateInput>
    /**
     * Choose, which Commission to update.
     */
    where: CommissionWhereUniqueInput
  }

  /**
   * Commission updateMany
   */
  export type CommissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Commissions.
     */
    data: XOR<CommissionUpdateManyMutationInput, CommissionUncheckedUpdateManyInput>
    /**
     * Filter which Commissions to update
     */
    where?: CommissionWhereInput
  }

  /**
   * Commission upsert
   */
  export type CommissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commission
     */
    select?: CommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Commission to update in case it exists.
     */
    where: CommissionWhereUniqueInput
    /**
     * In case the Commission found by the `where` argument doesn't exist, create a new Commission with this data.
     */
    create: XOR<CommissionCreateInput, CommissionUncheckedCreateInput>
    /**
     * In case the Commission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommissionUpdateInput, CommissionUncheckedUpdateInput>
  }

  /**
   * Commission delete
   */
  export type CommissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commission
     */
    select?: CommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionInclude<ExtArgs> | null
    /**
     * Filter which Commission to delete.
     */
    where: CommissionWhereUniqueInput
  }

  /**
   * Commission deleteMany
   */
  export type CommissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Commissions to delete
     */
    where?: CommissionWhereInput
  }

  /**
   * Commission.payout
   */
  export type Commission$payoutArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutInclude<ExtArgs> | null
    where?: PayoutWhereInput
  }

  /**
   * Commission without action
   */
  export type CommissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commission
     */
    select?: CommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionInclude<ExtArgs> | null
  }


  /**
   * Model Payout
   */

  export type AggregatePayout = {
    _count: PayoutCountAggregateOutputType | null
    _avg: PayoutAvgAggregateOutputType | null
    _sum: PayoutSumAggregateOutputType | null
    _min: PayoutMinAggregateOutputType | null
    _max: PayoutMaxAggregateOutputType | null
  }

  export type PayoutAvgAggregateOutputType = {
    amount: number | null
  }

  export type PayoutSumAggregateOutputType = {
    amount: number | null
  }

  export type PayoutMinAggregateOutputType = {
    id: string | null
    affiliateId: string | null
    amount: number | null
    method: $Enums.PaymentMethod | null
    status: $Enums.PayoutStatus | null
    referenceId: string | null
    processedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayoutMaxAggregateOutputType = {
    id: string | null
    affiliateId: string | null
    amount: number | null
    method: $Enums.PaymentMethod | null
    status: $Enums.PayoutStatus | null
    referenceId: string | null
    processedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayoutCountAggregateOutputType = {
    id: number
    affiliateId: number
    amount: number
    method: number
    status: number
    referenceId: number
    processedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PayoutAvgAggregateInputType = {
    amount?: true
  }

  export type PayoutSumAggregateInputType = {
    amount?: true
  }

  export type PayoutMinAggregateInputType = {
    id?: true
    affiliateId?: true
    amount?: true
    method?: true
    status?: true
    referenceId?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayoutMaxAggregateInputType = {
    id?: true
    affiliateId?: true
    amount?: true
    method?: true
    status?: true
    referenceId?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayoutCountAggregateInputType = {
    id?: true
    affiliateId?: true
    amount?: true
    method?: true
    status?: true
    referenceId?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PayoutAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payout to aggregate.
     */
    where?: PayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payouts to fetch.
     */
    orderBy?: PayoutOrderByWithRelationInput | PayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payouts
    **/
    _count?: true | PayoutCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PayoutAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PayoutSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PayoutMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PayoutMaxAggregateInputType
  }

  export type GetPayoutAggregateType<T extends PayoutAggregateArgs> = {
        [P in keyof T & keyof AggregatePayout]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayout[P]>
      : GetScalarType<T[P], AggregatePayout[P]>
  }




  export type PayoutGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayoutWhereInput
    orderBy?: PayoutOrderByWithAggregationInput | PayoutOrderByWithAggregationInput[]
    by: PayoutScalarFieldEnum[] | PayoutScalarFieldEnum
    having?: PayoutScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PayoutCountAggregateInputType | true
    _avg?: PayoutAvgAggregateInputType
    _sum?: PayoutSumAggregateInputType
    _min?: PayoutMinAggregateInputType
    _max?: PayoutMaxAggregateInputType
  }

  export type PayoutGroupByOutputType = {
    id: string
    affiliateId: string
    amount: number
    method: $Enums.PaymentMethod
    status: $Enums.PayoutStatus
    referenceId: string | null
    processedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PayoutCountAggregateOutputType | null
    _avg: PayoutAvgAggregateOutputType | null
    _sum: PayoutSumAggregateOutputType | null
    _min: PayoutMinAggregateOutputType | null
    _max: PayoutMaxAggregateOutputType | null
  }

  type GetPayoutGroupByPayload<T extends PayoutGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PayoutGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PayoutGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PayoutGroupByOutputType[P]>
            : GetScalarType<T[P], PayoutGroupByOutputType[P]>
        }
      >
    >


  export type PayoutSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    affiliateId?: boolean
    amount?: boolean
    method?: boolean
    status?: boolean
    referenceId?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    affiliate?: boolean | AffiliateProfileDefaultArgs<ExtArgs>
    commissions?: boolean | Payout$commissionsArgs<ExtArgs>
    _count?: boolean | PayoutCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payout"]>

  export type PayoutSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    affiliateId?: boolean
    amount?: boolean
    method?: boolean
    status?: boolean
    referenceId?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    affiliate?: boolean | AffiliateProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payout"]>

  export type PayoutSelectScalar = {
    id?: boolean
    affiliateId?: boolean
    amount?: boolean
    method?: boolean
    status?: boolean
    referenceId?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PayoutInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliate?: boolean | AffiliateProfileDefaultArgs<ExtArgs>
    commissions?: boolean | Payout$commissionsArgs<ExtArgs>
    _count?: boolean | PayoutCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PayoutIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliate?: boolean | AffiliateProfileDefaultArgs<ExtArgs>
  }

  export type $PayoutPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payout"
    objects: {
      affiliate: Prisma.$AffiliateProfilePayload<ExtArgs>
      commissions: Prisma.$CommissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      affiliateId: string
      amount: number
      method: $Enums.PaymentMethod
      status: $Enums.PayoutStatus
      referenceId: string | null
      processedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payout"]>
    composites: {}
  }

  type PayoutGetPayload<S extends boolean | null | undefined | PayoutDefaultArgs> = $Result.GetResult<Prisma.$PayoutPayload, S>

  type PayoutCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PayoutFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PayoutCountAggregateInputType | true
    }

  export interface PayoutDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payout'], meta: { name: 'Payout' } }
    /**
     * Find zero or one Payout that matches the filter.
     * @param {PayoutFindUniqueArgs} args - Arguments to find a Payout
     * @example
     * // Get one Payout
     * const payout = await prisma.payout.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PayoutFindUniqueArgs>(args: SelectSubset<T, PayoutFindUniqueArgs<ExtArgs>>): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payout that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PayoutFindUniqueOrThrowArgs} args - Arguments to find a Payout
     * @example
     * // Get one Payout
     * const payout = await prisma.payout.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PayoutFindUniqueOrThrowArgs>(args: SelectSubset<T, PayoutFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payout that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutFindFirstArgs} args - Arguments to find a Payout
     * @example
     * // Get one Payout
     * const payout = await prisma.payout.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PayoutFindFirstArgs>(args?: SelectSubset<T, PayoutFindFirstArgs<ExtArgs>>): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payout that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutFindFirstOrThrowArgs} args - Arguments to find a Payout
     * @example
     * // Get one Payout
     * const payout = await prisma.payout.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PayoutFindFirstOrThrowArgs>(args?: SelectSubset<T, PayoutFindFirstOrThrowArgs<ExtArgs>>): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payouts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payouts
     * const payouts = await prisma.payout.findMany()
     * 
     * // Get first 10 Payouts
     * const payouts = await prisma.payout.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payoutWithIdOnly = await prisma.payout.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PayoutFindManyArgs>(args?: SelectSubset<T, PayoutFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payout.
     * @param {PayoutCreateArgs} args - Arguments to create a Payout.
     * @example
     * // Create one Payout
     * const Payout = await prisma.payout.create({
     *   data: {
     *     // ... data to create a Payout
     *   }
     * })
     * 
     */
    create<T extends PayoutCreateArgs>(args: SelectSubset<T, PayoutCreateArgs<ExtArgs>>): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payouts.
     * @param {PayoutCreateManyArgs} args - Arguments to create many Payouts.
     * @example
     * // Create many Payouts
     * const payout = await prisma.payout.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PayoutCreateManyArgs>(args?: SelectSubset<T, PayoutCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payouts and returns the data saved in the database.
     * @param {PayoutCreateManyAndReturnArgs} args - Arguments to create many Payouts.
     * @example
     * // Create many Payouts
     * const payout = await prisma.payout.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payouts and only return the `id`
     * const payoutWithIdOnly = await prisma.payout.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PayoutCreateManyAndReturnArgs>(args?: SelectSubset<T, PayoutCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payout.
     * @param {PayoutDeleteArgs} args - Arguments to delete one Payout.
     * @example
     * // Delete one Payout
     * const Payout = await prisma.payout.delete({
     *   where: {
     *     // ... filter to delete one Payout
     *   }
     * })
     * 
     */
    delete<T extends PayoutDeleteArgs>(args: SelectSubset<T, PayoutDeleteArgs<ExtArgs>>): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payout.
     * @param {PayoutUpdateArgs} args - Arguments to update one Payout.
     * @example
     * // Update one Payout
     * const payout = await prisma.payout.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PayoutUpdateArgs>(args: SelectSubset<T, PayoutUpdateArgs<ExtArgs>>): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payouts.
     * @param {PayoutDeleteManyArgs} args - Arguments to filter Payouts to delete.
     * @example
     * // Delete a few Payouts
     * const { count } = await prisma.payout.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PayoutDeleteManyArgs>(args?: SelectSubset<T, PayoutDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payouts
     * const payout = await prisma.payout.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PayoutUpdateManyArgs>(args: SelectSubset<T, PayoutUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payout.
     * @param {PayoutUpsertArgs} args - Arguments to update or create a Payout.
     * @example
     * // Update or create a Payout
     * const payout = await prisma.payout.upsert({
     *   create: {
     *     // ... data to create a Payout
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payout we want to update
     *   }
     * })
     */
    upsert<T extends PayoutUpsertArgs>(args: SelectSubset<T, PayoutUpsertArgs<ExtArgs>>): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutCountArgs} args - Arguments to filter Payouts to count.
     * @example
     * // Count the number of Payouts
     * const count = await prisma.payout.count({
     *   where: {
     *     // ... the filter for the Payouts we want to count
     *   }
     * })
    **/
    count<T extends PayoutCountArgs>(
      args?: Subset<T, PayoutCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PayoutCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PayoutAggregateArgs>(args: Subset<T, PayoutAggregateArgs>): Prisma.PrismaPromise<GetPayoutAggregateType<T>>

    /**
     * Group by Payout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PayoutGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PayoutGroupByArgs['orderBy'] }
        : { orderBy?: PayoutGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PayoutGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayoutGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payout model
   */
  readonly fields: PayoutFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payout.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PayoutClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    affiliate<T extends AffiliateProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AffiliateProfileDefaultArgs<ExtArgs>>): Prisma__AffiliateProfileClient<$Result.GetResult<Prisma.$AffiliateProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    commissions<T extends Payout$commissionsArgs<ExtArgs> = {}>(args?: Subset<T, Payout$commissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommissionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payout model
   */ 
  interface PayoutFieldRefs {
    readonly id: FieldRef<"Payout", 'String'>
    readonly affiliateId: FieldRef<"Payout", 'String'>
    readonly amount: FieldRef<"Payout", 'Float'>
    readonly method: FieldRef<"Payout", 'PaymentMethod'>
    readonly status: FieldRef<"Payout", 'PayoutStatus'>
    readonly referenceId: FieldRef<"Payout", 'String'>
    readonly processedAt: FieldRef<"Payout", 'DateTime'>
    readonly createdAt: FieldRef<"Payout", 'DateTime'>
    readonly updatedAt: FieldRef<"Payout", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payout findUnique
   */
  export type PayoutFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutInclude<ExtArgs> | null
    /**
     * Filter, which Payout to fetch.
     */
    where: PayoutWhereUniqueInput
  }

  /**
   * Payout findUniqueOrThrow
   */
  export type PayoutFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutInclude<ExtArgs> | null
    /**
     * Filter, which Payout to fetch.
     */
    where: PayoutWhereUniqueInput
  }

  /**
   * Payout findFirst
   */
  export type PayoutFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutInclude<ExtArgs> | null
    /**
     * Filter, which Payout to fetch.
     */
    where?: PayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payouts to fetch.
     */
    orderBy?: PayoutOrderByWithRelationInput | PayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payouts.
     */
    cursor?: PayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payouts.
     */
    distinct?: PayoutScalarFieldEnum | PayoutScalarFieldEnum[]
  }

  /**
   * Payout findFirstOrThrow
   */
  export type PayoutFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutInclude<ExtArgs> | null
    /**
     * Filter, which Payout to fetch.
     */
    where?: PayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payouts to fetch.
     */
    orderBy?: PayoutOrderByWithRelationInput | PayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payouts.
     */
    cursor?: PayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payouts.
     */
    distinct?: PayoutScalarFieldEnum | PayoutScalarFieldEnum[]
  }

  /**
   * Payout findMany
   */
  export type PayoutFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutInclude<ExtArgs> | null
    /**
     * Filter, which Payouts to fetch.
     */
    where?: PayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payouts to fetch.
     */
    orderBy?: PayoutOrderByWithRelationInput | PayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payouts.
     */
    cursor?: PayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payouts.
     */
    skip?: number
    distinct?: PayoutScalarFieldEnum | PayoutScalarFieldEnum[]
  }

  /**
   * Payout create
   */
  export type PayoutCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutInclude<ExtArgs> | null
    /**
     * The data needed to create a Payout.
     */
    data: XOR<PayoutCreateInput, PayoutUncheckedCreateInput>
  }

  /**
   * Payout createMany
   */
  export type PayoutCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payouts.
     */
    data: PayoutCreateManyInput | PayoutCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payout createManyAndReturn
   */
  export type PayoutCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Payouts.
     */
    data: PayoutCreateManyInput | PayoutCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payout update
   */
  export type PayoutUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutInclude<ExtArgs> | null
    /**
     * The data needed to update a Payout.
     */
    data: XOR<PayoutUpdateInput, PayoutUncheckedUpdateInput>
    /**
     * Choose, which Payout to update.
     */
    where: PayoutWhereUniqueInput
  }

  /**
   * Payout updateMany
   */
  export type PayoutUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payouts.
     */
    data: XOR<PayoutUpdateManyMutationInput, PayoutUncheckedUpdateManyInput>
    /**
     * Filter which Payouts to update
     */
    where?: PayoutWhereInput
  }

  /**
   * Payout upsert
   */
  export type PayoutUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutInclude<ExtArgs> | null
    /**
     * The filter to search for the Payout to update in case it exists.
     */
    where: PayoutWhereUniqueInput
    /**
     * In case the Payout found by the `where` argument doesn't exist, create a new Payout with this data.
     */
    create: XOR<PayoutCreateInput, PayoutUncheckedCreateInput>
    /**
     * In case the Payout was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PayoutUpdateInput, PayoutUncheckedUpdateInput>
  }

  /**
   * Payout delete
   */
  export type PayoutDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutInclude<ExtArgs> | null
    /**
     * Filter which Payout to delete.
     */
    where: PayoutWhereUniqueInput
  }

  /**
   * Payout deleteMany
   */
  export type PayoutDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payouts to delete
     */
    where?: PayoutWhereInput
  }

  /**
   * Payout.commissions
   */
  export type Payout$commissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commission
     */
    select?: CommissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionInclude<ExtArgs> | null
    where?: CommissionWhereInput
    orderBy?: CommissionOrderByWithRelationInput | CommissionOrderByWithRelationInput[]
    cursor?: CommissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommissionScalarFieldEnum | CommissionScalarFieldEnum[]
  }

  /**
   * Payout without action
   */
  export type PayoutDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutInclude<ExtArgs> | null
  }


  /**
   * Model Creative
   */

  export type AggregateCreative = {
    _count: CreativeCountAggregateOutputType | null
    _min: CreativeMinAggregateOutputType | null
    _max: CreativeMaxAggregateOutputType | null
  }

  export type CreativeMinAggregateOutputType = {
    id: string | null
    offerId: string | null
    name: string | null
    type: $Enums.CreativeType | null
    size: string | null
    format: string | null
    url: string | null
    downloadUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CreativeMaxAggregateOutputType = {
    id: string | null
    offerId: string | null
    name: string | null
    type: $Enums.CreativeType | null
    size: string | null
    format: string | null
    url: string | null
    downloadUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CreativeCountAggregateOutputType = {
    id: number
    offerId: number
    name: number
    type: number
    size: number
    format: number
    url: number
    downloadUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CreativeMinAggregateInputType = {
    id?: true
    offerId?: true
    name?: true
    type?: true
    size?: true
    format?: true
    url?: true
    downloadUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CreativeMaxAggregateInputType = {
    id?: true
    offerId?: true
    name?: true
    type?: true
    size?: true
    format?: true
    url?: true
    downloadUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CreativeCountAggregateInputType = {
    id?: true
    offerId?: true
    name?: true
    type?: true
    size?: true
    format?: true
    url?: true
    downloadUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CreativeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Creative to aggregate.
     */
    where?: CreativeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creatives to fetch.
     */
    orderBy?: CreativeOrderByWithRelationInput | CreativeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreativeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creatives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creatives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Creatives
    **/
    _count?: true | CreativeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreativeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreativeMaxAggregateInputType
  }

  export type GetCreativeAggregateType<T extends CreativeAggregateArgs> = {
        [P in keyof T & keyof AggregateCreative]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreative[P]>
      : GetScalarType<T[P], AggregateCreative[P]>
  }




  export type CreativeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreativeWhereInput
    orderBy?: CreativeOrderByWithAggregationInput | CreativeOrderByWithAggregationInput[]
    by: CreativeScalarFieldEnum[] | CreativeScalarFieldEnum
    having?: CreativeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreativeCountAggregateInputType | true
    _min?: CreativeMinAggregateInputType
    _max?: CreativeMaxAggregateInputType
  }

  export type CreativeGroupByOutputType = {
    id: string
    offerId: string
    name: string
    type: $Enums.CreativeType
    size: string
    format: string
    url: string
    downloadUrl: string
    createdAt: Date
    updatedAt: Date
    _count: CreativeCountAggregateOutputType | null
    _min: CreativeMinAggregateOutputType | null
    _max: CreativeMaxAggregateOutputType | null
  }

  type GetCreativeGroupByPayload<T extends CreativeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreativeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreativeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreativeGroupByOutputType[P]>
            : GetScalarType<T[P], CreativeGroupByOutputType[P]>
        }
      >
    >


  export type CreativeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    offerId?: boolean
    name?: boolean
    type?: boolean
    size?: boolean
    format?: boolean
    url?: boolean
    downloadUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    offer?: boolean | OfferDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creative"]>

  export type CreativeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    offerId?: boolean
    name?: boolean
    type?: boolean
    size?: boolean
    format?: boolean
    url?: boolean
    downloadUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    offer?: boolean | OfferDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creative"]>

  export type CreativeSelectScalar = {
    id?: boolean
    offerId?: boolean
    name?: boolean
    type?: boolean
    size?: boolean
    format?: boolean
    url?: boolean
    downloadUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CreativeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offer?: boolean | OfferDefaultArgs<ExtArgs>
  }
  export type CreativeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offer?: boolean | OfferDefaultArgs<ExtArgs>
  }

  export type $CreativePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Creative"
    objects: {
      offer: Prisma.$OfferPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      offerId: string
      name: string
      type: $Enums.CreativeType
      size: string
      format: string
      url: string
      downloadUrl: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["creative"]>
    composites: {}
  }

  type CreativeGetPayload<S extends boolean | null | undefined | CreativeDefaultArgs> = $Result.GetResult<Prisma.$CreativePayload, S>

  type CreativeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CreativeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CreativeCountAggregateInputType | true
    }

  export interface CreativeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Creative'], meta: { name: 'Creative' } }
    /**
     * Find zero or one Creative that matches the filter.
     * @param {CreativeFindUniqueArgs} args - Arguments to find a Creative
     * @example
     * // Get one Creative
     * const creative = await prisma.creative.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreativeFindUniqueArgs>(args: SelectSubset<T, CreativeFindUniqueArgs<ExtArgs>>): Prisma__CreativeClient<$Result.GetResult<Prisma.$CreativePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Creative that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CreativeFindUniqueOrThrowArgs} args - Arguments to find a Creative
     * @example
     * // Get one Creative
     * const creative = await prisma.creative.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreativeFindUniqueOrThrowArgs>(args: SelectSubset<T, CreativeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreativeClient<$Result.GetResult<Prisma.$CreativePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Creative that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreativeFindFirstArgs} args - Arguments to find a Creative
     * @example
     * // Get one Creative
     * const creative = await prisma.creative.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreativeFindFirstArgs>(args?: SelectSubset<T, CreativeFindFirstArgs<ExtArgs>>): Prisma__CreativeClient<$Result.GetResult<Prisma.$CreativePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Creative that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreativeFindFirstOrThrowArgs} args - Arguments to find a Creative
     * @example
     * // Get one Creative
     * const creative = await prisma.creative.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreativeFindFirstOrThrowArgs>(args?: SelectSubset<T, CreativeFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreativeClient<$Result.GetResult<Prisma.$CreativePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Creatives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreativeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Creatives
     * const creatives = await prisma.creative.findMany()
     * 
     * // Get first 10 Creatives
     * const creatives = await prisma.creative.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creativeWithIdOnly = await prisma.creative.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreativeFindManyArgs>(args?: SelectSubset<T, CreativeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreativePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Creative.
     * @param {CreativeCreateArgs} args - Arguments to create a Creative.
     * @example
     * // Create one Creative
     * const Creative = await prisma.creative.create({
     *   data: {
     *     // ... data to create a Creative
     *   }
     * })
     * 
     */
    create<T extends CreativeCreateArgs>(args: SelectSubset<T, CreativeCreateArgs<ExtArgs>>): Prisma__CreativeClient<$Result.GetResult<Prisma.$CreativePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Creatives.
     * @param {CreativeCreateManyArgs} args - Arguments to create many Creatives.
     * @example
     * // Create many Creatives
     * const creative = await prisma.creative.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreativeCreateManyArgs>(args?: SelectSubset<T, CreativeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Creatives and returns the data saved in the database.
     * @param {CreativeCreateManyAndReturnArgs} args - Arguments to create many Creatives.
     * @example
     * // Create many Creatives
     * const creative = await prisma.creative.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Creatives and only return the `id`
     * const creativeWithIdOnly = await prisma.creative.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreativeCreateManyAndReturnArgs>(args?: SelectSubset<T, CreativeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreativePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Creative.
     * @param {CreativeDeleteArgs} args - Arguments to delete one Creative.
     * @example
     * // Delete one Creative
     * const Creative = await prisma.creative.delete({
     *   where: {
     *     // ... filter to delete one Creative
     *   }
     * })
     * 
     */
    delete<T extends CreativeDeleteArgs>(args: SelectSubset<T, CreativeDeleteArgs<ExtArgs>>): Prisma__CreativeClient<$Result.GetResult<Prisma.$CreativePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Creative.
     * @param {CreativeUpdateArgs} args - Arguments to update one Creative.
     * @example
     * // Update one Creative
     * const creative = await prisma.creative.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreativeUpdateArgs>(args: SelectSubset<T, CreativeUpdateArgs<ExtArgs>>): Prisma__CreativeClient<$Result.GetResult<Prisma.$CreativePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Creatives.
     * @param {CreativeDeleteManyArgs} args - Arguments to filter Creatives to delete.
     * @example
     * // Delete a few Creatives
     * const { count } = await prisma.creative.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreativeDeleteManyArgs>(args?: SelectSubset<T, CreativeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Creatives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreativeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Creatives
     * const creative = await prisma.creative.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreativeUpdateManyArgs>(args: SelectSubset<T, CreativeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Creative.
     * @param {CreativeUpsertArgs} args - Arguments to update or create a Creative.
     * @example
     * // Update or create a Creative
     * const creative = await prisma.creative.upsert({
     *   create: {
     *     // ... data to create a Creative
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Creative we want to update
     *   }
     * })
     */
    upsert<T extends CreativeUpsertArgs>(args: SelectSubset<T, CreativeUpsertArgs<ExtArgs>>): Prisma__CreativeClient<$Result.GetResult<Prisma.$CreativePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Creatives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreativeCountArgs} args - Arguments to filter Creatives to count.
     * @example
     * // Count the number of Creatives
     * const count = await prisma.creative.count({
     *   where: {
     *     // ... the filter for the Creatives we want to count
     *   }
     * })
    **/
    count<T extends CreativeCountArgs>(
      args?: Subset<T, CreativeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreativeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Creative.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreativeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreativeAggregateArgs>(args: Subset<T, CreativeAggregateArgs>): Prisma.PrismaPromise<GetCreativeAggregateType<T>>

    /**
     * Group by Creative.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreativeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreativeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreativeGroupByArgs['orderBy'] }
        : { orderBy?: CreativeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreativeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreativeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Creative model
   */
  readonly fields: CreativeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Creative.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreativeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    offer<T extends OfferDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OfferDefaultArgs<ExtArgs>>): Prisma__OfferClient<$Result.GetResult<Prisma.$OfferPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Creative model
   */ 
  interface CreativeFieldRefs {
    readonly id: FieldRef<"Creative", 'String'>
    readonly offerId: FieldRef<"Creative", 'String'>
    readonly name: FieldRef<"Creative", 'String'>
    readonly type: FieldRef<"Creative", 'CreativeType'>
    readonly size: FieldRef<"Creative", 'String'>
    readonly format: FieldRef<"Creative", 'String'>
    readonly url: FieldRef<"Creative", 'String'>
    readonly downloadUrl: FieldRef<"Creative", 'String'>
    readonly createdAt: FieldRef<"Creative", 'DateTime'>
    readonly updatedAt: FieldRef<"Creative", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Creative findUnique
   */
  export type CreativeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creative
     */
    select?: CreativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeInclude<ExtArgs> | null
    /**
     * Filter, which Creative to fetch.
     */
    where: CreativeWhereUniqueInput
  }

  /**
   * Creative findUniqueOrThrow
   */
  export type CreativeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creative
     */
    select?: CreativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeInclude<ExtArgs> | null
    /**
     * Filter, which Creative to fetch.
     */
    where: CreativeWhereUniqueInput
  }

  /**
   * Creative findFirst
   */
  export type CreativeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creative
     */
    select?: CreativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeInclude<ExtArgs> | null
    /**
     * Filter, which Creative to fetch.
     */
    where?: CreativeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creatives to fetch.
     */
    orderBy?: CreativeOrderByWithRelationInput | CreativeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Creatives.
     */
    cursor?: CreativeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creatives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creatives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Creatives.
     */
    distinct?: CreativeScalarFieldEnum | CreativeScalarFieldEnum[]
  }

  /**
   * Creative findFirstOrThrow
   */
  export type CreativeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creative
     */
    select?: CreativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeInclude<ExtArgs> | null
    /**
     * Filter, which Creative to fetch.
     */
    where?: CreativeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creatives to fetch.
     */
    orderBy?: CreativeOrderByWithRelationInput | CreativeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Creatives.
     */
    cursor?: CreativeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creatives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creatives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Creatives.
     */
    distinct?: CreativeScalarFieldEnum | CreativeScalarFieldEnum[]
  }

  /**
   * Creative findMany
   */
  export type CreativeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creative
     */
    select?: CreativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeInclude<ExtArgs> | null
    /**
     * Filter, which Creatives to fetch.
     */
    where?: CreativeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Creatives to fetch.
     */
    orderBy?: CreativeOrderByWithRelationInput | CreativeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Creatives.
     */
    cursor?: CreativeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Creatives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Creatives.
     */
    skip?: number
    distinct?: CreativeScalarFieldEnum | CreativeScalarFieldEnum[]
  }

  /**
   * Creative create
   */
  export type CreativeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creative
     */
    select?: CreativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeInclude<ExtArgs> | null
    /**
     * The data needed to create a Creative.
     */
    data: XOR<CreativeCreateInput, CreativeUncheckedCreateInput>
  }

  /**
   * Creative createMany
   */
  export type CreativeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Creatives.
     */
    data: CreativeCreateManyInput | CreativeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Creative createManyAndReturn
   */
  export type CreativeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creative
     */
    select?: CreativeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Creatives.
     */
    data: CreativeCreateManyInput | CreativeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Creative update
   */
  export type CreativeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creative
     */
    select?: CreativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeInclude<ExtArgs> | null
    /**
     * The data needed to update a Creative.
     */
    data: XOR<CreativeUpdateInput, CreativeUncheckedUpdateInput>
    /**
     * Choose, which Creative to update.
     */
    where: CreativeWhereUniqueInput
  }

  /**
   * Creative updateMany
   */
  export type CreativeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Creatives.
     */
    data: XOR<CreativeUpdateManyMutationInput, CreativeUncheckedUpdateManyInput>
    /**
     * Filter which Creatives to update
     */
    where?: CreativeWhereInput
  }

  /**
   * Creative upsert
   */
  export type CreativeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creative
     */
    select?: CreativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeInclude<ExtArgs> | null
    /**
     * The filter to search for the Creative to update in case it exists.
     */
    where: CreativeWhereUniqueInput
    /**
     * In case the Creative found by the `where` argument doesn't exist, create a new Creative with this data.
     */
    create: XOR<CreativeCreateInput, CreativeUncheckedCreateInput>
    /**
     * In case the Creative was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreativeUpdateInput, CreativeUncheckedUpdateInput>
  }

  /**
   * Creative delete
   */
  export type CreativeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creative
     */
    select?: CreativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeInclude<ExtArgs> | null
    /**
     * Filter which Creative to delete.
     */
    where: CreativeWhereUniqueInput
  }

  /**
   * Creative deleteMany
   */
  export type CreativeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Creatives to delete
     */
    where?: CreativeWhereInput
  }

  /**
   * Creative without action
   */
  export type CreativeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Creative
     */
    select?: CreativeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreativeInclude<ExtArgs> | null
  }


  /**
   * Model Coupon
   */

  export type AggregateCoupon = {
    _count: CouponCountAggregateOutputType | null
    _avg: CouponAvgAggregateOutputType | null
    _sum: CouponSumAggregateOutputType | null
    _min: CouponMinAggregateOutputType | null
    _max: CouponMaxAggregateOutputType | null
  }

  export type CouponAvgAggregateOutputType = {
    usage: number | null
    maxUsage: number | null
  }

  export type CouponSumAggregateOutputType = {
    usage: number | null
    maxUsage: number | null
  }

  export type CouponMinAggregateOutputType = {
    id: string | null
    affiliateId: string | null
    code: string | null
    description: string | null
    discount: string | null
    validUntil: Date | null
    usage: number | null
    maxUsage: number | null
    status: $Enums.CouponStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CouponMaxAggregateOutputType = {
    id: string | null
    affiliateId: string | null
    code: string | null
    description: string | null
    discount: string | null
    validUntil: Date | null
    usage: number | null
    maxUsage: number | null
    status: $Enums.CouponStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CouponCountAggregateOutputType = {
    id: number
    affiliateId: number
    code: number
    description: number
    discount: number
    validUntil: number
    usage: number
    maxUsage: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CouponAvgAggregateInputType = {
    usage?: true
    maxUsage?: true
  }

  export type CouponSumAggregateInputType = {
    usage?: true
    maxUsage?: true
  }

  export type CouponMinAggregateInputType = {
    id?: true
    affiliateId?: true
    code?: true
    description?: true
    discount?: true
    validUntil?: true
    usage?: true
    maxUsage?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CouponMaxAggregateInputType = {
    id?: true
    affiliateId?: true
    code?: true
    description?: true
    discount?: true
    validUntil?: true
    usage?: true
    maxUsage?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CouponCountAggregateInputType = {
    id?: true
    affiliateId?: true
    code?: true
    description?: true
    discount?: true
    validUntil?: true
    usage?: true
    maxUsage?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CouponAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Coupon to aggregate.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Coupons
    **/
    _count?: true | CouponCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CouponAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CouponSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CouponMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CouponMaxAggregateInputType
  }

  export type GetCouponAggregateType<T extends CouponAggregateArgs> = {
        [P in keyof T & keyof AggregateCoupon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoupon[P]>
      : GetScalarType<T[P], AggregateCoupon[P]>
  }




  export type CouponGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CouponWhereInput
    orderBy?: CouponOrderByWithAggregationInput | CouponOrderByWithAggregationInput[]
    by: CouponScalarFieldEnum[] | CouponScalarFieldEnum
    having?: CouponScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CouponCountAggregateInputType | true
    _avg?: CouponAvgAggregateInputType
    _sum?: CouponSumAggregateInputType
    _min?: CouponMinAggregateInputType
    _max?: CouponMaxAggregateInputType
  }

  export type CouponGroupByOutputType = {
    id: string
    affiliateId: string
    code: string
    description: string
    discount: string
    validUntil: Date
    usage: number
    maxUsage: number | null
    status: $Enums.CouponStatus
    createdAt: Date
    updatedAt: Date
    _count: CouponCountAggregateOutputType | null
    _avg: CouponAvgAggregateOutputType | null
    _sum: CouponSumAggregateOutputType | null
    _min: CouponMinAggregateOutputType | null
    _max: CouponMaxAggregateOutputType | null
  }

  type GetCouponGroupByPayload<T extends CouponGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CouponGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CouponGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CouponGroupByOutputType[P]>
            : GetScalarType<T[P], CouponGroupByOutputType[P]>
        }
      >
    >


  export type CouponSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    affiliateId?: boolean
    code?: boolean
    description?: boolean
    discount?: boolean
    validUntil?: boolean
    usage?: boolean
    maxUsage?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    affiliate?: boolean | AffiliateProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coupon"]>

  export type CouponSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    affiliateId?: boolean
    code?: boolean
    description?: boolean
    discount?: boolean
    validUntil?: boolean
    usage?: boolean
    maxUsage?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    affiliate?: boolean | AffiliateProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coupon"]>

  export type CouponSelectScalar = {
    id?: boolean
    affiliateId?: boolean
    code?: boolean
    description?: boolean
    discount?: boolean
    validUntil?: boolean
    usage?: boolean
    maxUsage?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CouponInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliate?: boolean | AffiliateProfileDefaultArgs<ExtArgs>
  }
  export type CouponIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliate?: boolean | AffiliateProfileDefaultArgs<ExtArgs>
  }

  export type $CouponPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Coupon"
    objects: {
      affiliate: Prisma.$AffiliateProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      affiliateId: string
      code: string
      description: string
      discount: string
      validUntil: Date
      usage: number
      maxUsage: number | null
      status: $Enums.CouponStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["coupon"]>
    composites: {}
  }

  type CouponGetPayload<S extends boolean | null | undefined | CouponDefaultArgs> = $Result.GetResult<Prisma.$CouponPayload, S>

  type CouponCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CouponFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CouponCountAggregateInputType | true
    }

  export interface CouponDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Coupon'], meta: { name: 'Coupon' } }
    /**
     * Find zero or one Coupon that matches the filter.
     * @param {CouponFindUniqueArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CouponFindUniqueArgs>(args: SelectSubset<T, CouponFindUniqueArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Coupon that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CouponFindUniqueOrThrowArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CouponFindUniqueOrThrowArgs>(args: SelectSubset<T, CouponFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Coupon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindFirstArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CouponFindFirstArgs>(args?: SelectSubset<T, CouponFindFirstArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Coupon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindFirstOrThrowArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CouponFindFirstOrThrowArgs>(args?: SelectSubset<T, CouponFindFirstOrThrowArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Coupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Coupons
     * const coupons = await prisma.coupon.findMany()
     * 
     * // Get first 10 Coupons
     * const coupons = await prisma.coupon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const couponWithIdOnly = await prisma.coupon.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CouponFindManyArgs>(args?: SelectSubset<T, CouponFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Coupon.
     * @param {CouponCreateArgs} args - Arguments to create a Coupon.
     * @example
     * // Create one Coupon
     * const Coupon = await prisma.coupon.create({
     *   data: {
     *     // ... data to create a Coupon
     *   }
     * })
     * 
     */
    create<T extends CouponCreateArgs>(args: SelectSubset<T, CouponCreateArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Coupons.
     * @param {CouponCreateManyArgs} args - Arguments to create many Coupons.
     * @example
     * // Create many Coupons
     * const coupon = await prisma.coupon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CouponCreateManyArgs>(args?: SelectSubset<T, CouponCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Coupons and returns the data saved in the database.
     * @param {CouponCreateManyAndReturnArgs} args - Arguments to create many Coupons.
     * @example
     * // Create many Coupons
     * const coupon = await prisma.coupon.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Coupons and only return the `id`
     * const couponWithIdOnly = await prisma.coupon.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CouponCreateManyAndReturnArgs>(args?: SelectSubset<T, CouponCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Coupon.
     * @param {CouponDeleteArgs} args - Arguments to delete one Coupon.
     * @example
     * // Delete one Coupon
     * const Coupon = await prisma.coupon.delete({
     *   where: {
     *     // ... filter to delete one Coupon
     *   }
     * })
     * 
     */
    delete<T extends CouponDeleteArgs>(args: SelectSubset<T, CouponDeleteArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Coupon.
     * @param {CouponUpdateArgs} args - Arguments to update one Coupon.
     * @example
     * // Update one Coupon
     * const coupon = await prisma.coupon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CouponUpdateArgs>(args: SelectSubset<T, CouponUpdateArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Coupons.
     * @param {CouponDeleteManyArgs} args - Arguments to filter Coupons to delete.
     * @example
     * // Delete a few Coupons
     * const { count } = await prisma.coupon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CouponDeleteManyArgs>(args?: SelectSubset<T, CouponDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Coupons
     * const coupon = await prisma.coupon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CouponUpdateManyArgs>(args: SelectSubset<T, CouponUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Coupon.
     * @param {CouponUpsertArgs} args - Arguments to update or create a Coupon.
     * @example
     * // Update or create a Coupon
     * const coupon = await prisma.coupon.upsert({
     *   create: {
     *     // ... data to create a Coupon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Coupon we want to update
     *   }
     * })
     */
    upsert<T extends CouponUpsertArgs>(args: SelectSubset<T, CouponUpsertArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponCountArgs} args - Arguments to filter Coupons to count.
     * @example
     * // Count the number of Coupons
     * const count = await prisma.coupon.count({
     *   where: {
     *     // ... the filter for the Coupons we want to count
     *   }
     * })
    **/
    count<T extends CouponCountArgs>(
      args?: Subset<T, CouponCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CouponCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Coupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CouponAggregateArgs>(args: Subset<T, CouponAggregateArgs>): Prisma.PrismaPromise<GetCouponAggregateType<T>>

    /**
     * Group by Coupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CouponGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CouponGroupByArgs['orderBy'] }
        : { orderBy?: CouponGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CouponGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCouponGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Coupon model
   */
  readonly fields: CouponFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Coupon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CouponClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    affiliate<T extends AffiliateProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AffiliateProfileDefaultArgs<ExtArgs>>): Prisma__AffiliateProfileClient<$Result.GetResult<Prisma.$AffiliateProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Coupon model
   */ 
  interface CouponFieldRefs {
    readonly id: FieldRef<"Coupon", 'String'>
    readonly affiliateId: FieldRef<"Coupon", 'String'>
    readonly code: FieldRef<"Coupon", 'String'>
    readonly description: FieldRef<"Coupon", 'String'>
    readonly discount: FieldRef<"Coupon", 'String'>
    readonly validUntil: FieldRef<"Coupon", 'DateTime'>
    readonly usage: FieldRef<"Coupon", 'Int'>
    readonly maxUsage: FieldRef<"Coupon", 'Int'>
    readonly status: FieldRef<"Coupon", 'CouponStatus'>
    readonly createdAt: FieldRef<"Coupon", 'DateTime'>
    readonly updatedAt: FieldRef<"Coupon", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Coupon findUnique
   */
  export type CouponFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon findUniqueOrThrow
   */
  export type CouponFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon findFirst
   */
  export type CouponFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Coupons.
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Coupons.
     */
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Coupon findFirstOrThrow
   */
  export type CouponFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Coupons.
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Coupons.
     */
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Coupon findMany
   */
  export type CouponFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupons to fetch.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Coupons.
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Coupon create
   */
  export type CouponCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * The data needed to create a Coupon.
     */
    data: XOR<CouponCreateInput, CouponUncheckedCreateInput>
  }

  /**
   * Coupon createMany
   */
  export type CouponCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Coupons.
     */
    data: CouponCreateManyInput | CouponCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Coupon createManyAndReturn
   */
  export type CouponCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Coupons.
     */
    data: CouponCreateManyInput | CouponCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Coupon update
   */
  export type CouponUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * The data needed to update a Coupon.
     */
    data: XOR<CouponUpdateInput, CouponUncheckedUpdateInput>
    /**
     * Choose, which Coupon to update.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon updateMany
   */
  export type CouponUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Coupons.
     */
    data: XOR<CouponUpdateManyMutationInput, CouponUncheckedUpdateManyInput>
    /**
     * Filter which Coupons to update
     */
    where?: CouponWhereInput
  }

  /**
   * Coupon upsert
   */
  export type CouponUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * The filter to search for the Coupon to update in case it exists.
     */
    where: CouponWhereUniqueInput
    /**
     * In case the Coupon found by the `where` argument doesn't exist, create a new Coupon with this data.
     */
    create: XOR<CouponCreateInput, CouponUncheckedCreateInput>
    /**
     * In case the Coupon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CouponUpdateInput, CouponUncheckedUpdateInput>
  }

  /**
   * Coupon delete
   */
  export type CouponDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter which Coupon to delete.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon deleteMany
   */
  export type CouponDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Coupons to delete
     */
    where?: CouponWhereInput
  }

  /**
   * Coupon without action
   */
  export type CouponDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    type: $Enums.NotificationType | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    type: $Enums.NotificationType | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    message: number
    type: number
    read: number
    data: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    read?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    read?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    read?: true
    data?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    title: string
    message: string
    type: $Enums.NotificationType
    read: boolean
    data: JsonValue | null
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    read?: boolean
    data?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    read?: boolean
    data?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    read?: boolean
    data?: boolean
    createdAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      message: string
      type: $Enums.NotificationType
      read: boolean
      data: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly data: FieldRef<"Notification", 'Json'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Activity
   */

  export type AggregateActivity = {
    _count: ActivityCountAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  export type ActivityMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    resource: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type ActivityMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    resource: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type ActivityCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    resource: number
    details: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type ActivityMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type ActivityMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type ActivityCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type ActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activity to aggregate.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Activities
    **/
    _count?: true | ActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityMaxAggregateInputType
  }

  export type GetActivityAggregateType<T extends ActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivity[P]>
      : GetScalarType<T[P], AggregateActivity[P]>
  }




  export type ActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityWhereInput
    orderBy?: ActivityOrderByWithAggregationInput | ActivityOrderByWithAggregationInput[]
    by: ActivityScalarFieldEnum[] | ActivityScalarFieldEnum
    having?: ActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityCountAggregateInputType | true
    _min?: ActivityMinAggregateInputType
    _max?: ActivityMaxAggregateInputType
  }

  export type ActivityGroupByOutputType = {
    id: string
    userId: string
    action: string
    resource: string
    details: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: ActivityCountAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  type GetActivityGroupByPayload<T extends ActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityGroupByOutputType[P]>
        }
      >
    >


  export type ActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type ActivitySelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type ActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Activity"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      action: string
      resource: string
      details: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["activity"]>
    composites: {}
  }

  type ActivityGetPayload<S extends boolean | null | undefined | ActivityDefaultArgs> = $Result.GetResult<Prisma.$ActivityPayload, S>

  type ActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActivityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActivityCountAggregateInputType | true
    }

  export interface ActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Activity'], meta: { name: 'Activity' } }
    /**
     * Find zero or one Activity that matches the filter.
     * @param {ActivityFindUniqueArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityFindUniqueArgs>(args: SelectSubset<T, ActivityFindUniqueArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Activity that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ActivityFindUniqueOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Activity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityFindFirstArgs>(args?: SelectSubset<T, ActivityFindFirstArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Activity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindFirstOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activities
     * const activities = await prisma.activity.findMany()
     * 
     * // Get first 10 Activities
     * const activities = await prisma.activity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityWithIdOnly = await prisma.activity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityFindManyArgs>(args?: SelectSubset<T, ActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Activity.
     * @param {ActivityCreateArgs} args - Arguments to create a Activity.
     * @example
     * // Create one Activity
     * const Activity = await prisma.activity.create({
     *   data: {
     *     // ... data to create a Activity
     *   }
     * })
     * 
     */
    create<T extends ActivityCreateArgs>(args: SelectSubset<T, ActivityCreateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Activities.
     * @param {ActivityCreateManyArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityCreateManyArgs>(args?: SelectSubset<T, ActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Activities and returns the data saved in the database.
     * @param {ActivityCreateManyAndReturnArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Activity.
     * @param {ActivityDeleteArgs} args - Arguments to delete one Activity.
     * @example
     * // Delete one Activity
     * const Activity = await prisma.activity.delete({
     *   where: {
     *     // ... filter to delete one Activity
     *   }
     * })
     * 
     */
    delete<T extends ActivityDeleteArgs>(args: SelectSubset<T, ActivityDeleteArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Activity.
     * @param {ActivityUpdateArgs} args - Arguments to update one Activity.
     * @example
     * // Update one Activity
     * const activity = await prisma.activity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityUpdateArgs>(args: SelectSubset<T, ActivityUpdateArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Activities.
     * @param {ActivityDeleteManyArgs} args - Arguments to filter Activities to delete.
     * @example
     * // Delete a few Activities
     * const { count } = await prisma.activity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityDeleteManyArgs>(args?: SelectSubset<T, ActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityUpdateManyArgs>(args: SelectSubset<T, ActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Activity.
     * @param {ActivityUpsertArgs} args - Arguments to update or create a Activity.
     * @example
     * // Update or create a Activity
     * const activity = await prisma.activity.upsert({
     *   create: {
     *     // ... data to create a Activity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activity we want to update
     *   }
     * })
     */
    upsert<T extends ActivityUpsertArgs>(args: SelectSubset<T, ActivityUpsertArgs<ExtArgs>>): Prisma__ActivityClient<$Result.GetResult<Prisma.$ActivityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityCountArgs} args - Arguments to filter Activities to count.
     * @example
     * // Count the number of Activities
     * const count = await prisma.activity.count({
     *   where: {
     *     // ... the filter for the Activities we want to count
     *   }
     * })
    **/
    count<T extends ActivityCountArgs>(
      args?: Subset<T, ActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityAggregateArgs>(args: Subset<T, ActivityAggregateArgs>): Prisma.PrismaPromise<GetActivityAggregateType<T>>

    /**
     * Group by Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityGroupByArgs['orderBy'] }
        : { orderBy?: ActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Activity model
   */
  readonly fields: ActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Activity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Activity model
   */ 
  interface ActivityFieldRefs {
    readonly id: FieldRef<"Activity", 'String'>
    readonly userId: FieldRef<"Activity", 'String'>
    readonly action: FieldRef<"Activity", 'String'>
    readonly resource: FieldRef<"Activity", 'String'>
    readonly details: FieldRef<"Activity", 'Json'>
    readonly ipAddress: FieldRef<"Activity", 'String'>
    readonly userAgent: FieldRef<"Activity", 'String'>
    readonly createdAt: FieldRef<"Activity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Activity findUnique
   */
  export type ActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findUniqueOrThrow
   */
  export type ActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity findFirst
   */
  export type ActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findFirstOrThrow
   */
  export type ActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activity to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity findMany
   */
  export type ActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter, which Activities to fetch.
     */
    where?: ActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Activities to fetch.
     */
    orderBy?: ActivityOrderByWithRelationInput | ActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Activities.
     */
    cursor?: ActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Activities.
     */
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * Activity create
   */
  export type ActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a Activity.
     */
    data: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
  }

  /**
   * Activity createMany
   */
  export type ActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Activity createManyAndReturn
   */
  export type ActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Activities.
     */
    data: ActivityCreateManyInput | ActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Activity update
   */
  export type ActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a Activity.
     */
    data: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
    /**
     * Choose, which Activity to update.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity updateMany
   */
  export type ActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Activities.
     */
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyInput>
    /**
     * Filter which Activities to update
     */
    where?: ActivityWhereInput
  }

  /**
   * Activity upsert
   */
  export type ActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the Activity to update in case it exists.
     */
    where: ActivityWhereUniqueInput
    /**
     * In case the Activity found by the `where` argument doesn't exist, create a new Activity with this data.
     */
    create: XOR<ActivityCreateInput, ActivityUncheckedCreateInput>
    /**
     * In case the Activity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityUpdateInput, ActivityUncheckedUpdateInput>
  }

  /**
   * Activity delete
   */
  export type ActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
    /**
     * Filter which Activity to delete.
     */
    where: ActivityWhereUniqueInput
  }

  /**
   * Activity deleteMany
   */
  export type ActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Activities to delete
     */
    where?: ActivityWhereInput
  }

  /**
   * Activity without action
   */
  export type ActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Activity
     */
    select?: ActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityInclude<ExtArgs> | null
  }


  /**
   * Model Webhook
   */

  export type AggregateWebhook = {
    _count: WebhookCountAggregateOutputType | null
    _avg: WebhookAvgAggregateOutputType | null
    _sum: WebhookSumAggregateOutputType | null
    _min: WebhookMinAggregateOutputType | null
    _max: WebhookMaxAggregateOutputType | null
  }

  export type WebhookAvgAggregateOutputType = {
    successRate: number | null
    totalCalls: number | null
  }

  export type WebhookSumAggregateOutputType = {
    successRate: number | null
    totalCalls: number | null
  }

  export type WebhookMinAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    secret: string | null
    status: $Enums.WebhookStatus | null
    lastTriggered: Date | null
    successRate: number | null
    totalCalls: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebhookMaxAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    secret: string | null
    status: $Enums.WebhookStatus | null
    lastTriggered: Date | null
    successRate: number | null
    totalCalls: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebhookCountAggregateOutputType = {
    id: number
    name: number
    url: number
    events: number
    secret: number
    status: number
    lastTriggered: number
    successRate: number
    totalCalls: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WebhookAvgAggregateInputType = {
    successRate?: true
    totalCalls?: true
  }

  export type WebhookSumAggregateInputType = {
    successRate?: true
    totalCalls?: true
  }

  export type WebhookMinAggregateInputType = {
    id?: true
    name?: true
    url?: true
    secret?: true
    status?: true
    lastTriggered?: true
    successRate?: true
    totalCalls?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebhookMaxAggregateInputType = {
    id?: true
    name?: true
    url?: true
    secret?: true
    status?: true
    lastTriggered?: true
    successRate?: true
    totalCalls?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebhookCountAggregateInputType = {
    id?: true
    name?: true
    url?: true
    events?: true
    secret?: true
    status?: true
    lastTriggered?: true
    successRate?: true
    totalCalls?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WebhookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Webhook to aggregate.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Webhooks
    **/
    _count?: true | WebhookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WebhookAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WebhookSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookMaxAggregateInputType
  }

  export type GetWebhookAggregateType<T extends WebhookAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhook[P]>
      : GetScalarType<T[P], AggregateWebhook[P]>
  }




  export type WebhookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookWhereInput
    orderBy?: WebhookOrderByWithAggregationInput | WebhookOrderByWithAggregationInput[]
    by: WebhookScalarFieldEnum[] | WebhookScalarFieldEnum
    having?: WebhookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookCountAggregateInputType | true
    _avg?: WebhookAvgAggregateInputType
    _sum?: WebhookSumAggregateInputType
    _min?: WebhookMinAggregateInputType
    _max?: WebhookMaxAggregateInputType
  }

  export type WebhookGroupByOutputType = {
    id: string
    name: string
    url: string
    events: string[]
    secret: string
    status: $Enums.WebhookStatus
    lastTriggered: Date | null
    successRate: number
    totalCalls: number
    createdAt: Date
    updatedAt: Date
    _count: WebhookCountAggregateOutputType | null
    _avg: WebhookAvgAggregateOutputType | null
    _sum: WebhookSumAggregateOutputType | null
    _min: WebhookMinAggregateOutputType | null
    _max: WebhookMaxAggregateOutputType | null
  }

  type GetWebhookGroupByPayload<T extends WebhookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookGroupByOutputType[P]>
        }
      >
    >


  export type WebhookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    events?: boolean
    secret?: boolean
    status?: boolean
    lastTriggered?: boolean
    successRate?: boolean
    totalCalls?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["webhook"]>

  export type WebhookSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    events?: boolean
    secret?: boolean
    status?: boolean
    lastTriggered?: boolean
    successRate?: boolean
    totalCalls?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["webhook"]>

  export type WebhookSelectScalar = {
    id?: boolean
    name?: boolean
    url?: boolean
    events?: boolean
    secret?: boolean
    status?: boolean
    lastTriggered?: boolean
    successRate?: boolean
    totalCalls?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $WebhookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Webhook"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      url: string
      events: string[]
      secret: string
      status: $Enums.WebhookStatus
      lastTriggered: Date | null
      successRate: number
      totalCalls: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["webhook"]>
    composites: {}
  }

  type WebhookGetPayload<S extends boolean | null | undefined | WebhookDefaultArgs> = $Result.GetResult<Prisma.$WebhookPayload, S>

  type WebhookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WebhookFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WebhookCountAggregateInputType | true
    }

  export interface WebhookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Webhook'], meta: { name: 'Webhook' } }
    /**
     * Find zero or one Webhook that matches the filter.
     * @param {WebhookFindUniqueArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookFindUniqueArgs>(args: SelectSubset<T, WebhookFindUniqueArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Webhook that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WebhookFindUniqueOrThrowArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Webhook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindFirstArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookFindFirstArgs>(args?: SelectSubset<T, WebhookFindFirstArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Webhook that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindFirstOrThrowArgs} args - Arguments to find a Webhook
     * @example
     * // Get one Webhook
     * const webhook = await prisma.webhook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Webhooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Webhooks
     * const webhooks = await prisma.webhook.findMany()
     * 
     * // Get first 10 Webhooks
     * const webhooks = await prisma.webhook.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookWithIdOnly = await prisma.webhook.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookFindManyArgs>(args?: SelectSubset<T, WebhookFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Webhook.
     * @param {WebhookCreateArgs} args - Arguments to create a Webhook.
     * @example
     * // Create one Webhook
     * const Webhook = await prisma.webhook.create({
     *   data: {
     *     // ... data to create a Webhook
     *   }
     * })
     * 
     */
    create<T extends WebhookCreateArgs>(args: SelectSubset<T, WebhookCreateArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Webhooks.
     * @param {WebhookCreateManyArgs} args - Arguments to create many Webhooks.
     * @example
     * // Create many Webhooks
     * const webhook = await prisma.webhook.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookCreateManyArgs>(args?: SelectSubset<T, WebhookCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Webhooks and returns the data saved in the database.
     * @param {WebhookCreateManyAndReturnArgs} args - Arguments to create many Webhooks.
     * @example
     * // Create many Webhooks
     * const webhook = await prisma.webhook.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Webhooks and only return the `id`
     * const webhookWithIdOnly = await prisma.webhook.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebhookCreateManyAndReturnArgs>(args?: SelectSubset<T, WebhookCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Webhook.
     * @param {WebhookDeleteArgs} args - Arguments to delete one Webhook.
     * @example
     * // Delete one Webhook
     * const Webhook = await prisma.webhook.delete({
     *   where: {
     *     // ... filter to delete one Webhook
     *   }
     * })
     * 
     */
    delete<T extends WebhookDeleteArgs>(args: SelectSubset<T, WebhookDeleteArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Webhook.
     * @param {WebhookUpdateArgs} args - Arguments to update one Webhook.
     * @example
     * // Update one Webhook
     * const webhook = await prisma.webhook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookUpdateArgs>(args: SelectSubset<T, WebhookUpdateArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Webhooks.
     * @param {WebhookDeleteManyArgs} args - Arguments to filter Webhooks to delete.
     * @example
     * // Delete a few Webhooks
     * const { count } = await prisma.webhook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookDeleteManyArgs>(args?: SelectSubset<T, WebhookDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Webhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Webhooks
     * const webhook = await prisma.webhook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookUpdateManyArgs>(args: SelectSubset<T, WebhookUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Webhook.
     * @param {WebhookUpsertArgs} args - Arguments to update or create a Webhook.
     * @example
     * // Update or create a Webhook
     * const webhook = await prisma.webhook.upsert({
     *   create: {
     *     // ... data to create a Webhook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Webhook we want to update
     *   }
     * })
     */
    upsert<T extends WebhookUpsertArgs>(args: SelectSubset<T, WebhookUpsertArgs<ExtArgs>>): Prisma__WebhookClient<$Result.GetResult<Prisma.$WebhookPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Webhooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookCountArgs} args - Arguments to filter Webhooks to count.
     * @example
     * // Count the number of Webhooks
     * const count = await prisma.webhook.count({
     *   where: {
     *     // ... the filter for the Webhooks we want to count
     *   }
     * })
    **/
    count<T extends WebhookCountArgs>(
      args?: Subset<T, WebhookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Webhook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookAggregateArgs>(args: Subset<T, WebhookAggregateArgs>): Prisma.PrismaPromise<GetWebhookAggregateType<T>>

    /**
     * Group by Webhook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookGroupByArgs['orderBy'] }
        : { orderBy?: WebhookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Webhook model
   */
  readonly fields: WebhookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Webhook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Webhook model
   */ 
  interface WebhookFieldRefs {
    readonly id: FieldRef<"Webhook", 'String'>
    readonly name: FieldRef<"Webhook", 'String'>
    readonly url: FieldRef<"Webhook", 'String'>
    readonly events: FieldRef<"Webhook", 'String[]'>
    readonly secret: FieldRef<"Webhook", 'String'>
    readonly status: FieldRef<"Webhook", 'WebhookStatus'>
    readonly lastTriggered: FieldRef<"Webhook", 'DateTime'>
    readonly successRate: FieldRef<"Webhook", 'Float'>
    readonly totalCalls: FieldRef<"Webhook", 'Int'>
    readonly createdAt: FieldRef<"Webhook", 'DateTime'>
    readonly updatedAt: FieldRef<"Webhook", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Webhook findUnique
   */
  export type WebhookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook findUniqueOrThrow
   */
  export type WebhookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook findFirst
   */
  export type WebhookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Webhooks.
     */
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook findFirstOrThrow
   */
  export type WebhookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Filter, which Webhook to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Webhooks.
     */
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook findMany
   */
  export type WebhookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Filter, which Webhooks to fetch.
     */
    where?: WebhookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Webhooks to fetch.
     */
    orderBy?: WebhookOrderByWithRelationInput | WebhookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Webhooks.
     */
    cursor?: WebhookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Webhooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Webhooks.
     */
    skip?: number
    distinct?: WebhookScalarFieldEnum | WebhookScalarFieldEnum[]
  }

  /**
   * Webhook create
   */
  export type WebhookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * The data needed to create a Webhook.
     */
    data: XOR<WebhookCreateInput, WebhookUncheckedCreateInput>
  }

  /**
   * Webhook createMany
   */
  export type WebhookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Webhooks.
     */
    data: WebhookCreateManyInput | WebhookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Webhook createManyAndReturn
   */
  export type WebhookCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Webhooks.
     */
    data: WebhookCreateManyInput | WebhookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Webhook update
   */
  export type WebhookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * The data needed to update a Webhook.
     */
    data: XOR<WebhookUpdateInput, WebhookUncheckedUpdateInput>
    /**
     * Choose, which Webhook to update.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook updateMany
   */
  export type WebhookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Webhooks.
     */
    data: XOR<WebhookUpdateManyMutationInput, WebhookUncheckedUpdateManyInput>
    /**
     * Filter which Webhooks to update
     */
    where?: WebhookWhereInput
  }

  /**
   * Webhook upsert
   */
  export type WebhookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * The filter to search for the Webhook to update in case it exists.
     */
    where: WebhookWhereUniqueInput
    /**
     * In case the Webhook found by the `where` argument doesn't exist, create a new Webhook with this data.
     */
    create: XOR<WebhookCreateInput, WebhookUncheckedCreateInput>
    /**
     * In case the Webhook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookUpdateInput, WebhookUncheckedUpdateInput>
  }

  /**
   * Webhook delete
   */
  export type WebhookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
    /**
     * Filter which Webhook to delete.
     */
    where: WebhookWhereUniqueInput
  }

  /**
   * Webhook deleteMany
   */
  export type WebhookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Webhooks to delete
     */
    where?: WebhookWhereInput
  }

  /**
   * Webhook without action
   */
  export type WebhookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Webhook
     */
    select?: WebhookSelect<ExtArgs> | null
  }


  /**
   * Model TrafficRule
   */

  export type AggregateTrafficRule = {
    _count: TrafficRuleCountAggregateOutputType | null
    _avg: TrafficRuleAvgAggregateOutputType | null
    _sum: TrafficRuleSumAggregateOutputType | null
    _min: TrafficRuleMinAggregateOutputType | null
    _max: TrafficRuleMaxAggregateOutputType | null
  }

  export type TrafficRuleAvgAggregateOutputType = {
    hits: number | null
  }

  export type TrafficRuleSumAggregateOutputType = {
    hits: number | null
  }

  export type TrafficRuleMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.RuleType | null
    action: $Enums.RuleAction | null
    status: $Enums.RuleStatus | null
    hits: number | null
    lastTriggered: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrafficRuleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.RuleType | null
    action: $Enums.RuleAction | null
    status: $Enums.RuleStatus | null
    hits: number | null
    lastTriggered: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrafficRuleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type: number
    conditions: number
    action: number
    status: number
    hits: number
    lastTriggered: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrafficRuleAvgAggregateInputType = {
    hits?: true
  }

  export type TrafficRuleSumAggregateInputType = {
    hits?: true
  }

  export type TrafficRuleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    action?: true
    status?: true
    hits?: true
    lastTriggered?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrafficRuleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    action?: true
    status?: true
    hits?: true
    lastTriggered?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrafficRuleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    conditions?: true
    action?: true
    status?: true
    hits?: true
    lastTriggered?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrafficRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrafficRule to aggregate.
     */
    where?: TrafficRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrafficRules to fetch.
     */
    orderBy?: TrafficRuleOrderByWithRelationInput | TrafficRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrafficRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrafficRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrafficRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrafficRules
    **/
    _count?: true | TrafficRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrafficRuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrafficRuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrafficRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrafficRuleMaxAggregateInputType
  }

  export type GetTrafficRuleAggregateType<T extends TrafficRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateTrafficRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrafficRule[P]>
      : GetScalarType<T[P], AggregateTrafficRule[P]>
  }




  export type TrafficRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrafficRuleWhereInput
    orderBy?: TrafficRuleOrderByWithAggregationInput | TrafficRuleOrderByWithAggregationInput[]
    by: TrafficRuleScalarFieldEnum[] | TrafficRuleScalarFieldEnum
    having?: TrafficRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrafficRuleCountAggregateInputType | true
    _avg?: TrafficRuleAvgAggregateInputType
    _sum?: TrafficRuleSumAggregateInputType
    _min?: TrafficRuleMinAggregateInputType
    _max?: TrafficRuleMaxAggregateInputType
  }

  export type TrafficRuleGroupByOutputType = {
    id: string
    name: string
    description: string
    type: $Enums.RuleType
    conditions: JsonValue
    action: $Enums.RuleAction
    status: $Enums.RuleStatus
    hits: number
    lastTriggered: Date | null
    createdAt: Date
    updatedAt: Date
    _count: TrafficRuleCountAggregateOutputType | null
    _avg: TrafficRuleAvgAggregateOutputType | null
    _sum: TrafficRuleSumAggregateOutputType | null
    _min: TrafficRuleMinAggregateOutputType | null
    _max: TrafficRuleMaxAggregateOutputType | null
  }

  type GetTrafficRuleGroupByPayload<T extends TrafficRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrafficRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrafficRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrafficRuleGroupByOutputType[P]>
            : GetScalarType<T[P], TrafficRuleGroupByOutputType[P]>
        }
      >
    >


  export type TrafficRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    conditions?: boolean
    action?: boolean
    status?: boolean
    hits?: boolean
    lastTriggered?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["trafficRule"]>

  export type TrafficRuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    conditions?: boolean
    action?: boolean
    status?: boolean
    hits?: boolean
    lastTriggered?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["trafficRule"]>

  export type TrafficRuleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    conditions?: boolean
    action?: boolean
    status?: boolean
    hits?: boolean
    lastTriggered?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $TrafficRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrafficRule"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      type: $Enums.RuleType
      conditions: Prisma.JsonValue
      action: $Enums.RuleAction
      status: $Enums.RuleStatus
      hits: number
      lastTriggered: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trafficRule"]>
    composites: {}
  }

  type TrafficRuleGetPayload<S extends boolean | null | undefined | TrafficRuleDefaultArgs> = $Result.GetResult<Prisma.$TrafficRulePayload, S>

  type TrafficRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TrafficRuleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TrafficRuleCountAggregateInputType | true
    }

  export interface TrafficRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrafficRule'], meta: { name: 'TrafficRule' } }
    /**
     * Find zero or one TrafficRule that matches the filter.
     * @param {TrafficRuleFindUniqueArgs} args - Arguments to find a TrafficRule
     * @example
     * // Get one TrafficRule
     * const trafficRule = await prisma.trafficRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrafficRuleFindUniqueArgs>(args: SelectSubset<T, TrafficRuleFindUniqueArgs<ExtArgs>>): Prisma__TrafficRuleClient<$Result.GetResult<Prisma.$TrafficRulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TrafficRule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TrafficRuleFindUniqueOrThrowArgs} args - Arguments to find a TrafficRule
     * @example
     * // Get one TrafficRule
     * const trafficRule = await prisma.trafficRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrafficRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, TrafficRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrafficRuleClient<$Result.GetResult<Prisma.$TrafficRulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TrafficRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrafficRuleFindFirstArgs} args - Arguments to find a TrafficRule
     * @example
     * // Get one TrafficRule
     * const trafficRule = await prisma.trafficRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrafficRuleFindFirstArgs>(args?: SelectSubset<T, TrafficRuleFindFirstArgs<ExtArgs>>): Prisma__TrafficRuleClient<$Result.GetResult<Prisma.$TrafficRulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TrafficRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrafficRuleFindFirstOrThrowArgs} args - Arguments to find a TrafficRule
     * @example
     * // Get one TrafficRule
     * const trafficRule = await prisma.trafficRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrafficRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, TrafficRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrafficRuleClient<$Result.GetResult<Prisma.$TrafficRulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TrafficRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrafficRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrafficRules
     * const trafficRules = await prisma.trafficRule.findMany()
     * 
     * // Get first 10 TrafficRules
     * const trafficRules = await prisma.trafficRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trafficRuleWithIdOnly = await prisma.trafficRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrafficRuleFindManyArgs>(args?: SelectSubset<T, TrafficRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrafficRulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TrafficRule.
     * @param {TrafficRuleCreateArgs} args - Arguments to create a TrafficRule.
     * @example
     * // Create one TrafficRule
     * const TrafficRule = await prisma.trafficRule.create({
     *   data: {
     *     // ... data to create a TrafficRule
     *   }
     * })
     * 
     */
    create<T extends TrafficRuleCreateArgs>(args: SelectSubset<T, TrafficRuleCreateArgs<ExtArgs>>): Prisma__TrafficRuleClient<$Result.GetResult<Prisma.$TrafficRulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TrafficRules.
     * @param {TrafficRuleCreateManyArgs} args - Arguments to create many TrafficRules.
     * @example
     * // Create many TrafficRules
     * const trafficRule = await prisma.trafficRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrafficRuleCreateManyArgs>(args?: SelectSubset<T, TrafficRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrafficRules and returns the data saved in the database.
     * @param {TrafficRuleCreateManyAndReturnArgs} args - Arguments to create many TrafficRules.
     * @example
     * // Create many TrafficRules
     * const trafficRule = await prisma.trafficRule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrafficRules and only return the `id`
     * const trafficRuleWithIdOnly = await prisma.trafficRule.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrafficRuleCreateManyAndReturnArgs>(args?: SelectSubset<T, TrafficRuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrafficRulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TrafficRule.
     * @param {TrafficRuleDeleteArgs} args - Arguments to delete one TrafficRule.
     * @example
     * // Delete one TrafficRule
     * const TrafficRule = await prisma.trafficRule.delete({
     *   where: {
     *     // ... filter to delete one TrafficRule
     *   }
     * })
     * 
     */
    delete<T extends TrafficRuleDeleteArgs>(args: SelectSubset<T, TrafficRuleDeleteArgs<ExtArgs>>): Prisma__TrafficRuleClient<$Result.GetResult<Prisma.$TrafficRulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TrafficRule.
     * @param {TrafficRuleUpdateArgs} args - Arguments to update one TrafficRule.
     * @example
     * // Update one TrafficRule
     * const trafficRule = await prisma.trafficRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrafficRuleUpdateArgs>(args: SelectSubset<T, TrafficRuleUpdateArgs<ExtArgs>>): Prisma__TrafficRuleClient<$Result.GetResult<Prisma.$TrafficRulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TrafficRules.
     * @param {TrafficRuleDeleteManyArgs} args - Arguments to filter TrafficRules to delete.
     * @example
     * // Delete a few TrafficRules
     * const { count } = await prisma.trafficRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrafficRuleDeleteManyArgs>(args?: SelectSubset<T, TrafficRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrafficRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrafficRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrafficRules
     * const trafficRule = await prisma.trafficRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrafficRuleUpdateManyArgs>(args: SelectSubset<T, TrafficRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TrafficRule.
     * @param {TrafficRuleUpsertArgs} args - Arguments to update or create a TrafficRule.
     * @example
     * // Update or create a TrafficRule
     * const trafficRule = await prisma.trafficRule.upsert({
     *   create: {
     *     // ... data to create a TrafficRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrafficRule we want to update
     *   }
     * })
     */
    upsert<T extends TrafficRuleUpsertArgs>(args: SelectSubset<T, TrafficRuleUpsertArgs<ExtArgs>>): Prisma__TrafficRuleClient<$Result.GetResult<Prisma.$TrafficRulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TrafficRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrafficRuleCountArgs} args - Arguments to filter TrafficRules to count.
     * @example
     * // Count the number of TrafficRules
     * const count = await prisma.trafficRule.count({
     *   where: {
     *     // ... the filter for the TrafficRules we want to count
     *   }
     * })
    **/
    count<T extends TrafficRuleCountArgs>(
      args?: Subset<T, TrafficRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrafficRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrafficRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrafficRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrafficRuleAggregateArgs>(args: Subset<T, TrafficRuleAggregateArgs>): Prisma.PrismaPromise<GetTrafficRuleAggregateType<T>>

    /**
     * Group by TrafficRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrafficRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrafficRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrafficRuleGroupByArgs['orderBy'] }
        : { orderBy?: TrafficRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrafficRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrafficRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrafficRule model
   */
  readonly fields: TrafficRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrafficRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrafficRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrafficRule model
   */ 
  interface TrafficRuleFieldRefs {
    readonly id: FieldRef<"TrafficRule", 'String'>
    readonly name: FieldRef<"TrafficRule", 'String'>
    readonly description: FieldRef<"TrafficRule", 'String'>
    readonly type: FieldRef<"TrafficRule", 'RuleType'>
    readonly conditions: FieldRef<"TrafficRule", 'Json'>
    readonly action: FieldRef<"TrafficRule", 'RuleAction'>
    readonly status: FieldRef<"TrafficRule", 'RuleStatus'>
    readonly hits: FieldRef<"TrafficRule", 'Int'>
    readonly lastTriggered: FieldRef<"TrafficRule", 'DateTime'>
    readonly createdAt: FieldRef<"TrafficRule", 'DateTime'>
    readonly updatedAt: FieldRef<"TrafficRule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrafficRule findUnique
   */
  export type TrafficRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrafficRule
     */
    select?: TrafficRuleSelect<ExtArgs> | null
    /**
     * Filter, which TrafficRule to fetch.
     */
    where: TrafficRuleWhereUniqueInput
  }

  /**
   * TrafficRule findUniqueOrThrow
   */
  export type TrafficRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrafficRule
     */
    select?: TrafficRuleSelect<ExtArgs> | null
    /**
     * Filter, which TrafficRule to fetch.
     */
    where: TrafficRuleWhereUniqueInput
  }

  /**
   * TrafficRule findFirst
   */
  export type TrafficRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrafficRule
     */
    select?: TrafficRuleSelect<ExtArgs> | null
    /**
     * Filter, which TrafficRule to fetch.
     */
    where?: TrafficRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrafficRules to fetch.
     */
    orderBy?: TrafficRuleOrderByWithRelationInput | TrafficRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrafficRules.
     */
    cursor?: TrafficRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrafficRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrafficRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrafficRules.
     */
    distinct?: TrafficRuleScalarFieldEnum | TrafficRuleScalarFieldEnum[]
  }

  /**
   * TrafficRule findFirstOrThrow
   */
  export type TrafficRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrafficRule
     */
    select?: TrafficRuleSelect<ExtArgs> | null
    /**
     * Filter, which TrafficRule to fetch.
     */
    where?: TrafficRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrafficRules to fetch.
     */
    orderBy?: TrafficRuleOrderByWithRelationInput | TrafficRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrafficRules.
     */
    cursor?: TrafficRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrafficRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrafficRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrafficRules.
     */
    distinct?: TrafficRuleScalarFieldEnum | TrafficRuleScalarFieldEnum[]
  }

  /**
   * TrafficRule findMany
   */
  export type TrafficRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrafficRule
     */
    select?: TrafficRuleSelect<ExtArgs> | null
    /**
     * Filter, which TrafficRules to fetch.
     */
    where?: TrafficRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrafficRules to fetch.
     */
    orderBy?: TrafficRuleOrderByWithRelationInput | TrafficRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrafficRules.
     */
    cursor?: TrafficRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrafficRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrafficRules.
     */
    skip?: number
    distinct?: TrafficRuleScalarFieldEnum | TrafficRuleScalarFieldEnum[]
  }

  /**
   * TrafficRule create
   */
  export type TrafficRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrafficRule
     */
    select?: TrafficRuleSelect<ExtArgs> | null
    /**
     * The data needed to create a TrafficRule.
     */
    data: XOR<TrafficRuleCreateInput, TrafficRuleUncheckedCreateInput>
  }

  /**
   * TrafficRule createMany
   */
  export type TrafficRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrafficRules.
     */
    data: TrafficRuleCreateManyInput | TrafficRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrafficRule createManyAndReturn
   */
  export type TrafficRuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrafficRule
     */
    select?: TrafficRuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TrafficRules.
     */
    data: TrafficRuleCreateManyInput | TrafficRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrafficRule update
   */
  export type TrafficRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrafficRule
     */
    select?: TrafficRuleSelect<ExtArgs> | null
    /**
     * The data needed to update a TrafficRule.
     */
    data: XOR<TrafficRuleUpdateInput, TrafficRuleUncheckedUpdateInput>
    /**
     * Choose, which TrafficRule to update.
     */
    where: TrafficRuleWhereUniqueInput
  }

  /**
   * TrafficRule updateMany
   */
  export type TrafficRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrafficRules.
     */
    data: XOR<TrafficRuleUpdateManyMutationInput, TrafficRuleUncheckedUpdateManyInput>
    /**
     * Filter which TrafficRules to update
     */
    where?: TrafficRuleWhereInput
  }

  /**
   * TrafficRule upsert
   */
  export type TrafficRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrafficRule
     */
    select?: TrafficRuleSelect<ExtArgs> | null
    /**
     * The filter to search for the TrafficRule to update in case it exists.
     */
    where: TrafficRuleWhereUniqueInput
    /**
     * In case the TrafficRule found by the `where` argument doesn't exist, create a new TrafficRule with this data.
     */
    create: XOR<TrafficRuleCreateInput, TrafficRuleUncheckedCreateInput>
    /**
     * In case the TrafficRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrafficRuleUpdateInput, TrafficRuleUncheckedUpdateInput>
  }

  /**
   * TrafficRule delete
   */
  export type TrafficRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrafficRule
     */
    select?: TrafficRuleSelect<ExtArgs> | null
    /**
     * Filter which TrafficRule to delete.
     */
    where: TrafficRuleWhereUniqueInput
  }

  /**
   * TrafficRule deleteMany
   */
  export type TrafficRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrafficRules to delete
     */
    where?: TrafficRuleWhereInput
  }

  /**
   * TrafficRule without action
   */
  export type TrafficRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrafficRule
     */
    select?: TrafficRuleSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    firstName: 'firstName',
    lastName: 'lastName',
    role: 'role',
    status: 'status',
    avatar: 'avatar',
    phone: 'phone',
    timezone: 'timezone',
    language: 'language',
    twoFactorEnabled: 'twoFactorEnabled',
    twoFactorSecret: 'twoFactorSecret',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastLoginAt: 'lastLoginAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const AffiliateProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    companyName: 'companyName',
    website: 'website',
    socialMedia: 'socialMedia',
    paymentMethod: 'paymentMethod',
    paymentEmail: 'paymentEmail',
    taxId: 'taxId',
    address: 'address',
    tier: 'tier',
    commissionRate: 'commissionRate',
    totalEarnings: 'totalEarnings',
    totalClicks: 'totalClicks',
    totalConversions: 'totalConversions',
    conversionRate: 'conversionRate',
    lastActivityAt: 'lastActivityAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AffiliateProfileScalarFieldEnum = (typeof AffiliateProfileScalarFieldEnum)[keyof typeof AffiliateProfileScalarFieldEnum]


  export const AdminProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    permissions: 'permissions',
    department: 'department',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminProfileScalarFieldEnum = (typeof AdminProfileScalarFieldEnum)[keyof typeof AdminProfileScalarFieldEnum]


  export const OfferScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    category: 'category',
    commissionRate: 'commissionRate',
    status: 'status',
    startDate: 'startDate',
    endDate: 'endDate',
    terms: 'terms',
    requirements: 'requirements',
    totalClicks: 'totalClicks',
    totalConversions: 'totalConversions',
    totalRevenue: 'totalRevenue',
    totalCommissions: 'totalCommissions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OfferScalarFieldEnum = (typeof OfferScalarFieldEnum)[keyof typeof OfferScalarFieldEnum]


  export const OfferApplicationScalarFieldEnum: {
    id: 'id',
    affiliateId: 'affiliateId',
    offerId: 'offerId',
    status: 'status',
    message: 'message',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OfferApplicationScalarFieldEnum = (typeof OfferApplicationScalarFieldEnum)[keyof typeof OfferApplicationScalarFieldEnum]


  export const AffiliateLinkScalarFieldEnum: {
    id: 'id',
    affiliateId: 'affiliateId',
    offerId: 'offerId',
    originalUrl: 'originalUrl',
    shortUrl: 'shortUrl',
    customSlug: 'customSlug',
    clicks: 'clicks',
    conversions: 'conversions',
    earnings: 'earnings',
    isActive: 'isActive',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AffiliateLinkScalarFieldEnum = (typeof AffiliateLinkScalarFieldEnum)[keyof typeof AffiliateLinkScalarFieldEnum]


  export const ClickScalarFieldEnum: {
    id: 'id',
    linkId: 'linkId',
    affiliateId: 'affiliateId',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    referrer: 'referrer',
    country: 'country',
    city: 'city',
    device: 'device',
    browser: 'browser',
    os: 'os',
    converted: 'converted',
    conversionId: 'conversionId',
    createdAt: 'createdAt'
  };

  export type ClickScalarFieldEnum = (typeof ClickScalarFieldEnum)[keyof typeof ClickScalarFieldEnum]


  export const ConversionScalarFieldEnum: {
    id: 'id',
    clickId: 'clickId',
    affiliateId: 'affiliateId',
    offerId: 'offerId',
    customerEmail: 'customerEmail',
    customerValue: 'customerValue',
    commissionAmount: 'commissionAmount',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConversionScalarFieldEnum = (typeof ConversionScalarFieldEnum)[keyof typeof ConversionScalarFieldEnum]


  export const CommissionScalarFieldEnum: {
    id: 'id',
    conversionId: 'conversionId',
    affiliateId: 'affiliateId',
    payoutId: 'payoutId',
    amount: 'amount',
    rate: 'rate',
    status: 'status',
    payoutDate: 'payoutDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommissionScalarFieldEnum = (typeof CommissionScalarFieldEnum)[keyof typeof CommissionScalarFieldEnum]


  export const PayoutScalarFieldEnum: {
    id: 'id',
    affiliateId: 'affiliateId',
    amount: 'amount',
    method: 'method',
    status: 'status',
    referenceId: 'referenceId',
    processedAt: 'processedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PayoutScalarFieldEnum = (typeof PayoutScalarFieldEnum)[keyof typeof PayoutScalarFieldEnum]


  export const CreativeScalarFieldEnum: {
    id: 'id',
    offerId: 'offerId',
    name: 'name',
    type: 'type',
    size: 'size',
    format: 'format',
    url: 'url',
    downloadUrl: 'downloadUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CreativeScalarFieldEnum = (typeof CreativeScalarFieldEnum)[keyof typeof CreativeScalarFieldEnum]


  export const CouponScalarFieldEnum: {
    id: 'id',
    affiliateId: 'affiliateId',
    code: 'code',
    description: 'description',
    discount: 'discount',
    validUntil: 'validUntil',
    usage: 'usage',
    maxUsage: 'maxUsage',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CouponScalarFieldEnum = (typeof CouponScalarFieldEnum)[keyof typeof CouponScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    message: 'message',
    type: 'type',
    read: 'read',
    data: 'data',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const ActivityScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    resource: 'resource',
    details: 'details',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type ActivityScalarFieldEnum = (typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum]


  export const WebhookScalarFieldEnum: {
    id: 'id',
    name: 'name',
    url: 'url',
    events: 'events',
    secret: 'secret',
    status: 'status',
    lastTriggered: 'lastTriggered',
    successRate: 'successRate',
    totalCalls: 'totalCalls',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WebhookScalarFieldEnum = (typeof WebhookScalarFieldEnum)[keyof typeof WebhookScalarFieldEnum]


  export const TrafficRuleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type: 'type',
    conditions: 'conditions',
    action: 'action',
    status: 'status',
    hits: 'hits',
    lastTriggered: 'lastTriggered',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrafficRuleScalarFieldEnum = (typeof TrafficRuleScalarFieldEnum)[keyof typeof TrafficRuleScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'UserStatus[]'
   */
  export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'AffiliateTier'
   */
  export type EnumAffiliateTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AffiliateTier'>
    


  /**
   * Reference to a field of type 'AffiliateTier[]'
   */
  export type ListEnumAffiliateTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AffiliateTier[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'OfferStatus'
   */
  export type EnumOfferStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OfferStatus'>
    


  /**
   * Reference to a field of type 'OfferStatus[]'
   */
  export type ListEnumOfferStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OfferStatus[]'>
    


  /**
   * Reference to a field of type 'ApplicationStatus'
   */
  export type EnumApplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicationStatus'>
    


  /**
   * Reference to a field of type 'ApplicationStatus[]'
   */
  export type ListEnumApplicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicationStatus[]'>
    


  /**
   * Reference to a field of type 'ConversionStatus'
   */
  export type EnumConversionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConversionStatus'>
    


  /**
   * Reference to a field of type 'ConversionStatus[]'
   */
  export type ListEnumConversionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConversionStatus[]'>
    


  /**
   * Reference to a field of type 'CommissionStatus'
   */
  export type EnumCommissionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommissionStatus'>
    


  /**
   * Reference to a field of type 'CommissionStatus[]'
   */
  export type ListEnumCommissionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommissionStatus[]'>
    


  /**
   * Reference to a field of type 'PayoutStatus'
   */
  export type EnumPayoutStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayoutStatus'>
    


  /**
   * Reference to a field of type 'PayoutStatus[]'
   */
  export type ListEnumPayoutStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayoutStatus[]'>
    


  /**
   * Reference to a field of type 'CreativeType'
   */
  export type EnumCreativeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CreativeType'>
    


  /**
   * Reference to a field of type 'CreativeType[]'
   */
  export type ListEnumCreativeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CreativeType[]'>
    


  /**
   * Reference to a field of type 'CouponStatus'
   */
  export type EnumCouponStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CouponStatus'>
    


  /**
   * Reference to a field of type 'CouponStatus[]'
   */
  export type ListEnumCouponStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CouponStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'WebhookStatus'
   */
  export type EnumWebhookStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WebhookStatus'>
    


  /**
   * Reference to a field of type 'WebhookStatus[]'
   */
  export type ListEnumWebhookStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WebhookStatus[]'>
    


  /**
   * Reference to a field of type 'RuleType'
   */
  export type EnumRuleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RuleType'>
    


  /**
   * Reference to a field of type 'RuleType[]'
   */
  export type ListEnumRuleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RuleType[]'>
    


  /**
   * Reference to a field of type 'RuleAction'
   */
  export type EnumRuleActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RuleAction'>
    


  /**
   * Reference to a field of type 'RuleAction[]'
   */
  export type ListEnumRuleActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RuleAction[]'>
    


  /**
   * Reference to a field of type 'RuleStatus'
   */
  export type EnumRuleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RuleStatus'>
    


  /**
   * Reference to a field of type 'RuleStatus[]'
   */
  export type ListEnumRuleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RuleStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    avatar?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    timezone?: StringFilter<"User"> | string
    language?: StringFilter<"User"> | string
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    affiliateProfile?: XOR<AffiliateProfileNullableRelationFilter, AffiliateProfileWhereInput> | null
    adminProfile?: XOR<AdminProfileNullableRelationFilter, AdminProfileWhereInput> | null
    sessions?: SessionListRelationFilter
    notifications?: NotificationListRelationFilter
    activities?: ActivityListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    status?: SortOrder
    avatar?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    timezone?: SortOrder
    language?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    affiliateProfile?: AffiliateProfileOrderByWithRelationInput
    adminProfile?: AdminProfileOrderByWithRelationInput
    sessions?: SessionOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    activities?: ActivityOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    avatar?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    timezone?: StringFilter<"User"> | string
    language?: StringFilter<"User"> | string
    twoFactorEnabled?: BoolFilter<"User"> | boolean
    twoFactorSecret?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    affiliateProfile?: XOR<AffiliateProfileNullableRelationFilter, AffiliateProfileWhereInput> | null
    adminProfile?: XOR<AdminProfileNullableRelationFilter, AdminProfileWhereInput> | null
    sessions?: SessionListRelationFilter
    notifications?: NotificationListRelationFilter
    activities?: ActivityListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    status?: SortOrder
    avatar?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    timezone?: SortOrder
    language?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusWithAggregatesFilter<"User"> | $Enums.UserStatus
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    timezone?: StringWithAggregatesFilter<"User"> | string
    language?: StringWithAggregatesFilter<"User"> | string
    twoFactorEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    twoFactorSecret?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    token?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type AffiliateProfileWhereInput = {
    AND?: AffiliateProfileWhereInput | AffiliateProfileWhereInput[]
    OR?: AffiliateProfileWhereInput[]
    NOT?: AffiliateProfileWhereInput | AffiliateProfileWhereInput[]
    id?: StringFilter<"AffiliateProfile"> | string
    userId?: StringFilter<"AffiliateProfile"> | string
    companyName?: StringNullableFilter<"AffiliateProfile"> | string | null
    website?: StringNullableFilter<"AffiliateProfile"> | string | null
    socialMedia?: JsonNullableFilter<"AffiliateProfile">
    paymentMethod?: EnumPaymentMethodFilter<"AffiliateProfile"> | $Enums.PaymentMethod
    paymentEmail?: StringNullableFilter<"AffiliateProfile"> | string | null
    taxId?: StringNullableFilter<"AffiliateProfile"> | string | null
    address?: JsonNullableFilter<"AffiliateProfile">
    tier?: EnumAffiliateTierFilter<"AffiliateProfile"> | $Enums.AffiliateTier
    commissionRate?: FloatFilter<"AffiliateProfile"> | number
    totalEarnings?: FloatFilter<"AffiliateProfile"> | number
    totalClicks?: IntFilter<"AffiliateProfile"> | number
    totalConversions?: IntFilter<"AffiliateProfile"> | number
    conversionRate?: FloatFilter<"AffiliateProfile"> | number
    lastActivityAt?: DateTimeNullableFilter<"AffiliateProfile"> | Date | string | null
    createdAt?: DateTimeFilter<"AffiliateProfile"> | Date | string
    updatedAt?: DateTimeFilter<"AffiliateProfile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    clicks?: ClickListRelationFilter
    conversions?: ConversionListRelationFilter
    commissions?: CommissionListRelationFilter
    payouts?: PayoutListRelationFilter
    links?: AffiliateLinkListRelationFilter
    coupons?: CouponListRelationFilter
    applications?: OfferApplicationListRelationFilter
  }

  export type AffiliateProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    socialMedia?: SortOrderInput | SortOrder
    paymentMethod?: SortOrder
    paymentEmail?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    tier?: SortOrder
    commissionRate?: SortOrder
    totalEarnings?: SortOrder
    totalClicks?: SortOrder
    totalConversions?: SortOrder
    conversionRate?: SortOrder
    lastActivityAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    clicks?: ClickOrderByRelationAggregateInput
    conversions?: ConversionOrderByRelationAggregateInput
    commissions?: CommissionOrderByRelationAggregateInput
    payouts?: PayoutOrderByRelationAggregateInput
    links?: AffiliateLinkOrderByRelationAggregateInput
    coupons?: CouponOrderByRelationAggregateInput
    applications?: OfferApplicationOrderByRelationAggregateInput
  }

  export type AffiliateProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: AffiliateProfileWhereInput | AffiliateProfileWhereInput[]
    OR?: AffiliateProfileWhereInput[]
    NOT?: AffiliateProfileWhereInput | AffiliateProfileWhereInput[]
    companyName?: StringNullableFilter<"AffiliateProfile"> | string | null
    website?: StringNullableFilter<"AffiliateProfile"> | string | null
    socialMedia?: JsonNullableFilter<"AffiliateProfile">
    paymentMethod?: EnumPaymentMethodFilter<"AffiliateProfile"> | $Enums.PaymentMethod
    paymentEmail?: StringNullableFilter<"AffiliateProfile"> | string | null
    taxId?: StringNullableFilter<"AffiliateProfile"> | string | null
    address?: JsonNullableFilter<"AffiliateProfile">
    tier?: EnumAffiliateTierFilter<"AffiliateProfile"> | $Enums.AffiliateTier
    commissionRate?: FloatFilter<"AffiliateProfile"> | number
    totalEarnings?: FloatFilter<"AffiliateProfile"> | number
    totalClicks?: IntFilter<"AffiliateProfile"> | number
    totalConversions?: IntFilter<"AffiliateProfile"> | number
    conversionRate?: FloatFilter<"AffiliateProfile"> | number
    lastActivityAt?: DateTimeNullableFilter<"AffiliateProfile"> | Date | string | null
    createdAt?: DateTimeFilter<"AffiliateProfile"> | Date | string
    updatedAt?: DateTimeFilter<"AffiliateProfile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    clicks?: ClickListRelationFilter
    conversions?: ConversionListRelationFilter
    commissions?: CommissionListRelationFilter
    payouts?: PayoutListRelationFilter
    links?: AffiliateLinkListRelationFilter
    coupons?: CouponListRelationFilter
    applications?: OfferApplicationListRelationFilter
  }, "id" | "userId">

  export type AffiliateProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    socialMedia?: SortOrderInput | SortOrder
    paymentMethod?: SortOrder
    paymentEmail?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    tier?: SortOrder
    commissionRate?: SortOrder
    totalEarnings?: SortOrder
    totalClicks?: SortOrder
    totalConversions?: SortOrder
    conversionRate?: SortOrder
    lastActivityAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AffiliateProfileCountOrderByAggregateInput
    _avg?: AffiliateProfileAvgOrderByAggregateInput
    _max?: AffiliateProfileMaxOrderByAggregateInput
    _min?: AffiliateProfileMinOrderByAggregateInput
    _sum?: AffiliateProfileSumOrderByAggregateInput
  }

  export type AffiliateProfileScalarWhereWithAggregatesInput = {
    AND?: AffiliateProfileScalarWhereWithAggregatesInput | AffiliateProfileScalarWhereWithAggregatesInput[]
    OR?: AffiliateProfileScalarWhereWithAggregatesInput[]
    NOT?: AffiliateProfileScalarWhereWithAggregatesInput | AffiliateProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AffiliateProfile"> | string
    userId?: StringWithAggregatesFilter<"AffiliateProfile"> | string
    companyName?: StringNullableWithAggregatesFilter<"AffiliateProfile"> | string | null
    website?: StringNullableWithAggregatesFilter<"AffiliateProfile"> | string | null
    socialMedia?: JsonNullableWithAggregatesFilter<"AffiliateProfile">
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"AffiliateProfile"> | $Enums.PaymentMethod
    paymentEmail?: StringNullableWithAggregatesFilter<"AffiliateProfile"> | string | null
    taxId?: StringNullableWithAggregatesFilter<"AffiliateProfile"> | string | null
    address?: JsonNullableWithAggregatesFilter<"AffiliateProfile">
    tier?: EnumAffiliateTierWithAggregatesFilter<"AffiliateProfile"> | $Enums.AffiliateTier
    commissionRate?: FloatWithAggregatesFilter<"AffiliateProfile"> | number
    totalEarnings?: FloatWithAggregatesFilter<"AffiliateProfile"> | number
    totalClicks?: IntWithAggregatesFilter<"AffiliateProfile"> | number
    totalConversions?: IntWithAggregatesFilter<"AffiliateProfile"> | number
    conversionRate?: FloatWithAggregatesFilter<"AffiliateProfile"> | number
    lastActivityAt?: DateTimeNullableWithAggregatesFilter<"AffiliateProfile"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AffiliateProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AffiliateProfile"> | Date | string
  }

  export type AdminProfileWhereInput = {
    AND?: AdminProfileWhereInput | AdminProfileWhereInput[]
    OR?: AdminProfileWhereInput[]
    NOT?: AdminProfileWhereInput | AdminProfileWhereInput[]
    id?: StringFilter<"AdminProfile"> | string
    userId?: StringFilter<"AdminProfile"> | string
    permissions?: StringNullableListFilter<"AdminProfile">
    department?: StringNullableFilter<"AdminProfile"> | string | null
    createdAt?: DateTimeFilter<"AdminProfile"> | Date | string
    updatedAt?: DateTimeFilter<"AdminProfile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AdminProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    permissions?: SortOrder
    department?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AdminProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: AdminProfileWhereInput | AdminProfileWhereInput[]
    OR?: AdminProfileWhereInput[]
    NOT?: AdminProfileWhereInput | AdminProfileWhereInput[]
    permissions?: StringNullableListFilter<"AdminProfile">
    department?: StringNullableFilter<"AdminProfile"> | string | null
    createdAt?: DateTimeFilter<"AdminProfile"> | Date | string
    updatedAt?: DateTimeFilter<"AdminProfile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type AdminProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    permissions?: SortOrder
    department?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminProfileCountOrderByAggregateInput
    _max?: AdminProfileMaxOrderByAggregateInput
    _min?: AdminProfileMinOrderByAggregateInput
  }

  export type AdminProfileScalarWhereWithAggregatesInput = {
    AND?: AdminProfileScalarWhereWithAggregatesInput | AdminProfileScalarWhereWithAggregatesInput[]
    OR?: AdminProfileScalarWhereWithAggregatesInput[]
    NOT?: AdminProfileScalarWhereWithAggregatesInput | AdminProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminProfile"> | string
    userId?: StringWithAggregatesFilter<"AdminProfile"> | string
    permissions?: StringNullableListFilter<"AdminProfile">
    department?: StringNullableWithAggregatesFilter<"AdminProfile"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AdminProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdminProfile"> | Date | string
  }

  export type OfferWhereInput = {
    AND?: OfferWhereInput | OfferWhereInput[]
    OR?: OfferWhereInput[]
    NOT?: OfferWhereInput | OfferWhereInput[]
    id?: StringFilter<"Offer"> | string
    name?: StringFilter<"Offer"> | string
    description?: StringFilter<"Offer"> | string
    category?: StringFilter<"Offer"> | string
    commissionRate?: FloatFilter<"Offer"> | number
    status?: EnumOfferStatusFilter<"Offer"> | $Enums.OfferStatus
    startDate?: DateTimeFilter<"Offer"> | Date | string
    endDate?: DateTimeNullableFilter<"Offer"> | Date | string | null
    terms?: StringNullableFilter<"Offer"> | string | null
    requirements?: StringNullableFilter<"Offer"> | string | null
    totalClicks?: IntFilter<"Offer"> | number
    totalConversions?: IntFilter<"Offer"> | number
    totalRevenue?: FloatFilter<"Offer"> | number
    totalCommissions?: FloatFilter<"Offer"> | number
    createdAt?: DateTimeFilter<"Offer"> | Date | string
    updatedAt?: DateTimeFilter<"Offer"> | Date | string
    applications?: OfferApplicationListRelationFilter
    conversions?: ConversionListRelationFilter
    links?: AffiliateLinkListRelationFilter
    creatives?: CreativeListRelationFilter
  }

  export type OfferOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    commissionRate?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    terms?: SortOrderInput | SortOrder
    requirements?: SortOrderInput | SortOrder
    totalClicks?: SortOrder
    totalConversions?: SortOrder
    totalRevenue?: SortOrder
    totalCommissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    applications?: OfferApplicationOrderByRelationAggregateInput
    conversions?: ConversionOrderByRelationAggregateInput
    links?: AffiliateLinkOrderByRelationAggregateInput
    creatives?: CreativeOrderByRelationAggregateInput
  }

  export type OfferWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OfferWhereInput | OfferWhereInput[]
    OR?: OfferWhereInput[]
    NOT?: OfferWhereInput | OfferWhereInput[]
    name?: StringFilter<"Offer"> | string
    description?: StringFilter<"Offer"> | string
    category?: StringFilter<"Offer"> | string
    commissionRate?: FloatFilter<"Offer"> | number
    status?: EnumOfferStatusFilter<"Offer"> | $Enums.OfferStatus
    startDate?: DateTimeFilter<"Offer"> | Date | string
    endDate?: DateTimeNullableFilter<"Offer"> | Date | string | null
    terms?: StringNullableFilter<"Offer"> | string | null
    requirements?: StringNullableFilter<"Offer"> | string | null
    totalClicks?: IntFilter<"Offer"> | number
    totalConversions?: IntFilter<"Offer"> | number
    totalRevenue?: FloatFilter<"Offer"> | number
    totalCommissions?: FloatFilter<"Offer"> | number
    createdAt?: DateTimeFilter<"Offer"> | Date | string
    updatedAt?: DateTimeFilter<"Offer"> | Date | string
    applications?: OfferApplicationListRelationFilter
    conversions?: ConversionListRelationFilter
    links?: AffiliateLinkListRelationFilter
    creatives?: CreativeListRelationFilter
  }, "id">

  export type OfferOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    commissionRate?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    terms?: SortOrderInput | SortOrder
    requirements?: SortOrderInput | SortOrder
    totalClicks?: SortOrder
    totalConversions?: SortOrder
    totalRevenue?: SortOrder
    totalCommissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OfferCountOrderByAggregateInput
    _avg?: OfferAvgOrderByAggregateInput
    _max?: OfferMaxOrderByAggregateInput
    _min?: OfferMinOrderByAggregateInput
    _sum?: OfferSumOrderByAggregateInput
  }

  export type OfferScalarWhereWithAggregatesInput = {
    AND?: OfferScalarWhereWithAggregatesInput | OfferScalarWhereWithAggregatesInput[]
    OR?: OfferScalarWhereWithAggregatesInput[]
    NOT?: OfferScalarWhereWithAggregatesInput | OfferScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Offer"> | string
    name?: StringWithAggregatesFilter<"Offer"> | string
    description?: StringWithAggregatesFilter<"Offer"> | string
    category?: StringWithAggregatesFilter<"Offer"> | string
    commissionRate?: FloatWithAggregatesFilter<"Offer"> | number
    status?: EnumOfferStatusWithAggregatesFilter<"Offer"> | $Enums.OfferStatus
    startDate?: DateTimeWithAggregatesFilter<"Offer"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Offer"> | Date | string | null
    terms?: StringNullableWithAggregatesFilter<"Offer"> | string | null
    requirements?: StringNullableWithAggregatesFilter<"Offer"> | string | null
    totalClicks?: IntWithAggregatesFilter<"Offer"> | number
    totalConversions?: IntWithAggregatesFilter<"Offer"> | number
    totalRevenue?: FloatWithAggregatesFilter<"Offer"> | number
    totalCommissions?: FloatWithAggregatesFilter<"Offer"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Offer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Offer"> | Date | string
  }

  export type OfferApplicationWhereInput = {
    AND?: OfferApplicationWhereInput | OfferApplicationWhereInput[]
    OR?: OfferApplicationWhereInput[]
    NOT?: OfferApplicationWhereInput | OfferApplicationWhereInput[]
    id?: StringFilter<"OfferApplication"> | string
    affiliateId?: StringFilter<"OfferApplication"> | string
    offerId?: StringFilter<"OfferApplication"> | string
    status?: EnumApplicationStatusFilter<"OfferApplication"> | $Enums.ApplicationStatus
    message?: StringNullableFilter<"OfferApplication"> | string | null
    createdAt?: DateTimeFilter<"OfferApplication"> | Date | string
    updatedAt?: DateTimeFilter<"OfferApplication"> | Date | string
    affiliate?: XOR<AffiliateProfileRelationFilter, AffiliateProfileWhereInput>
    offer?: XOR<OfferRelationFilter, OfferWhereInput>
  }

  export type OfferApplicationOrderByWithRelationInput = {
    id?: SortOrder
    affiliateId?: SortOrder
    offerId?: SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    affiliate?: AffiliateProfileOrderByWithRelationInput
    offer?: OfferOrderByWithRelationInput
  }

  export type OfferApplicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    affiliateId_offerId?: OfferApplicationAffiliateIdOfferIdCompoundUniqueInput
    AND?: OfferApplicationWhereInput | OfferApplicationWhereInput[]
    OR?: OfferApplicationWhereInput[]
    NOT?: OfferApplicationWhereInput | OfferApplicationWhereInput[]
    affiliateId?: StringFilter<"OfferApplication"> | string
    offerId?: StringFilter<"OfferApplication"> | string
    status?: EnumApplicationStatusFilter<"OfferApplication"> | $Enums.ApplicationStatus
    message?: StringNullableFilter<"OfferApplication"> | string | null
    createdAt?: DateTimeFilter<"OfferApplication"> | Date | string
    updatedAt?: DateTimeFilter<"OfferApplication"> | Date | string
    affiliate?: XOR<AffiliateProfileRelationFilter, AffiliateProfileWhereInput>
    offer?: XOR<OfferRelationFilter, OfferWhereInput>
  }, "id" | "affiliateId_offerId">

  export type OfferApplicationOrderByWithAggregationInput = {
    id?: SortOrder
    affiliateId?: SortOrder
    offerId?: SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OfferApplicationCountOrderByAggregateInput
    _max?: OfferApplicationMaxOrderByAggregateInput
    _min?: OfferApplicationMinOrderByAggregateInput
  }

  export type OfferApplicationScalarWhereWithAggregatesInput = {
    AND?: OfferApplicationScalarWhereWithAggregatesInput | OfferApplicationScalarWhereWithAggregatesInput[]
    OR?: OfferApplicationScalarWhereWithAggregatesInput[]
    NOT?: OfferApplicationScalarWhereWithAggregatesInput | OfferApplicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OfferApplication"> | string
    affiliateId?: StringWithAggregatesFilter<"OfferApplication"> | string
    offerId?: StringWithAggregatesFilter<"OfferApplication"> | string
    status?: EnumApplicationStatusWithAggregatesFilter<"OfferApplication"> | $Enums.ApplicationStatus
    message?: StringNullableWithAggregatesFilter<"OfferApplication"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OfferApplication"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OfferApplication"> | Date | string
  }

  export type AffiliateLinkWhereInput = {
    AND?: AffiliateLinkWhereInput | AffiliateLinkWhereInput[]
    OR?: AffiliateLinkWhereInput[]
    NOT?: AffiliateLinkWhereInput | AffiliateLinkWhereInput[]
    id?: StringFilter<"AffiliateLink"> | string
    affiliateId?: StringFilter<"AffiliateLink"> | string
    offerId?: StringNullableFilter<"AffiliateLink"> | string | null
    originalUrl?: StringFilter<"AffiliateLink"> | string
    shortUrl?: StringFilter<"AffiliateLink"> | string
    customSlug?: StringNullableFilter<"AffiliateLink"> | string | null
    clicks?: IntFilter<"AffiliateLink"> | number
    conversions?: IntFilter<"AffiliateLink"> | number
    earnings?: FloatFilter<"AffiliateLink"> | number
    isActive?: BoolFilter<"AffiliateLink"> | boolean
    expiresAt?: DateTimeNullableFilter<"AffiliateLink"> | Date | string | null
    createdAt?: DateTimeFilter<"AffiliateLink"> | Date | string
    updatedAt?: DateTimeFilter<"AffiliateLink"> | Date | string
    affiliate?: XOR<AffiliateProfileRelationFilter, AffiliateProfileWhereInput>
    offer?: XOR<OfferNullableRelationFilter, OfferWhereInput> | null
    clickRecords?: ClickListRelationFilter
  }

  export type AffiliateLinkOrderByWithRelationInput = {
    id?: SortOrder
    affiliateId?: SortOrder
    offerId?: SortOrderInput | SortOrder
    originalUrl?: SortOrder
    shortUrl?: SortOrder
    customSlug?: SortOrderInput | SortOrder
    clicks?: SortOrder
    conversions?: SortOrder
    earnings?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    affiliate?: AffiliateProfileOrderByWithRelationInput
    offer?: OfferOrderByWithRelationInput
    clickRecords?: ClickOrderByRelationAggregateInput
  }

  export type AffiliateLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    shortUrl?: string
    AND?: AffiliateLinkWhereInput | AffiliateLinkWhereInput[]
    OR?: AffiliateLinkWhereInput[]
    NOT?: AffiliateLinkWhereInput | AffiliateLinkWhereInput[]
    affiliateId?: StringFilter<"AffiliateLink"> | string
    offerId?: StringNullableFilter<"AffiliateLink"> | string | null
    originalUrl?: StringFilter<"AffiliateLink"> | string
    customSlug?: StringNullableFilter<"AffiliateLink"> | string | null
    clicks?: IntFilter<"AffiliateLink"> | number
    conversions?: IntFilter<"AffiliateLink"> | number
    earnings?: FloatFilter<"AffiliateLink"> | number
    isActive?: BoolFilter<"AffiliateLink"> | boolean
    expiresAt?: DateTimeNullableFilter<"AffiliateLink"> | Date | string | null
    createdAt?: DateTimeFilter<"AffiliateLink"> | Date | string
    updatedAt?: DateTimeFilter<"AffiliateLink"> | Date | string
    affiliate?: XOR<AffiliateProfileRelationFilter, AffiliateProfileWhereInput>
    offer?: XOR<OfferNullableRelationFilter, OfferWhereInput> | null
    clickRecords?: ClickListRelationFilter
  }, "id" | "shortUrl">

  export type AffiliateLinkOrderByWithAggregationInput = {
    id?: SortOrder
    affiliateId?: SortOrder
    offerId?: SortOrderInput | SortOrder
    originalUrl?: SortOrder
    shortUrl?: SortOrder
    customSlug?: SortOrderInput | SortOrder
    clicks?: SortOrder
    conversions?: SortOrder
    earnings?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AffiliateLinkCountOrderByAggregateInput
    _avg?: AffiliateLinkAvgOrderByAggregateInput
    _max?: AffiliateLinkMaxOrderByAggregateInput
    _min?: AffiliateLinkMinOrderByAggregateInput
    _sum?: AffiliateLinkSumOrderByAggregateInput
  }

  export type AffiliateLinkScalarWhereWithAggregatesInput = {
    AND?: AffiliateLinkScalarWhereWithAggregatesInput | AffiliateLinkScalarWhereWithAggregatesInput[]
    OR?: AffiliateLinkScalarWhereWithAggregatesInput[]
    NOT?: AffiliateLinkScalarWhereWithAggregatesInput | AffiliateLinkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AffiliateLink"> | string
    affiliateId?: StringWithAggregatesFilter<"AffiliateLink"> | string
    offerId?: StringNullableWithAggregatesFilter<"AffiliateLink"> | string | null
    originalUrl?: StringWithAggregatesFilter<"AffiliateLink"> | string
    shortUrl?: StringWithAggregatesFilter<"AffiliateLink"> | string
    customSlug?: StringNullableWithAggregatesFilter<"AffiliateLink"> | string | null
    clicks?: IntWithAggregatesFilter<"AffiliateLink"> | number
    conversions?: IntWithAggregatesFilter<"AffiliateLink"> | number
    earnings?: FloatWithAggregatesFilter<"AffiliateLink"> | number
    isActive?: BoolWithAggregatesFilter<"AffiliateLink"> | boolean
    expiresAt?: DateTimeNullableWithAggregatesFilter<"AffiliateLink"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AffiliateLink"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AffiliateLink"> | Date | string
  }

  export type ClickWhereInput = {
    AND?: ClickWhereInput | ClickWhereInput[]
    OR?: ClickWhereInput[]
    NOT?: ClickWhereInput | ClickWhereInput[]
    id?: StringFilter<"Click"> | string
    linkId?: StringFilter<"Click"> | string
    affiliateId?: StringFilter<"Click"> | string
    ipAddress?: StringFilter<"Click"> | string
    userAgent?: StringFilter<"Click"> | string
    referrer?: StringNullableFilter<"Click"> | string | null
    country?: StringNullableFilter<"Click"> | string | null
    city?: StringNullableFilter<"Click"> | string | null
    device?: StringNullableFilter<"Click"> | string | null
    browser?: StringNullableFilter<"Click"> | string | null
    os?: StringNullableFilter<"Click"> | string | null
    converted?: BoolFilter<"Click"> | boolean
    conversionId?: StringNullableFilter<"Click"> | string | null
    createdAt?: DateTimeFilter<"Click"> | Date | string
    link?: XOR<AffiliateLinkRelationFilter, AffiliateLinkWhereInput>
    affiliate?: XOR<AffiliateProfileRelationFilter, AffiliateProfileWhereInput>
    conversion?: XOR<ConversionNullableRelationFilter, ConversionWhereInput> | null
  }

  export type ClickOrderByWithRelationInput = {
    id?: SortOrder
    linkId?: SortOrder
    affiliateId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    referrer?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    device?: SortOrderInput | SortOrder
    browser?: SortOrderInput | SortOrder
    os?: SortOrderInput | SortOrder
    converted?: SortOrder
    conversionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    link?: AffiliateLinkOrderByWithRelationInput
    affiliate?: AffiliateProfileOrderByWithRelationInput
    conversion?: ConversionOrderByWithRelationInput
  }

  export type ClickWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClickWhereInput | ClickWhereInput[]
    OR?: ClickWhereInput[]
    NOT?: ClickWhereInput | ClickWhereInput[]
    linkId?: StringFilter<"Click"> | string
    affiliateId?: StringFilter<"Click"> | string
    ipAddress?: StringFilter<"Click"> | string
    userAgent?: StringFilter<"Click"> | string
    referrer?: StringNullableFilter<"Click"> | string | null
    country?: StringNullableFilter<"Click"> | string | null
    city?: StringNullableFilter<"Click"> | string | null
    device?: StringNullableFilter<"Click"> | string | null
    browser?: StringNullableFilter<"Click"> | string | null
    os?: StringNullableFilter<"Click"> | string | null
    converted?: BoolFilter<"Click"> | boolean
    conversionId?: StringNullableFilter<"Click"> | string | null
    createdAt?: DateTimeFilter<"Click"> | Date | string
    link?: XOR<AffiliateLinkRelationFilter, AffiliateLinkWhereInput>
    affiliate?: XOR<AffiliateProfileRelationFilter, AffiliateProfileWhereInput>
    conversion?: XOR<ConversionNullableRelationFilter, ConversionWhereInput> | null
  }, "id">

  export type ClickOrderByWithAggregationInput = {
    id?: SortOrder
    linkId?: SortOrder
    affiliateId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    referrer?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    device?: SortOrderInput | SortOrder
    browser?: SortOrderInput | SortOrder
    os?: SortOrderInput | SortOrder
    converted?: SortOrder
    conversionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ClickCountOrderByAggregateInput
    _max?: ClickMaxOrderByAggregateInput
    _min?: ClickMinOrderByAggregateInput
  }

  export type ClickScalarWhereWithAggregatesInput = {
    AND?: ClickScalarWhereWithAggregatesInput | ClickScalarWhereWithAggregatesInput[]
    OR?: ClickScalarWhereWithAggregatesInput[]
    NOT?: ClickScalarWhereWithAggregatesInput | ClickScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Click"> | string
    linkId?: StringWithAggregatesFilter<"Click"> | string
    affiliateId?: StringWithAggregatesFilter<"Click"> | string
    ipAddress?: StringWithAggregatesFilter<"Click"> | string
    userAgent?: StringWithAggregatesFilter<"Click"> | string
    referrer?: StringNullableWithAggregatesFilter<"Click"> | string | null
    country?: StringNullableWithAggregatesFilter<"Click"> | string | null
    city?: StringNullableWithAggregatesFilter<"Click"> | string | null
    device?: StringNullableWithAggregatesFilter<"Click"> | string | null
    browser?: StringNullableWithAggregatesFilter<"Click"> | string | null
    os?: StringNullableWithAggregatesFilter<"Click"> | string | null
    converted?: BoolWithAggregatesFilter<"Click"> | boolean
    conversionId?: StringNullableWithAggregatesFilter<"Click"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Click"> | Date | string
  }

  export type ConversionWhereInput = {
    AND?: ConversionWhereInput | ConversionWhereInput[]
    OR?: ConversionWhereInput[]
    NOT?: ConversionWhereInput | ConversionWhereInput[]
    id?: StringFilter<"Conversion"> | string
    clickId?: StringFilter<"Conversion"> | string
    affiliateId?: StringFilter<"Conversion"> | string
    offerId?: StringFilter<"Conversion"> | string
    customerEmail?: StringNullableFilter<"Conversion"> | string | null
    customerValue?: FloatFilter<"Conversion"> | number
    commissionAmount?: FloatFilter<"Conversion"> | number
    status?: EnumConversionStatusFilter<"Conversion"> | $Enums.ConversionStatus
    createdAt?: DateTimeFilter<"Conversion"> | Date | string
    updatedAt?: DateTimeFilter<"Conversion"> | Date | string
    click?: XOR<ClickRelationFilter, ClickWhereInput>
    affiliate?: XOR<AffiliateProfileRelationFilter, AffiliateProfileWhereInput>
    offer?: XOR<OfferRelationFilter, OfferWhereInput>
    commission?: XOR<CommissionNullableRelationFilter, CommissionWhereInput> | null
  }

  export type ConversionOrderByWithRelationInput = {
    id?: SortOrder
    clickId?: SortOrder
    affiliateId?: SortOrder
    offerId?: SortOrder
    customerEmail?: SortOrderInput | SortOrder
    customerValue?: SortOrder
    commissionAmount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    click?: ClickOrderByWithRelationInput
    affiliate?: AffiliateProfileOrderByWithRelationInput
    offer?: OfferOrderByWithRelationInput
    commission?: CommissionOrderByWithRelationInput
  }

  export type ConversionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clickId?: string
    AND?: ConversionWhereInput | ConversionWhereInput[]
    OR?: ConversionWhereInput[]
    NOT?: ConversionWhereInput | ConversionWhereInput[]
    affiliateId?: StringFilter<"Conversion"> | string
    offerId?: StringFilter<"Conversion"> | string
    customerEmail?: StringNullableFilter<"Conversion"> | string | null
    customerValue?: FloatFilter<"Conversion"> | number
    commissionAmount?: FloatFilter<"Conversion"> | number
    status?: EnumConversionStatusFilter<"Conversion"> | $Enums.ConversionStatus
    createdAt?: DateTimeFilter<"Conversion"> | Date | string
    updatedAt?: DateTimeFilter<"Conversion"> | Date | string
    click?: XOR<ClickRelationFilter, ClickWhereInput>
    affiliate?: XOR<AffiliateProfileRelationFilter, AffiliateProfileWhereInput>
    offer?: XOR<OfferRelationFilter, OfferWhereInput>
    commission?: XOR<CommissionNullableRelationFilter, CommissionWhereInput> | null
  }, "id" | "clickId">

  export type ConversionOrderByWithAggregationInput = {
    id?: SortOrder
    clickId?: SortOrder
    affiliateId?: SortOrder
    offerId?: SortOrder
    customerEmail?: SortOrderInput | SortOrder
    customerValue?: SortOrder
    commissionAmount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConversionCountOrderByAggregateInput
    _avg?: ConversionAvgOrderByAggregateInput
    _max?: ConversionMaxOrderByAggregateInput
    _min?: ConversionMinOrderByAggregateInput
    _sum?: ConversionSumOrderByAggregateInput
  }

  export type ConversionScalarWhereWithAggregatesInput = {
    AND?: ConversionScalarWhereWithAggregatesInput | ConversionScalarWhereWithAggregatesInput[]
    OR?: ConversionScalarWhereWithAggregatesInput[]
    NOT?: ConversionScalarWhereWithAggregatesInput | ConversionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Conversion"> | string
    clickId?: StringWithAggregatesFilter<"Conversion"> | string
    affiliateId?: StringWithAggregatesFilter<"Conversion"> | string
    offerId?: StringWithAggregatesFilter<"Conversion"> | string
    customerEmail?: StringNullableWithAggregatesFilter<"Conversion"> | string | null
    customerValue?: FloatWithAggregatesFilter<"Conversion"> | number
    commissionAmount?: FloatWithAggregatesFilter<"Conversion"> | number
    status?: EnumConversionStatusWithAggregatesFilter<"Conversion"> | $Enums.ConversionStatus
    createdAt?: DateTimeWithAggregatesFilter<"Conversion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Conversion"> | Date | string
  }

  export type CommissionWhereInput = {
    AND?: CommissionWhereInput | CommissionWhereInput[]
    OR?: CommissionWhereInput[]
    NOT?: CommissionWhereInput | CommissionWhereInput[]
    id?: StringFilter<"Commission"> | string
    conversionId?: StringFilter<"Commission"> | string
    affiliateId?: StringFilter<"Commission"> | string
    payoutId?: StringNullableFilter<"Commission"> | string | null
    amount?: FloatFilter<"Commission"> | number
    rate?: FloatFilter<"Commission"> | number
    status?: EnumCommissionStatusFilter<"Commission"> | $Enums.CommissionStatus
    payoutDate?: DateTimeNullableFilter<"Commission"> | Date | string | null
    createdAt?: DateTimeFilter<"Commission"> | Date | string
    updatedAt?: DateTimeFilter<"Commission"> | Date | string
    conversion?: XOR<ConversionRelationFilter, ConversionWhereInput>
    affiliate?: XOR<AffiliateProfileRelationFilter, AffiliateProfileWhereInput>
    payout?: XOR<PayoutNullableRelationFilter, PayoutWhereInput> | null
  }

  export type CommissionOrderByWithRelationInput = {
    id?: SortOrder
    conversionId?: SortOrder
    affiliateId?: SortOrder
    payoutId?: SortOrderInput | SortOrder
    amount?: SortOrder
    rate?: SortOrder
    status?: SortOrder
    payoutDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    conversion?: ConversionOrderByWithRelationInput
    affiliate?: AffiliateProfileOrderByWithRelationInput
    payout?: PayoutOrderByWithRelationInput
  }

  export type CommissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    conversionId?: string
    AND?: CommissionWhereInput | CommissionWhereInput[]
    OR?: CommissionWhereInput[]
    NOT?: CommissionWhereInput | CommissionWhereInput[]
    affiliateId?: StringFilter<"Commission"> | string
    payoutId?: StringNullableFilter<"Commission"> | string | null
    amount?: FloatFilter<"Commission"> | number
    rate?: FloatFilter<"Commission"> | number
    status?: EnumCommissionStatusFilter<"Commission"> | $Enums.CommissionStatus
    payoutDate?: DateTimeNullableFilter<"Commission"> | Date | string | null
    createdAt?: DateTimeFilter<"Commission"> | Date | string
    updatedAt?: DateTimeFilter<"Commission"> | Date | string
    conversion?: XOR<ConversionRelationFilter, ConversionWhereInput>
    affiliate?: XOR<AffiliateProfileRelationFilter, AffiliateProfileWhereInput>
    payout?: XOR<PayoutNullableRelationFilter, PayoutWhereInput> | null
  }, "id" | "conversionId">

  export type CommissionOrderByWithAggregationInput = {
    id?: SortOrder
    conversionId?: SortOrder
    affiliateId?: SortOrder
    payoutId?: SortOrderInput | SortOrder
    amount?: SortOrder
    rate?: SortOrder
    status?: SortOrder
    payoutDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommissionCountOrderByAggregateInput
    _avg?: CommissionAvgOrderByAggregateInput
    _max?: CommissionMaxOrderByAggregateInput
    _min?: CommissionMinOrderByAggregateInput
    _sum?: CommissionSumOrderByAggregateInput
  }

  export type CommissionScalarWhereWithAggregatesInput = {
    AND?: CommissionScalarWhereWithAggregatesInput | CommissionScalarWhereWithAggregatesInput[]
    OR?: CommissionScalarWhereWithAggregatesInput[]
    NOT?: CommissionScalarWhereWithAggregatesInput | CommissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Commission"> | string
    conversionId?: StringWithAggregatesFilter<"Commission"> | string
    affiliateId?: StringWithAggregatesFilter<"Commission"> | string
    payoutId?: StringNullableWithAggregatesFilter<"Commission"> | string | null
    amount?: FloatWithAggregatesFilter<"Commission"> | number
    rate?: FloatWithAggregatesFilter<"Commission"> | number
    status?: EnumCommissionStatusWithAggregatesFilter<"Commission"> | $Enums.CommissionStatus
    payoutDate?: DateTimeNullableWithAggregatesFilter<"Commission"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Commission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Commission"> | Date | string
  }

  export type PayoutWhereInput = {
    AND?: PayoutWhereInput | PayoutWhereInput[]
    OR?: PayoutWhereInput[]
    NOT?: PayoutWhereInput | PayoutWhereInput[]
    id?: StringFilter<"Payout"> | string
    affiliateId?: StringFilter<"Payout"> | string
    amount?: FloatFilter<"Payout"> | number
    method?: EnumPaymentMethodFilter<"Payout"> | $Enums.PaymentMethod
    status?: EnumPayoutStatusFilter<"Payout"> | $Enums.PayoutStatus
    referenceId?: StringNullableFilter<"Payout"> | string | null
    processedAt?: DateTimeNullableFilter<"Payout"> | Date | string | null
    createdAt?: DateTimeFilter<"Payout"> | Date | string
    updatedAt?: DateTimeFilter<"Payout"> | Date | string
    affiliate?: XOR<AffiliateProfileRelationFilter, AffiliateProfileWhereInput>
    commissions?: CommissionListRelationFilter
  }

  export type PayoutOrderByWithRelationInput = {
    id?: SortOrder
    affiliateId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    status?: SortOrder
    referenceId?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    affiliate?: AffiliateProfileOrderByWithRelationInput
    commissions?: CommissionOrderByRelationAggregateInput
  }

  export type PayoutWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PayoutWhereInput | PayoutWhereInput[]
    OR?: PayoutWhereInput[]
    NOT?: PayoutWhereInput | PayoutWhereInput[]
    affiliateId?: StringFilter<"Payout"> | string
    amount?: FloatFilter<"Payout"> | number
    method?: EnumPaymentMethodFilter<"Payout"> | $Enums.PaymentMethod
    status?: EnumPayoutStatusFilter<"Payout"> | $Enums.PayoutStatus
    referenceId?: StringNullableFilter<"Payout"> | string | null
    processedAt?: DateTimeNullableFilter<"Payout"> | Date | string | null
    createdAt?: DateTimeFilter<"Payout"> | Date | string
    updatedAt?: DateTimeFilter<"Payout"> | Date | string
    affiliate?: XOR<AffiliateProfileRelationFilter, AffiliateProfileWhereInput>
    commissions?: CommissionListRelationFilter
  }, "id">

  export type PayoutOrderByWithAggregationInput = {
    id?: SortOrder
    affiliateId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    status?: SortOrder
    referenceId?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PayoutCountOrderByAggregateInput
    _avg?: PayoutAvgOrderByAggregateInput
    _max?: PayoutMaxOrderByAggregateInput
    _min?: PayoutMinOrderByAggregateInput
    _sum?: PayoutSumOrderByAggregateInput
  }

  export type PayoutScalarWhereWithAggregatesInput = {
    AND?: PayoutScalarWhereWithAggregatesInput | PayoutScalarWhereWithAggregatesInput[]
    OR?: PayoutScalarWhereWithAggregatesInput[]
    NOT?: PayoutScalarWhereWithAggregatesInput | PayoutScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payout"> | string
    affiliateId?: StringWithAggregatesFilter<"Payout"> | string
    amount?: FloatWithAggregatesFilter<"Payout"> | number
    method?: EnumPaymentMethodWithAggregatesFilter<"Payout"> | $Enums.PaymentMethod
    status?: EnumPayoutStatusWithAggregatesFilter<"Payout"> | $Enums.PayoutStatus
    referenceId?: StringNullableWithAggregatesFilter<"Payout"> | string | null
    processedAt?: DateTimeNullableWithAggregatesFilter<"Payout"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payout"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payout"> | Date | string
  }

  export type CreativeWhereInput = {
    AND?: CreativeWhereInput | CreativeWhereInput[]
    OR?: CreativeWhereInput[]
    NOT?: CreativeWhereInput | CreativeWhereInput[]
    id?: StringFilter<"Creative"> | string
    offerId?: StringFilter<"Creative"> | string
    name?: StringFilter<"Creative"> | string
    type?: EnumCreativeTypeFilter<"Creative"> | $Enums.CreativeType
    size?: StringFilter<"Creative"> | string
    format?: StringFilter<"Creative"> | string
    url?: StringFilter<"Creative"> | string
    downloadUrl?: StringFilter<"Creative"> | string
    createdAt?: DateTimeFilter<"Creative"> | Date | string
    updatedAt?: DateTimeFilter<"Creative"> | Date | string
    offer?: XOR<OfferRelationFilter, OfferWhereInput>
  }

  export type CreativeOrderByWithRelationInput = {
    id?: SortOrder
    offerId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    size?: SortOrder
    format?: SortOrder
    url?: SortOrder
    downloadUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    offer?: OfferOrderByWithRelationInput
  }

  export type CreativeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CreativeWhereInput | CreativeWhereInput[]
    OR?: CreativeWhereInput[]
    NOT?: CreativeWhereInput | CreativeWhereInput[]
    offerId?: StringFilter<"Creative"> | string
    name?: StringFilter<"Creative"> | string
    type?: EnumCreativeTypeFilter<"Creative"> | $Enums.CreativeType
    size?: StringFilter<"Creative"> | string
    format?: StringFilter<"Creative"> | string
    url?: StringFilter<"Creative"> | string
    downloadUrl?: StringFilter<"Creative"> | string
    createdAt?: DateTimeFilter<"Creative"> | Date | string
    updatedAt?: DateTimeFilter<"Creative"> | Date | string
    offer?: XOR<OfferRelationFilter, OfferWhereInput>
  }, "id">

  export type CreativeOrderByWithAggregationInput = {
    id?: SortOrder
    offerId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    size?: SortOrder
    format?: SortOrder
    url?: SortOrder
    downloadUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CreativeCountOrderByAggregateInput
    _max?: CreativeMaxOrderByAggregateInput
    _min?: CreativeMinOrderByAggregateInput
  }

  export type CreativeScalarWhereWithAggregatesInput = {
    AND?: CreativeScalarWhereWithAggregatesInput | CreativeScalarWhereWithAggregatesInput[]
    OR?: CreativeScalarWhereWithAggregatesInput[]
    NOT?: CreativeScalarWhereWithAggregatesInput | CreativeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Creative"> | string
    offerId?: StringWithAggregatesFilter<"Creative"> | string
    name?: StringWithAggregatesFilter<"Creative"> | string
    type?: EnumCreativeTypeWithAggregatesFilter<"Creative"> | $Enums.CreativeType
    size?: StringWithAggregatesFilter<"Creative"> | string
    format?: StringWithAggregatesFilter<"Creative"> | string
    url?: StringWithAggregatesFilter<"Creative"> | string
    downloadUrl?: StringWithAggregatesFilter<"Creative"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Creative"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Creative"> | Date | string
  }

  export type CouponWhereInput = {
    AND?: CouponWhereInput | CouponWhereInput[]
    OR?: CouponWhereInput[]
    NOT?: CouponWhereInput | CouponWhereInput[]
    id?: StringFilter<"Coupon"> | string
    affiliateId?: StringFilter<"Coupon"> | string
    code?: StringFilter<"Coupon"> | string
    description?: StringFilter<"Coupon"> | string
    discount?: StringFilter<"Coupon"> | string
    validUntil?: DateTimeFilter<"Coupon"> | Date | string
    usage?: IntFilter<"Coupon"> | number
    maxUsage?: IntNullableFilter<"Coupon"> | number | null
    status?: EnumCouponStatusFilter<"Coupon"> | $Enums.CouponStatus
    createdAt?: DateTimeFilter<"Coupon"> | Date | string
    updatedAt?: DateTimeFilter<"Coupon"> | Date | string
    affiliate?: XOR<AffiliateProfileRelationFilter, AffiliateProfileWhereInput>
  }

  export type CouponOrderByWithRelationInput = {
    id?: SortOrder
    affiliateId?: SortOrder
    code?: SortOrder
    description?: SortOrder
    discount?: SortOrder
    validUntil?: SortOrder
    usage?: SortOrder
    maxUsage?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    affiliate?: AffiliateProfileOrderByWithRelationInput
  }

  export type CouponWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: CouponWhereInput | CouponWhereInput[]
    OR?: CouponWhereInput[]
    NOT?: CouponWhereInput | CouponWhereInput[]
    affiliateId?: StringFilter<"Coupon"> | string
    description?: StringFilter<"Coupon"> | string
    discount?: StringFilter<"Coupon"> | string
    validUntil?: DateTimeFilter<"Coupon"> | Date | string
    usage?: IntFilter<"Coupon"> | number
    maxUsage?: IntNullableFilter<"Coupon"> | number | null
    status?: EnumCouponStatusFilter<"Coupon"> | $Enums.CouponStatus
    createdAt?: DateTimeFilter<"Coupon"> | Date | string
    updatedAt?: DateTimeFilter<"Coupon"> | Date | string
    affiliate?: XOR<AffiliateProfileRelationFilter, AffiliateProfileWhereInput>
  }, "id" | "code">

  export type CouponOrderByWithAggregationInput = {
    id?: SortOrder
    affiliateId?: SortOrder
    code?: SortOrder
    description?: SortOrder
    discount?: SortOrder
    validUntil?: SortOrder
    usage?: SortOrder
    maxUsage?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CouponCountOrderByAggregateInput
    _avg?: CouponAvgOrderByAggregateInput
    _max?: CouponMaxOrderByAggregateInput
    _min?: CouponMinOrderByAggregateInput
    _sum?: CouponSumOrderByAggregateInput
  }

  export type CouponScalarWhereWithAggregatesInput = {
    AND?: CouponScalarWhereWithAggregatesInput | CouponScalarWhereWithAggregatesInput[]
    OR?: CouponScalarWhereWithAggregatesInput[]
    NOT?: CouponScalarWhereWithAggregatesInput | CouponScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Coupon"> | string
    affiliateId?: StringWithAggregatesFilter<"Coupon"> | string
    code?: StringWithAggregatesFilter<"Coupon"> | string
    description?: StringWithAggregatesFilter<"Coupon"> | string
    discount?: StringWithAggregatesFilter<"Coupon"> | string
    validUntil?: DateTimeWithAggregatesFilter<"Coupon"> | Date | string
    usage?: IntWithAggregatesFilter<"Coupon"> | number
    maxUsage?: IntNullableWithAggregatesFilter<"Coupon"> | number | null
    status?: EnumCouponStatusWithAggregatesFilter<"Coupon"> | $Enums.CouponStatus
    createdAt?: DateTimeWithAggregatesFilter<"Coupon"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Coupon"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    read?: BoolFilter<"Notification"> | boolean
    data?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    read?: SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    read?: BoolFilter<"Notification"> | boolean
    data?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    read?: SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    data?: JsonNullableWithAggregatesFilter<"Notification">
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type ActivityWhereInput = {
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    id?: StringFilter<"Activity"> | string
    userId?: StringFilter<"Activity"> | string
    action?: StringFilter<"Activity"> | string
    resource?: StringFilter<"Activity"> | string
    details?: JsonNullableFilter<"Activity">
    ipAddress?: StringNullableFilter<"Activity"> | string | null
    userAgent?: StringNullableFilter<"Activity"> | string | null
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ActivityOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityWhereInput | ActivityWhereInput[]
    OR?: ActivityWhereInput[]
    NOT?: ActivityWhereInput | ActivityWhereInput[]
    userId?: StringFilter<"Activity"> | string
    action?: StringFilter<"Activity"> | string
    resource?: StringFilter<"Activity"> | string
    details?: JsonNullableFilter<"Activity">
    ipAddress?: StringNullableFilter<"Activity"> | string | null
    userAgent?: StringNullableFilter<"Activity"> | string | null
    createdAt?: DateTimeFilter<"Activity"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ActivityOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ActivityCountOrderByAggregateInput
    _max?: ActivityMaxOrderByAggregateInput
    _min?: ActivityMinOrderByAggregateInput
  }

  export type ActivityScalarWhereWithAggregatesInput = {
    AND?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    OR?: ActivityScalarWhereWithAggregatesInput[]
    NOT?: ActivityScalarWhereWithAggregatesInput | ActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Activity"> | string
    userId?: StringWithAggregatesFilter<"Activity"> | string
    action?: StringWithAggregatesFilter<"Activity"> | string
    resource?: StringWithAggregatesFilter<"Activity"> | string
    details?: JsonNullableWithAggregatesFilter<"Activity">
    ipAddress?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Activity"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Activity"> | Date | string
  }

  export type WebhookWhereInput = {
    AND?: WebhookWhereInput | WebhookWhereInput[]
    OR?: WebhookWhereInput[]
    NOT?: WebhookWhereInput | WebhookWhereInput[]
    id?: StringFilter<"Webhook"> | string
    name?: StringFilter<"Webhook"> | string
    url?: StringFilter<"Webhook"> | string
    events?: StringNullableListFilter<"Webhook">
    secret?: StringFilter<"Webhook"> | string
    status?: EnumWebhookStatusFilter<"Webhook"> | $Enums.WebhookStatus
    lastTriggered?: DateTimeNullableFilter<"Webhook"> | Date | string | null
    successRate?: FloatFilter<"Webhook"> | number
    totalCalls?: IntFilter<"Webhook"> | number
    createdAt?: DateTimeFilter<"Webhook"> | Date | string
    updatedAt?: DateTimeFilter<"Webhook"> | Date | string
  }

  export type WebhookOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    events?: SortOrder
    secret?: SortOrder
    status?: SortOrder
    lastTriggered?: SortOrderInput | SortOrder
    successRate?: SortOrder
    totalCalls?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebhookWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WebhookWhereInput | WebhookWhereInput[]
    OR?: WebhookWhereInput[]
    NOT?: WebhookWhereInput | WebhookWhereInput[]
    name?: StringFilter<"Webhook"> | string
    url?: StringFilter<"Webhook"> | string
    events?: StringNullableListFilter<"Webhook">
    secret?: StringFilter<"Webhook"> | string
    status?: EnumWebhookStatusFilter<"Webhook"> | $Enums.WebhookStatus
    lastTriggered?: DateTimeNullableFilter<"Webhook"> | Date | string | null
    successRate?: FloatFilter<"Webhook"> | number
    totalCalls?: IntFilter<"Webhook"> | number
    createdAt?: DateTimeFilter<"Webhook"> | Date | string
    updatedAt?: DateTimeFilter<"Webhook"> | Date | string
  }, "id">

  export type WebhookOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    events?: SortOrder
    secret?: SortOrder
    status?: SortOrder
    lastTriggered?: SortOrderInput | SortOrder
    successRate?: SortOrder
    totalCalls?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WebhookCountOrderByAggregateInput
    _avg?: WebhookAvgOrderByAggregateInput
    _max?: WebhookMaxOrderByAggregateInput
    _min?: WebhookMinOrderByAggregateInput
    _sum?: WebhookSumOrderByAggregateInput
  }

  export type WebhookScalarWhereWithAggregatesInput = {
    AND?: WebhookScalarWhereWithAggregatesInput | WebhookScalarWhereWithAggregatesInput[]
    OR?: WebhookScalarWhereWithAggregatesInput[]
    NOT?: WebhookScalarWhereWithAggregatesInput | WebhookScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Webhook"> | string
    name?: StringWithAggregatesFilter<"Webhook"> | string
    url?: StringWithAggregatesFilter<"Webhook"> | string
    events?: StringNullableListFilter<"Webhook">
    secret?: StringWithAggregatesFilter<"Webhook"> | string
    status?: EnumWebhookStatusWithAggregatesFilter<"Webhook"> | $Enums.WebhookStatus
    lastTriggered?: DateTimeNullableWithAggregatesFilter<"Webhook"> | Date | string | null
    successRate?: FloatWithAggregatesFilter<"Webhook"> | number
    totalCalls?: IntWithAggregatesFilter<"Webhook"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Webhook"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Webhook"> | Date | string
  }

  export type TrafficRuleWhereInput = {
    AND?: TrafficRuleWhereInput | TrafficRuleWhereInput[]
    OR?: TrafficRuleWhereInput[]
    NOT?: TrafficRuleWhereInput | TrafficRuleWhereInput[]
    id?: StringFilter<"TrafficRule"> | string
    name?: StringFilter<"TrafficRule"> | string
    description?: StringFilter<"TrafficRule"> | string
    type?: EnumRuleTypeFilter<"TrafficRule"> | $Enums.RuleType
    conditions?: JsonFilter<"TrafficRule">
    action?: EnumRuleActionFilter<"TrafficRule"> | $Enums.RuleAction
    status?: EnumRuleStatusFilter<"TrafficRule"> | $Enums.RuleStatus
    hits?: IntFilter<"TrafficRule"> | number
    lastTriggered?: DateTimeNullableFilter<"TrafficRule"> | Date | string | null
    createdAt?: DateTimeFilter<"TrafficRule"> | Date | string
    updatedAt?: DateTimeFilter<"TrafficRule"> | Date | string
  }

  export type TrafficRuleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    conditions?: SortOrder
    action?: SortOrder
    status?: SortOrder
    hits?: SortOrder
    lastTriggered?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrafficRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrafficRuleWhereInput | TrafficRuleWhereInput[]
    OR?: TrafficRuleWhereInput[]
    NOT?: TrafficRuleWhereInput | TrafficRuleWhereInput[]
    name?: StringFilter<"TrafficRule"> | string
    description?: StringFilter<"TrafficRule"> | string
    type?: EnumRuleTypeFilter<"TrafficRule"> | $Enums.RuleType
    conditions?: JsonFilter<"TrafficRule">
    action?: EnumRuleActionFilter<"TrafficRule"> | $Enums.RuleAction
    status?: EnumRuleStatusFilter<"TrafficRule"> | $Enums.RuleStatus
    hits?: IntFilter<"TrafficRule"> | number
    lastTriggered?: DateTimeNullableFilter<"TrafficRule"> | Date | string | null
    createdAt?: DateTimeFilter<"TrafficRule"> | Date | string
    updatedAt?: DateTimeFilter<"TrafficRule"> | Date | string
  }, "id">

  export type TrafficRuleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    conditions?: SortOrder
    action?: SortOrder
    status?: SortOrder
    hits?: SortOrder
    lastTriggered?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TrafficRuleCountOrderByAggregateInput
    _avg?: TrafficRuleAvgOrderByAggregateInput
    _max?: TrafficRuleMaxOrderByAggregateInput
    _min?: TrafficRuleMinOrderByAggregateInput
    _sum?: TrafficRuleSumOrderByAggregateInput
  }

  export type TrafficRuleScalarWhereWithAggregatesInput = {
    AND?: TrafficRuleScalarWhereWithAggregatesInput | TrafficRuleScalarWhereWithAggregatesInput[]
    OR?: TrafficRuleScalarWhereWithAggregatesInput[]
    NOT?: TrafficRuleScalarWhereWithAggregatesInput | TrafficRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrafficRule"> | string
    name?: StringWithAggregatesFilter<"TrafficRule"> | string
    description?: StringWithAggregatesFilter<"TrafficRule"> | string
    type?: EnumRuleTypeWithAggregatesFilter<"TrafficRule"> | $Enums.RuleType
    conditions?: JsonWithAggregatesFilter<"TrafficRule">
    action?: EnumRuleActionWithAggregatesFilter<"TrafficRule"> | $Enums.RuleAction
    status?: EnumRuleStatusWithAggregatesFilter<"TrafficRule"> | $Enums.RuleStatus
    hits?: IntWithAggregatesFilter<"TrafficRule"> | number
    lastTriggered?: DateTimeNullableWithAggregatesFilter<"TrafficRule"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TrafficRule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TrafficRule"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    avatar?: string | null
    phone?: string | null
    timezone?: string
    language?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    affiliateProfile?: AffiliateProfileCreateNestedOneWithoutUserInput
    adminProfile?: AdminProfileCreateNestedOneWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    avatar?: string | null
    phone?: string | null
    timezone?: string
    language?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    affiliateProfile?: AffiliateProfileUncheckedCreateNestedOneWithoutUserInput
    adminProfile?: AdminProfileUncheckedCreateNestedOneWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateProfile?: AffiliateProfileUpdateOneWithoutUserNestedInput
    adminProfile?: AdminProfileUpdateOneWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateProfile?: AffiliateProfileUncheckedUpdateOneWithoutUserNestedInput
    adminProfile?: AdminProfileUncheckedUpdateOneWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    avatar?: string | null
    phone?: string | null
    timezone?: string
    language?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AffiliateProfileCreateInput = {
    id?: string
    companyName?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: $Enums.PaymentMethod
    paymentEmail?: string | null
    taxId?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    tier?: $Enums.AffiliateTier
    commissionRate?: number
    totalEarnings?: number
    totalClicks?: number
    totalConversions?: number
    conversionRate?: number
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAffiliateProfileInput
    clicks?: ClickCreateNestedManyWithoutAffiliateInput
    conversions?: ConversionCreateNestedManyWithoutAffiliateInput
    commissions?: CommissionCreateNestedManyWithoutAffiliateInput
    payouts?: PayoutCreateNestedManyWithoutAffiliateInput
    links?: AffiliateLinkCreateNestedManyWithoutAffiliateInput
    coupons?: CouponCreateNestedManyWithoutAffiliateInput
    applications?: OfferApplicationCreateNestedManyWithoutAffiliateInput
  }

  export type AffiliateProfileUncheckedCreateInput = {
    id?: string
    userId: string
    companyName?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: $Enums.PaymentMethod
    paymentEmail?: string | null
    taxId?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    tier?: $Enums.AffiliateTier
    commissionRate?: number
    totalEarnings?: number
    totalClicks?: number
    totalConversions?: number
    conversionRate?: number
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clicks?: ClickUncheckedCreateNestedManyWithoutAffiliateInput
    conversions?: ConversionUncheckedCreateNestedManyWithoutAffiliateInput
    commissions?: CommissionUncheckedCreateNestedManyWithoutAffiliateInput
    payouts?: PayoutUncheckedCreateNestedManyWithoutAffiliateInput
    links?: AffiliateLinkUncheckedCreateNestedManyWithoutAffiliateInput
    coupons?: CouponUncheckedCreateNestedManyWithoutAffiliateInput
    applications?: OfferApplicationUncheckedCreateNestedManyWithoutAffiliateInput
  }

  export type AffiliateProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    tier?: EnumAffiliateTierFieldUpdateOperationsInput | $Enums.AffiliateTier
    commissionRate?: FloatFieldUpdateOperationsInput | number
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAffiliateProfileNestedInput
    clicks?: ClickUpdateManyWithoutAffiliateNestedInput
    conversions?: ConversionUpdateManyWithoutAffiliateNestedInput
    commissions?: CommissionUpdateManyWithoutAffiliateNestedInput
    payouts?: PayoutUpdateManyWithoutAffiliateNestedInput
    links?: AffiliateLinkUpdateManyWithoutAffiliateNestedInput
    coupons?: CouponUpdateManyWithoutAffiliateNestedInput
    applications?: OfferApplicationUpdateManyWithoutAffiliateNestedInput
  }

  export type AffiliateProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    tier?: EnumAffiliateTierFieldUpdateOperationsInput | $Enums.AffiliateTier
    commissionRate?: FloatFieldUpdateOperationsInput | number
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clicks?: ClickUncheckedUpdateManyWithoutAffiliateNestedInput
    conversions?: ConversionUncheckedUpdateManyWithoutAffiliateNestedInput
    commissions?: CommissionUncheckedUpdateManyWithoutAffiliateNestedInput
    payouts?: PayoutUncheckedUpdateManyWithoutAffiliateNestedInput
    links?: AffiliateLinkUncheckedUpdateManyWithoutAffiliateNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutAffiliateNestedInput
    applications?: OfferApplicationUncheckedUpdateManyWithoutAffiliateNestedInput
  }

  export type AffiliateProfileCreateManyInput = {
    id?: string
    userId: string
    companyName?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: $Enums.PaymentMethod
    paymentEmail?: string | null
    taxId?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    tier?: $Enums.AffiliateTier
    commissionRate?: number
    totalEarnings?: number
    totalClicks?: number
    totalConversions?: number
    conversionRate?: number
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AffiliateProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    tier?: EnumAffiliateTierFieldUpdateOperationsInput | $Enums.AffiliateTier
    commissionRate?: FloatFieldUpdateOperationsInput | number
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AffiliateProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    tier?: EnumAffiliateTierFieldUpdateOperationsInput | $Enums.AffiliateTier
    commissionRate?: FloatFieldUpdateOperationsInput | number
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminProfileCreateInput = {
    id?: string
    permissions?: AdminProfileCreatepermissionsInput | string[]
    department?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAdminProfileInput
  }

  export type AdminProfileUncheckedCreateInput = {
    id?: string
    userId: string
    permissions?: AdminProfileCreatepermissionsInput | string[]
    department?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissions?: AdminProfileUpdatepermissionsInput | string[]
    department?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdminProfileNestedInput
  }

  export type AdminProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permissions?: AdminProfileUpdatepermissionsInput | string[]
    department?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminProfileCreateManyInput = {
    id?: string
    userId: string
    permissions?: AdminProfileCreatepermissionsInput | string[]
    department?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissions?: AdminProfileUpdatepermissionsInput | string[]
    department?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permissions?: AdminProfileUpdatepermissionsInput | string[]
    department?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferCreateInput = {
    id?: string
    name: string
    description: string
    category: string
    commissionRate: number
    status?: $Enums.OfferStatus
    startDate: Date | string
    endDate?: Date | string | null
    terms?: string | null
    requirements?: string | null
    totalClicks?: number
    totalConversions?: number
    totalRevenue?: number
    totalCommissions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: OfferApplicationCreateNestedManyWithoutOfferInput
    conversions?: ConversionCreateNestedManyWithoutOfferInput
    links?: AffiliateLinkCreateNestedManyWithoutOfferInput
    creatives?: CreativeCreateNestedManyWithoutOfferInput
  }

  export type OfferUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    category: string
    commissionRate: number
    status?: $Enums.OfferStatus
    startDate: Date | string
    endDate?: Date | string | null
    terms?: string | null
    requirements?: string | null
    totalClicks?: number
    totalConversions?: number
    totalRevenue?: number
    totalCommissions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: OfferApplicationUncheckedCreateNestedManyWithoutOfferInput
    conversions?: ConversionUncheckedCreateNestedManyWithoutOfferInput
    links?: AffiliateLinkUncheckedCreateNestedManyWithoutOfferInput
    creatives?: CreativeUncheckedCreateNestedManyWithoutOfferInput
  }

  export type OfferUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    commissionRate?: FloatFieldUpdateOperationsInput | number
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    totalCommissions?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: OfferApplicationUpdateManyWithoutOfferNestedInput
    conversions?: ConversionUpdateManyWithoutOfferNestedInput
    links?: AffiliateLinkUpdateManyWithoutOfferNestedInput
    creatives?: CreativeUpdateManyWithoutOfferNestedInput
  }

  export type OfferUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    commissionRate?: FloatFieldUpdateOperationsInput | number
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    totalCommissions?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: OfferApplicationUncheckedUpdateManyWithoutOfferNestedInput
    conversions?: ConversionUncheckedUpdateManyWithoutOfferNestedInput
    links?: AffiliateLinkUncheckedUpdateManyWithoutOfferNestedInput
    creatives?: CreativeUncheckedUpdateManyWithoutOfferNestedInput
  }

  export type OfferCreateManyInput = {
    id?: string
    name: string
    description: string
    category: string
    commissionRate: number
    status?: $Enums.OfferStatus
    startDate: Date | string
    endDate?: Date | string | null
    terms?: string | null
    requirements?: string | null
    totalClicks?: number
    totalConversions?: number
    totalRevenue?: number
    totalCommissions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    commissionRate?: FloatFieldUpdateOperationsInput | number
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    totalCommissions?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    commissionRate?: FloatFieldUpdateOperationsInput | number
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    totalCommissions?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferApplicationCreateInput = {
    id?: string
    status?: $Enums.ApplicationStatus
    message?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    affiliate: AffiliateProfileCreateNestedOneWithoutApplicationsInput
    offer: OfferCreateNestedOneWithoutApplicationsInput
  }

  export type OfferApplicationUncheckedCreateInput = {
    id?: string
    affiliateId: string
    offerId: string
    status?: $Enums.ApplicationStatus
    message?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferApplicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliate?: AffiliateProfileUpdateOneRequiredWithoutApplicationsNestedInput
    offer?: OfferUpdateOneRequiredWithoutApplicationsNestedInput
  }

  export type OfferApplicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliateId?: StringFieldUpdateOperationsInput | string
    offerId?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferApplicationCreateManyInput = {
    id?: string
    affiliateId: string
    offerId: string
    status?: $Enums.ApplicationStatus
    message?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferApplicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferApplicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliateId?: StringFieldUpdateOperationsInput | string
    offerId?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AffiliateLinkCreateInput = {
    id?: string
    originalUrl: string
    shortUrl: string
    customSlug?: string | null
    clicks?: number
    conversions?: number
    earnings?: number
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    affiliate: AffiliateProfileCreateNestedOneWithoutLinksInput
    offer?: OfferCreateNestedOneWithoutLinksInput
    clickRecords?: ClickCreateNestedManyWithoutLinkInput
  }

  export type AffiliateLinkUncheckedCreateInput = {
    id?: string
    affiliateId: string
    offerId?: string | null
    originalUrl: string
    shortUrl: string
    customSlug?: string | null
    clicks?: number
    conversions?: number
    earnings?: number
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clickRecords?: ClickUncheckedCreateNestedManyWithoutLinkInput
  }

  export type AffiliateLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    shortUrl?: StringFieldUpdateOperationsInput | string
    customSlug?: NullableStringFieldUpdateOperationsInput | string | null
    clicks?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    earnings?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliate?: AffiliateProfileUpdateOneRequiredWithoutLinksNestedInput
    offer?: OfferUpdateOneWithoutLinksNestedInput
    clickRecords?: ClickUpdateManyWithoutLinkNestedInput
  }

  export type AffiliateLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliateId?: StringFieldUpdateOperationsInput | string
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    originalUrl?: StringFieldUpdateOperationsInput | string
    shortUrl?: StringFieldUpdateOperationsInput | string
    customSlug?: NullableStringFieldUpdateOperationsInput | string | null
    clicks?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    earnings?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clickRecords?: ClickUncheckedUpdateManyWithoutLinkNestedInput
  }

  export type AffiliateLinkCreateManyInput = {
    id?: string
    affiliateId: string
    offerId?: string | null
    originalUrl: string
    shortUrl: string
    customSlug?: string | null
    clicks?: number
    conversions?: number
    earnings?: number
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AffiliateLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    shortUrl?: StringFieldUpdateOperationsInput | string
    customSlug?: NullableStringFieldUpdateOperationsInput | string | null
    clicks?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    earnings?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AffiliateLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliateId?: StringFieldUpdateOperationsInput | string
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    originalUrl?: StringFieldUpdateOperationsInput | string
    shortUrl?: StringFieldUpdateOperationsInput | string
    customSlug?: NullableStringFieldUpdateOperationsInput | string | null
    clicks?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    earnings?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClickCreateInput = {
    id?: string
    ipAddress: string
    userAgent: string
    referrer?: string | null
    country?: string | null
    city?: string | null
    device?: string | null
    browser?: string | null
    os?: string | null
    converted?: boolean
    conversionId?: string | null
    createdAt?: Date | string
    link: AffiliateLinkCreateNestedOneWithoutClickRecordsInput
    affiliate: AffiliateProfileCreateNestedOneWithoutClicksInput
    conversion?: ConversionCreateNestedOneWithoutClickInput
  }

  export type ClickUncheckedCreateInput = {
    id?: string
    linkId: string
    affiliateId: string
    ipAddress: string
    userAgent: string
    referrer?: string | null
    country?: string | null
    city?: string | null
    device?: string | null
    browser?: string | null
    os?: string | null
    converted?: boolean
    conversionId?: string | null
    createdAt?: Date | string
    conversion?: ConversionUncheckedCreateNestedOneWithoutClickInput
  }

  export type ClickUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    converted?: BoolFieldUpdateOperationsInput | boolean
    conversionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    link?: AffiliateLinkUpdateOneRequiredWithoutClickRecordsNestedInput
    affiliate?: AffiliateProfileUpdateOneRequiredWithoutClicksNestedInput
    conversion?: ConversionUpdateOneWithoutClickNestedInput
  }

  export type ClickUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    linkId?: StringFieldUpdateOperationsInput | string
    affiliateId?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    converted?: BoolFieldUpdateOperationsInput | boolean
    conversionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversion?: ConversionUncheckedUpdateOneWithoutClickNestedInput
  }

  export type ClickCreateManyInput = {
    id?: string
    linkId: string
    affiliateId: string
    ipAddress: string
    userAgent: string
    referrer?: string | null
    country?: string | null
    city?: string | null
    device?: string | null
    browser?: string | null
    os?: string | null
    converted?: boolean
    conversionId?: string | null
    createdAt?: Date | string
  }

  export type ClickUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    converted?: BoolFieldUpdateOperationsInput | boolean
    conversionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClickUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    linkId?: StringFieldUpdateOperationsInput | string
    affiliateId?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    converted?: BoolFieldUpdateOperationsInput | boolean
    conversionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversionCreateInput = {
    id?: string
    customerEmail?: string | null
    customerValue: number
    commissionAmount: number
    status?: $Enums.ConversionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    click: ClickCreateNestedOneWithoutConversionInput
    affiliate: AffiliateProfileCreateNestedOneWithoutConversionsInput
    offer: OfferCreateNestedOneWithoutConversionsInput
    commission?: CommissionCreateNestedOneWithoutConversionInput
  }

  export type ConversionUncheckedCreateInput = {
    id?: string
    clickId: string
    affiliateId: string
    offerId: string
    customerEmail?: string | null
    customerValue: number
    commissionAmount: number
    status?: $Enums.ConversionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    commission?: CommissionUncheckedCreateNestedOneWithoutConversionInput
  }

  export type ConversionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerValue?: FloatFieldUpdateOperationsInput | number
    commissionAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumConversionStatusFieldUpdateOperationsInput | $Enums.ConversionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    click?: ClickUpdateOneRequiredWithoutConversionNestedInput
    affiliate?: AffiliateProfileUpdateOneRequiredWithoutConversionsNestedInput
    offer?: OfferUpdateOneRequiredWithoutConversionsNestedInput
    commission?: CommissionUpdateOneWithoutConversionNestedInput
  }

  export type ConversionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clickId?: StringFieldUpdateOperationsInput | string
    affiliateId?: StringFieldUpdateOperationsInput | string
    offerId?: StringFieldUpdateOperationsInput | string
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerValue?: FloatFieldUpdateOperationsInput | number
    commissionAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumConversionStatusFieldUpdateOperationsInput | $Enums.ConversionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commission?: CommissionUncheckedUpdateOneWithoutConversionNestedInput
  }

  export type ConversionCreateManyInput = {
    id?: string
    clickId: string
    affiliateId: string
    offerId: string
    customerEmail?: string | null
    customerValue: number
    commissionAmount: number
    status?: $Enums.ConversionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerValue?: FloatFieldUpdateOperationsInput | number
    commissionAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumConversionStatusFieldUpdateOperationsInput | $Enums.ConversionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clickId?: StringFieldUpdateOperationsInput | string
    affiliateId?: StringFieldUpdateOperationsInput | string
    offerId?: StringFieldUpdateOperationsInput | string
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerValue?: FloatFieldUpdateOperationsInput | number
    commissionAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumConversionStatusFieldUpdateOperationsInput | $Enums.ConversionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionCreateInput = {
    id?: string
    amount: number
    rate: number
    status?: $Enums.CommissionStatus
    payoutDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conversion: ConversionCreateNestedOneWithoutCommissionInput
    affiliate: AffiliateProfileCreateNestedOneWithoutCommissionsInput
    payout?: PayoutCreateNestedOneWithoutCommissionsInput
  }

  export type CommissionUncheckedCreateInput = {
    id?: string
    conversionId: string
    affiliateId: string
    payoutId?: string | null
    amount: number
    rate: number
    status?: $Enums.CommissionStatus
    payoutDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    status?: EnumCommissionStatusFieldUpdateOperationsInput | $Enums.CommissionStatus
    payoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversion?: ConversionUpdateOneRequiredWithoutCommissionNestedInput
    affiliate?: AffiliateProfileUpdateOneRequiredWithoutCommissionsNestedInput
    payout?: PayoutUpdateOneWithoutCommissionsNestedInput
  }

  export type CommissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversionId?: StringFieldUpdateOperationsInput | string
    affiliateId?: StringFieldUpdateOperationsInput | string
    payoutId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    status?: EnumCommissionStatusFieldUpdateOperationsInput | $Enums.CommissionStatus
    payoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionCreateManyInput = {
    id?: string
    conversionId: string
    affiliateId: string
    payoutId?: string | null
    amount: number
    rate: number
    status?: $Enums.CommissionStatus
    payoutDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    status?: EnumCommissionStatusFieldUpdateOperationsInput | $Enums.CommissionStatus
    payoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversionId?: StringFieldUpdateOperationsInput | string
    affiliateId?: StringFieldUpdateOperationsInput | string
    payoutId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    status?: EnumCommissionStatusFieldUpdateOperationsInput | $Enums.CommissionStatus
    payoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayoutCreateInput = {
    id?: string
    amount: number
    method: $Enums.PaymentMethod
    status?: $Enums.PayoutStatus
    referenceId?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    affiliate: AffiliateProfileCreateNestedOneWithoutPayoutsInput
    commissions?: CommissionCreateNestedManyWithoutPayoutInput
  }

  export type PayoutUncheckedCreateInput = {
    id?: string
    affiliateId: string
    amount: number
    method: $Enums.PaymentMethod
    status?: $Enums.PayoutStatus
    referenceId?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    commissions?: CommissionUncheckedCreateNestedManyWithoutPayoutInput
  }

  export type PayoutUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliate?: AffiliateProfileUpdateOneRequiredWithoutPayoutsNestedInput
    commissions?: CommissionUpdateManyWithoutPayoutNestedInput
  }

  export type PayoutUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliateId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commissions?: CommissionUncheckedUpdateManyWithoutPayoutNestedInput
  }

  export type PayoutCreateManyInput = {
    id?: string
    affiliateId: string
    amount: number
    method: $Enums.PaymentMethod
    status?: $Enums.PayoutStatus
    referenceId?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayoutUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayoutUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliateId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreativeCreateInput = {
    id?: string
    name: string
    type: $Enums.CreativeType
    size: string
    format: string
    url: string
    downloadUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    offer: OfferCreateNestedOneWithoutCreativesInput
  }

  export type CreativeUncheckedCreateInput = {
    id?: string
    offerId: string
    name: string
    type: $Enums.CreativeType
    size: string
    format: string
    url: string
    downloadUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CreativeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCreativeTypeFieldUpdateOperationsInput | $Enums.CreativeType
    size?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    downloadUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offer?: OfferUpdateOneRequiredWithoutCreativesNestedInput
  }

  export type CreativeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    offerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCreativeTypeFieldUpdateOperationsInput | $Enums.CreativeType
    size?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    downloadUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreativeCreateManyInput = {
    id?: string
    offerId: string
    name: string
    type: $Enums.CreativeType
    size: string
    format: string
    url: string
    downloadUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CreativeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCreativeTypeFieldUpdateOperationsInput | $Enums.CreativeType
    size?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    downloadUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreativeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    offerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCreativeTypeFieldUpdateOperationsInput | $Enums.CreativeType
    size?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    downloadUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponCreateInput = {
    id?: string
    code: string
    description: string
    discount: string
    validUntil: Date | string
    usage?: number
    maxUsage?: number | null
    status?: $Enums.CouponStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    affiliate: AffiliateProfileCreateNestedOneWithoutCouponsInput
  }

  export type CouponUncheckedCreateInput = {
    id?: string
    affiliateId: string
    code: string
    description: string
    discount: string
    validUntil: Date | string
    usage?: number
    maxUsage?: number | null
    status?: $Enums.CouponStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CouponUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    discount?: StringFieldUpdateOperationsInput | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    usage?: IntFieldUpdateOperationsInput | number
    maxUsage?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumCouponStatusFieldUpdateOperationsInput | $Enums.CouponStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliate?: AffiliateProfileUpdateOneRequiredWithoutCouponsNestedInput
  }

  export type CouponUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliateId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    discount?: StringFieldUpdateOperationsInput | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    usage?: IntFieldUpdateOperationsInput | number
    maxUsage?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumCouponStatusFieldUpdateOperationsInput | $Enums.CouponStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponCreateManyInput = {
    id?: string
    affiliateId: string
    code: string
    description: string
    discount: string
    validUntil: Date | string
    usage?: number
    maxUsage?: number | null
    status?: $Enums.CouponStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CouponUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    discount?: StringFieldUpdateOperationsInput | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    usage?: IntFieldUpdateOperationsInput | number
    maxUsage?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumCouponStatusFieldUpdateOperationsInput | $Enums.CouponStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliateId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    discount?: StringFieldUpdateOperationsInput | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    usage?: IntFieldUpdateOperationsInput | number
    maxUsage?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumCouponStatusFieldUpdateOperationsInput | $Enums.CouponStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    read?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    message: string
    type: $Enums.NotificationType
    read?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    read?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    read?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    title: string
    message: string
    type: $Enums.NotificationType
    read?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    read?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    read?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateInput = {
    id?: string
    action: string
    resource: string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutActivitiesInput
  }

  export type ActivityUncheckedCreateInput = {
    id?: string
    userId: string
    action: string
    resource: string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type ActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type ActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityCreateManyInput = {
    id?: string
    userId: string
    action: string
    resource: string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type ActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookCreateInput = {
    id?: string
    name: string
    url: string
    events?: WebhookCreateeventsInput | string[]
    secret: string
    status?: $Enums.WebhookStatus
    lastTriggered?: Date | string | null
    successRate?: number
    totalCalls?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebhookUncheckedCreateInput = {
    id?: string
    name: string
    url: string
    events?: WebhookCreateeventsInput | string[]
    secret: string
    status?: $Enums.WebhookStatus
    lastTriggered?: Date | string | null
    successRate?: number
    totalCalls?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebhookUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    secret?: StringFieldUpdateOperationsInput | string
    status?: EnumWebhookStatusFieldUpdateOperationsInput | $Enums.WebhookStatus
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successRate?: FloatFieldUpdateOperationsInput | number
    totalCalls?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    secret?: StringFieldUpdateOperationsInput | string
    status?: EnumWebhookStatusFieldUpdateOperationsInput | $Enums.WebhookStatus
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successRate?: FloatFieldUpdateOperationsInput | number
    totalCalls?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookCreateManyInput = {
    id?: string
    name: string
    url: string
    events?: WebhookCreateeventsInput | string[]
    secret: string
    status?: $Enums.WebhookStatus
    lastTriggered?: Date | string | null
    successRate?: number
    totalCalls?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebhookUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    secret?: StringFieldUpdateOperationsInput | string
    status?: EnumWebhookStatusFieldUpdateOperationsInput | $Enums.WebhookStatus
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successRate?: FloatFieldUpdateOperationsInput | number
    totalCalls?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    events?: WebhookUpdateeventsInput | string[]
    secret?: StringFieldUpdateOperationsInput | string
    status?: EnumWebhookStatusFieldUpdateOperationsInput | $Enums.WebhookStatus
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    successRate?: FloatFieldUpdateOperationsInput | number
    totalCalls?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrafficRuleCreateInput = {
    id?: string
    name: string
    description: string
    type: $Enums.RuleType
    conditions: JsonNullValueInput | InputJsonValue
    action: $Enums.RuleAction
    status?: $Enums.RuleStatus
    hits?: number
    lastTriggered?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrafficRuleUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    type: $Enums.RuleType
    conditions: JsonNullValueInput | InputJsonValue
    action: $Enums.RuleAction
    status?: $Enums.RuleStatus
    hits?: number
    lastTriggered?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrafficRuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumRuleTypeFieldUpdateOperationsInput | $Enums.RuleType
    conditions?: JsonNullValueInput | InputJsonValue
    action?: EnumRuleActionFieldUpdateOperationsInput | $Enums.RuleAction
    status?: EnumRuleStatusFieldUpdateOperationsInput | $Enums.RuleStatus
    hits?: IntFieldUpdateOperationsInput | number
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrafficRuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumRuleTypeFieldUpdateOperationsInput | $Enums.RuleType
    conditions?: JsonNullValueInput | InputJsonValue
    action?: EnumRuleActionFieldUpdateOperationsInput | $Enums.RuleAction
    status?: EnumRuleStatusFieldUpdateOperationsInput | $Enums.RuleStatus
    hits?: IntFieldUpdateOperationsInput | number
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrafficRuleCreateManyInput = {
    id?: string
    name: string
    description: string
    type: $Enums.RuleType
    conditions: JsonNullValueInput | InputJsonValue
    action: $Enums.RuleAction
    status?: $Enums.RuleStatus
    hits?: number
    lastTriggered?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrafficRuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumRuleTypeFieldUpdateOperationsInput | $Enums.RuleType
    conditions?: JsonNullValueInput | InputJsonValue
    action?: EnumRuleActionFieldUpdateOperationsInput | $Enums.RuleAction
    status?: EnumRuleStatusFieldUpdateOperationsInput | $Enums.RuleStatus
    hits?: IntFieldUpdateOperationsInput | number
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrafficRuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumRuleTypeFieldUpdateOperationsInput | $Enums.RuleType
    conditions?: JsonNullValueInput | InputJsonValue
    action?: EnumRuleActionFieldUpdateOperationsInput | $Enums.RuleAction
    status?: EnumRuleStatusFieldUpdateOperationsInput | $Enums.RuleStatus
    hits?: IntFieldUpdateOperationsInput | number
    lastTriggered?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type EnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AffiliateProfileNullableRelationFilter = {
    is?: AffiliateProfileWhereInput | null
    isNot?: AffiliateProfileWhereInput | null
  }

  export type AdminProfileNullableRelationFilter = {
    is?: AdminProfileWhereInput | null
    isNot?: AdminProfileWhereInput | null
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type ActivityListRelationFilter = {
    every?: ActivityWhereInput
    some?: ActivityWhereInput
    none?: ActivityWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    status?: SortOrder
    avatar?: SortOrder
    phone?: SortOrder
    timezone?: SortOrder
    language?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    status?: SortOrder
    avatar?: SortOrder
    phone?: SortOrder
    timezone?: SortOrder
    language?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    status?: SortOrder
    avatar?: SortOrder
    phone?: SortOrder
    timezone?: SortOrder
    language?: SortOrder
    twoFactorEnabled?: SortOrder
    twoFactorSecret?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type EnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type EnumAffiliateTierFilter<$PrismaModel = never> = {
    equals?: $Enums.AffiliateTier | EnumAffiliateTierFieldRefInput<$PrismaModel>
    in?: $Enums.AffiliateTier[] | ListEnumAffiliateTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.AffiliateTier[] | ListEnumAffiliateTierFieldRefInput<$PrismaModel>
    not?: NestedEnumAffiliateTierFilter<$PrismaModel> | $Enums.AffiliateTier
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ClickListRelationFilter = {
    every?: ClickWhereInput
    some?: ClickWhereInput
    none?: ClickWhereInput
  }

  export type ConversionListRelationFilter = {
    every?: ConversionWhereInput
    some?: ConversionWhereInput
    none?: ConversionWhereInput
  }

  export type CommissionListRelationFilter = {
    every?: CommissionWhereInput
    some?: CommissionWhereInput
    none?: CommissionWhereInput
  }

  export type PayoutListRelationFilter = {
    every?: PayoutWhereInput
    some?: PayoutWhereInput
    none?: PayoutWhereInput
  }

  export type AffiliateLinkListRelationFilter = {
    every?: AffiliateLinkWhereInput
    some?: AffiliateLinkWhereInput
    none?: AffiliateLinkWhereInput
  }

  export type CouponListRelationFilter = {
    every?: CouponWhereInput
    some?: CouponWhereInput
    none?: CouponWhereInput
  }

  export type OfferApplicationListRelationFilter = {
    every?: OfferApplicationWhereInput
    some?: OfferApplicationWhereInput
    none?: OfferApplicationWhereInput
  }

  export type ClickOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PayoutOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AffiliateLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CouponOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OfferApplicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AffiliateProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    website?: SortOrder
    socialMedia?: SortOrder
    paymentMethod?: SortOrder
    paymentEmail?: SortOrder
    taxId?: SortOrder
    address?: SortOrder
    tier?: SortOrder
    commissionRate?: SortOrder
    totalEarnings?: SortOrder
    totalClicks?: SortOrder
    totalConversions?: SortOrder
    conversionRate?: SortOrder
    lastActivityAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AffiliateProfileAvgOrderByAggregateInput = {
    commissionRate?: SortOrder
    totalEarnings?: SortOrder
    totalClicks?: SortOrder
    totalConversions?: SortOrder
    conversionRate?: SortOrder
  }

  export type AffiliateProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    website?: SortOrder
    paymentMethod?: SortOrder
    paymentEmail?: SortOrder
    taxId?: SortOrder
    tier?: SortOrder
    commissionRate?: SortOrder
    totalEarnings?: SortOrder
    totalClicks?: SortOrder
    totalConversions?: SortOrder
    conversionRate?: SortOrder
    lastActivityAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AffiliateProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyName?: SortOrder
    website?: SortOrder
    paymentMethod?: SortOrder
    paymentEmail?: SortOrder
    taxId?: SortOrder
    tier?: SortOrder
    commissionRate?: SortOrder
    totalEarnings?: SortOrder
    totalClicks?: SortOrder
    totalConversions?: SortOrder
    conversionRate?: SortOrder
    lastActivityAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AffiliateProfileSumOrderByAggregateInput = {
    commissionRate?: SortOrder
    totalEarnings?: SortOrder
    totalClicks?: SortOrder
    totalConversions?: SortOrder
    conversionRate?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type EnumAffiliateTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AffiliateTier | EnumAffiliateTierFieldRefInput<$PrismaModel>
    in?: $Enums.AffiliateTier[] | ListEnumAffiliateTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.AffiliateTier[] | ListEnumAffiliateTierFieldRefInput<$PrismaModel>
    not?: NestedEnumAffiliateTierWithAggregatesFilter<$PrismaModel> | $Enums.AffiliateTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAffiliateTierFilter<$PrismaModel>
    _max?: NestedEnumAffiliateTierFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type AdminProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    permissions?: SortOrder
    department?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    department?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    department?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumOfferStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OfferStatus | EnumOfferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OfferStatus[] | ListEnumOfferStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OfferStatus[] | ListEnumOfferStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOfferStatusFilter<$PrismaModel> | $Enums.OfferStatus
  }

  export type CreativeListRelationFilter = {
    every?: CreativeWhereInput
    some?: CreativeWhereInput
    none?: CreativeWhereInput
  }

  export type CreativeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OfferCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    commissionRate?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    terms?: SortOrder
    requirements?: SortOrder
    totalClicks?: SortOrder
    totalConversions?: SortOrder
    totalRevenue?: SortOrder
    totalCommissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OfferAvgOrderByAggregateInput = {
    commissionRate?: SortOrder
    totalClicks?: SortOrder
    totalConversions?: SortOrder
    totalRevenue?: SortOrder
    totalCommissions?: SortOrder
  }

  export type OfferMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    commissionRate?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    terms?: SortOrder
    requirements?: SortOrder
    totalClicks?: SortOrder
    totalConversions?: SortOrder
    totalRevenue?: SortOrder
    totalCommissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OfferMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    commissionRate?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    terms?: SortOrder
    requirements?: SortOrder
    totalClicks?: SortOrder
    totalConversions?: SortOrder
    totalRevenue?: SortOrder
    totalCommissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OfferSumOrderByAggregateInput = {
    commissionRate?: SortOrder
    totalClicks?: SortOrder
    totalConversions?: SortOrder
    totalRevenue?: SortOrder
    totalCommissions?: SortOrder
  }

  export type EnumOfferStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OfferStatus | EnumOfferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OfferStatus[] | ListEnumOfferStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OfferStatus[] | ListEnumOfferStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOfferStatusWithAggregatesFilter<$PrismaModel> | $Enums.OfferStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOfferStatusFilter<$PrismaModel>
    _max?: NestedEnumOfferStatusFilter<$PrismaModel>
  }

  export type EnumApplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusFilter<$PrismaModel> | $Enums.ApplicationStatus
  }

  export type AffiliateProfileRelationFilter = {
    is?: AffiliateProfileWhereInput
    isNot?: AffiliateProfileWhereInput
  }

  export type OfferRelationFilter = {
    is?: OfferWhereInput
    isNot?: OfferWhereInput
  }

  export type OfferApplicationAffiliateIdOfferIdCompoundUniqueInput = {
    affiliateId: string
    offerId: string
  }

  export type OfferApplicationCountOrderByAggregateInput = {
    id?: SortOrder
    affiliateId?: SortOrder
    offerId?: SortOrder
    status?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OfferApplicationMaxOrderByAggregateInput = {
    id?: SortOrder
    affiliateId?: SortOrder
    offerId?: SortOrder
    status?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OfferApplicationMinOrderByAggregateInput = {
    id?: SortOrder
    affiliateId?: SortOrder
    offerId?: SortOrder
    status?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApplicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumApplicationStatusFilter<$PrismaModel>
  }

  export type OfferNullableRelationFilter = {
    is?: OfferWhereInput | null
    isNot?: OfferWhereInput | null
  }

  export type AffiliateLinkCountOrderByAggregateInput = {
    id?: SortOrder
    affiliateId?: SortOrder
    offerId?: SortOrder
    originalUrl?: SortOrder
    shortUrl?: SortOrder
    customSlug?: SortOrder
    clicks?: SortOrder
    conversions?: SortOrder
    earnings?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AffiliateLinkAvgOrderByAggregateInput = {
    clicks?: SortOrder
    conversions?: SortOrder
    earnings?: SortOrder
  }

  export type AffiliateLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    affiliateId?: SortOrder
    offerId?: SortOrder
    originalUrl?: SortOrder
    shortUrl?: SortOrder
    customSlug?: SortOrder
    clicks?: SortOrder
    conversions?: SortOrder
    earnings?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AffiliateLinkMinOrderByAggregateInput = {
    id?: SortOrder
    affiliateId?: SortOrder
    offerId?: SortOrder
    originalUrl?: SortOrder
    shortUrl?: SortOrder
    customSlug?: SortOrder
    clicks?: SortOrder
    conversions?: SortOrder
    earnings?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AffiliateLinkSumOrderByAggregateInput = {
    clicks?: SortOrder
    conversions?: SortOrder
    earnings?: SortOrder
  }

  export type AffiliateLinkRelationFilter = {
    is?: AffiliateLinkWhereInput
    isNot?: AffiliateLinkWhereInput
  }

  export type ConversionNullableRelationFilter = {
    is?: ConversionWhereInput | null
    isNot?: ConversionWhereInput | null
  }

  export type ClickCountOrderByAggregateInput = {
    id?: SortOrder
    linkId?: SortOrder
    affiliateId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    referrer?: SortOrder
    country?: SortOrder
    city?: SortOrder
    device?: SortOrder
    browser?: SortOrder
    os?: SortOrder
    converted?: SortOrder
    conversionId?: SortOrder
    createdAt?: SortOrder
  }

  export type ClickMaxOrderByAggregateInput = {
    id?: SortOrder
    linkId?: SortOrder
    affiliateId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    referrer?: SortOrder
    country?: SortOrder
    city?: SortOrder
    device?: SortOrder
    browser?: SortOrder
    os?: SortOrder
    converted?: SortOrder
    conversionId?: SortOrder
    createdAt?: SortOrder
  }

  export type ClickMinOrderByAggregateInput = {
    id?: SortOrder
    linkId?: SortOrder
    affiliateId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    referrer?: SortOrder
    country?: SortOrder
    city?: SortOrder
    device?: SortOrder
    browser?: SortOrder
    os?: SortOrder
    converted?: SortOrder
    conversionId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumConversionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ConversionStatus | EnumConversionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConversionStatus[] | ListEnumConversionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConversionStatus[] | ListEnumConversionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConversionStatusFilter<$PrismaModel> | $Enums.ConversionStatus
  }

  export type ClickRelationFilter = {
    is?: ClickWhereInput
    isNot?: ClickWhereInput
  }

  export type CommissionNullableRelationFilter = {
    is?: CommissionWhereInput | null
    isNot?: CommissionWhereInput | null
  }

  export type ConversionCountOrderByAggregateInput = {
    id?: SortOrder
    clickId?: SortOrder
    affiliateId?: SortOrder
    offerId?: SortOrder
    customerEmail?: SortOrder
    customerValue?: SortOrder
    commissionAmount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversionAvgOrderByAggregateInput = {
    customerValue?: SortOrder
    commissionAmount?: SortOrder
  }

  export type ConversionMaxOrderByAggregateInput = {
    id?: SortOrder
    clickId?: SortOrder
    affiliateId?: SortOrder
    offerId?: SortOrder
    customerEmail?: SortOrder
    customerValue?: SortOrder
    commissionAmount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversionMinOrderByAggregateInput = {
    id?: SortOrder
    clickId?: SortOrder
    affiliateId?: SortOrder
    offerId?: SortOrder
    customerEmail?: SortOrder
    customerValue?: SortOrder
    commissionAmount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversionSumOrderByAggregateInput = {
    customerValue?: SortOrder
    commissionAmount?: SortOrder
  }

  export type EnumConversionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConversionStatus | EnumConversionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConversionStatus[] | ListEnumConversionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConversionStatus[] | ListEnumConversionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConversionStatusWithAggregatesFilter<$PrismaModel> | $Enums.ConversionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConversionStatusFilter<$PrismaModel>
    _max?: NestedEnumConversionStatusFilter<$PrismaModel>
  }

  export type EnumCommissionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CommissionStatus | EnumCommissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CommissionStatus[] | ListEnumCommissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommissionStatus[] | ListEnumCommissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCommissionStatusFilter<$PrismaModel> | $Enums.CommissionStatus
  }

  export type ConversionRelationFilter = {
    is?: ConversionWhereInput
    isNot?: ConversionWhereInput
  }

  export type PayoutNullableRelationFilter = {
    is?: PayoutWhereInput | null
    isNot?: PayoutWhereInput | null
  }

  export type CommissionCountOrderByAggregateInput = {
    id?: SortOrder
    conversionId?: SortOrder
    affiliateId?: SortOrder
    payoutId?: SortOrder
    amount?: SortOrder
    rate?: SortOrder
    status?: SortOrder
    payoutDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommissionAvgOrderByAggregateInput = {
    amount?: SortOrder
    rate?: SortOrder
  }

  export type CommissionMaxOrderByAggregateInput = {
    id?: SortOrder
    conversionId?: SortOrder
    affiliateId?: SortOrder
    payoutId?: SortOrder
    amount?: SortOrder
    rate?: SortOrder
    status?: SortOrder
    payoutDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommissionMinOrderByAggregateInput = {
    id?: SortOrder
    conversionId?: SortOrder
    affiliateId?: SortOrder
    payoutId?: SortOrder
    amount?: SortOrder
    rate?: SortOrder
    status?: SortOrder
    payoutDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommissionSumOrderByAggregateInput = {
    amount?: SortOrder
    rate?: SortOrder
  }

  export type EnumCommissionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommissionStatus | EnumCommissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CommissionStatus[] | ListEnumCommissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommissionStatus[] | ListEnumCommissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCommissionStatusWithAggregatesFilter<$PrismaModel> | $Enums.CommissionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommissionStatusFilter<$PrismaModel>
    _max?: NestedEnumCommissionStatusFilter<$PrismaModel>
  }

  export type EnumPayoutStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PayoutStatus | EnumPayoutStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayoutStatusFilter<$PrismaModel> | $Enums.PayoutStatus
  }

  export type PayoutCountOrderByAggregateInput = {
    id?: SortOrder
    affiliateId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    status?: SortOrder
    referenceId?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayoutAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PayoutMaxOrderByAggregateInput = {
    id?: SortOrder
    affiliateId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    status?: SortOrder
    referenceId?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayoutMinOrderByAggregateInput = {
    id?: SortOrder
    affiliateId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    status?: SortOrder
    referenceId?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayoutSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPayoutStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayoutStatus | EnumPayoutStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayoutStatusWithAggregatesFilter<$PrismaModel> | $Enums.PayoutStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayoutStatusFilter<$PrismaModel>
    _max?: NestedEnumPayoutStatusFilter<$PrismaModel>
  }

  export type EnumCreativeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CreativeType | EnumCreativeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CreativeType[] | ListEnumCreativeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreativeType[] | ListEnumCreativeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCreativeTypeFilter<$PrismaModel> | $Enums.CreativeType
  }

  export type CreativeCountOrderByAggregateInput = {
    id?: SortOrder
    offerId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    size?: SortOrder
    format?: SortOrder
    url?: SortOrder
    downloadUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CreativeMaxOrderByAggregateInput = {
    id?: SortOrder
    offerId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    size?: SortOrder
    format?: SortOrder
    url?: SortOrder
    downloadUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CreativeMinOrderByAggregateInput = {
    id?: SortOrder
    offerId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    size?: SortOrder
    format?: SortOrder
    url?: SortOrder
    downloadUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCreativeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CreativeType | EnumCreativeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CreativeType[] | ListEnumCreativeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreativeType[] | ListEnumCreativeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCreativeTypeWithAggregatesFilter<$PrismaModel> | $Enums.CreativeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCreativeTypeFilter<$PrismaModel>
    _max?: NestedEnumCreativeTypeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumCouponStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CouponStatus | EnumCouponStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CouponStatus[] | ListEnumCouponStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CouponStatus[] | ListEnumCouponStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCouponStatusFilter<$PrismaModel> | $Enums.CouponStatus
  }

  export type CouponCountOrderByAggregateInput = {
    id?: SortOrder
    affiliateId?: SortOrder
    code?: SortOrder
    description?: SortOrder
    discount?: SortOrder
    validUntil?: SortOrder
    usage?: SortOrder
    maxUsage?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CouponAvgOrderByAggregateInput = {
    usage?: SortOrder
    maxUsage?: SortOrder
  }

  export type CouponMaxOrderByAggregateInput = {
    id?: SortOrder
    affiliateId?: SortOrder
    code?: SortOrder
    description?: SortOrder
    discount?: SortOrder
    validUntil?: SortOrder
    usage?: SortOrder
    maxUsage?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CouponMinOrderByAggregateInput = {
    id?: SortOrder
    affiliateId?: SortOrder
    code?: SortOrder
    description?: SortOrder
    discount?: SortOrder
    validUntil?: SortOrder
    usage?: SortOrder
    maxUsage?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CouponSumOrderByAggregateInput = {
    usage?: SortOrder
    maxUsage?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumCouponStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CouponStatus | EnumCouponStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CouponStatus[] | ListEnumCouponStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CouponStatus[] | ListEnumCouponStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCouponStatusWithAggregatesFilter<$PrismaModel> | $Enums.CouponStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCouponStatusFilter<$PrismaModel>
    _max?: NestedEnumCouponStatusFilter<$PrismaModel>
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    read?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type ActivityCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumWebhookStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WebhookStatus | EnumWebhookStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WebhookStatus[] | ListEnumWebhookStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WebhookStatus[] | ListEnumWebhookStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWebhookStatusFilter<$PrismaModel> | $Enums.WebhookStatus
  }

  export type WebhookCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    events?: SortOrder
    secret?: SortOrder
    status?: SortOrder
    lastTriggered?: SortOrder
    successRate?: SortOrder
    totalCalls?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebhookAvgOrderByAggregateInput = {
    successRate?: SortOrder
    totalCalls?: SortOrder
  }

  export type WebhookMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    status?: SortOrder
    lastTriggered?: SortOrder
    successRate?: SortOrder
    totalCalls?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebhookMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    secret?: SortOrder
    status?: SortOrder
    lastTriggered?: SortOrder
    successRate?: SortOrder
    totalCalls?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebhookSumOrderByAggregateInput = {
    successRate?: SortOrder
    totalCalls?: SortOrder
  }

  export type EnumWebhookStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WebhookStatus | EnumWebhookStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WebhookStatus[] | ListEnumWebhookStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WebhookStatus[] | ListEnumWebhookStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWebhookStatusWithAggregatesFilter<$PrismaModel> | $Enums.WebhookStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWebhookStatusFilter<$PrismaModel>
    _max?: NestedEnumWebhookStatusFilter<$PrismaModel>
  }

  export type EnumRuleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RuleType | EnumRuleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RuleType[] | ListEnumRuleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RuleType[] | ListEnumRuleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRuleTypeFilter<$PrismaModel> | $Enums.RuleType
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumRuleActionFilter<$PrismaModel = never> = {
    equals?: $Enums.RuleAction | EnumRuleActionFieldRefInput<$PrismaModel>
    in?: $Enums.RuleAction[] | ListEnumRuleActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.RuleAction[] | ListEnumRuleActionFieldRefInput<$PrismaModel>
    not?: NestedEnumRuleActionFilter<$PrismaModel> | $Enums.RuleAction
  }

  export type EnumRuleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RuleStatus | EnumRuleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RuleStatus[] | ListEnumRuleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RuleStatus[] | ListEnumRuleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRuleStatusFilter<$PrismaModel> | $Enums.RuleStatus
  }

  export type TrafficRuleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    conditions?: SortOrder
    action?: SortOrder
    status?: SortOrder
    hits?: SortOrder
    lastTriggered?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrafficRuleAvgOrderByAggregateInput = {
    hits?: SortOrder
  }

  export type TrafficRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    action?: SortOrder
    status?: SortOrder
    hits?: SortOrder
    lastTriggered?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrafficRuleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    action?: SortOrder
    status?: SortOrder
    hits?: SortOrder
    lastTriggered?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrafficRuleSumOrderByAggregateInput = {
    hits?: SortOrder
  }

  export type EnumRuleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RuleType | EnumRuleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RuleType[] | ListEnumRuleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RuleType[] | ListEnumRuleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRuleTypeWithAggregatesFilter<$PrismaModel> | $Enums.RuleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRuleTypeFilter<$PrismaModel>
    _max?: NestedEnumRuleTypeFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumRuleActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RuleAction | EnumRuleActionFieldRefInput<$PrismaModel>
    in?: $Enums.RuleAction[] | ListEnumRuleActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.RuleAction[] | ListEnumRuleActionFieldRefInput<$PrismaModel>
    not?: NestedEnumRuleActionWithAggregatesFilter<$PrismaModel> | $Enums.RuleAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRuleActionFilter<$PrismaModel>
    _max?: NestedEnumRuleActionFilter<$PrismaModel>
  }

  export type EnumRuleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RuleStatus | EnumRuleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RuleStatus[] | ListEnumRuleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RuleStatus[] | ListEnumRuleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRuleStatusWithAggregatesFilter<$PrismaModel> | $Enums.RuleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRuleStatusFilter<$PrismaModel>
    _max?: NestedEnumRuleStatusFilter<$PrismaModel>
  }

  export type AffiliateProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<AffiliateProfileCreateWithoutUserInput, AffiliateProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: AffiliateProfileCreateOrConnectWithoutUserInput
    connect?: AffiliateProfileWhereUniqueInput
  }

  export type AdminProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminProfileCreateWithoutUserInput, AdminProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminProfileCreateOrConnectWithoutUserInput
    connect?: AdminProfileWhereUniqueInput
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ActivityCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type AffiliateProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AffiliateProfileCreateWithoutUserInput, AffiliateProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: AffiliateProfileCreateOrConnectWithoutUserInput
    connect?: AffiliateProfileWhereUniqueInput
  }

  export type AdminProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminProfileCreateWithoutUserInput, AdminProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminProfileCreateOrConnectWithoutUserInput
    connect?: AdminProfileWhereUniqueInput
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ActivityUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AffiliateProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<AffiliateProfileCreateWithoutUserInput, AffiliateProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: AffiliateProfileCreateOrConnectWithoutUserInput
    upsert?: AffiliateProfileUpsertWithoutUserInput
    disconnect?: AffiliateProfileWhereInput | boolean
    delete?: AffiliateProfileWhereInput | boolean
    connect?: AffiliateProfileWhereUniqueInput
    update?: XOR<XOR<AffiliateProfileUpdateToOneWithWhereWithoutUserInput, AffiliateProfileUpdateWithoutUserInput>, AffiliateProfileUncheckedUpdateWithoutUserInput>
  }

  export type AdminProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminProfileCreateWithoutUserInput, AdminProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminProfileCreateOrConnectWithoutUserInput
    upsert?: AdminProfileUpsertWithoutUserInput
    disconnect?: AdminProfileWhereInput | boolean
    delete?: AdminProfileWhereInput | boolean
    connect?: AdminProfileWhereUniqueInput
    update?: XOR<XOR<AdminProfileUpdateToOneWithWhereWithoutUserInput, AdminProfileUpdateWithoutUserInput>, AdminProfileUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ActivityUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutUserInput | ActivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutUserInput | ActivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutUserInput | ActivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type AffiliateProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AffiliateProfileCreateWithoutUserInput, AffiliateProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: AffiliateProfileCreateOrConnectWithoutUserInput
    upsert?: AffiliateProfileUpsertWithoutUserInput
    disconnect?: AffiliateProfileWhereInput | boolean
    delete?: AffiliateProfileWhereInput | boolean
    connect?: AffiliateProfileWhereUniqueInput
    update?: XOR<XOR<AffiliateProfileUpdateToOneWithWhereWithoutUserInput, AffiliateProfileUpdateWithoutUserInput>, AffiliateProfileUncheckedUpdateWithoutUserInput>
  }

  export type AdminProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminProfileCreateWithoutUserInput, AdminProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminProfileCreateOrConnectWithoutUserInput
    upsert?: AdminProfileUpsertWithoutUserInput
    disconnect?: AdminProfileWhereInput | boolean
    delete?: AdminProfileWhereInput | boolean
    connect?: AdminProfileWhereUniqueInput
    update?: XOR<XOR<AdminProfileUpdateToOneWithWhereWithoutUserInput, AdminProfileUpdateWithoutUserInput>, AdminProfileUncheckedUpdateWithoutUserInput>
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ActivityUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput> | ActivityCreateWithoutUserInput[] | ActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityCreateOrConnectWithoutUserInput | ActivityCreateOrConnectWithoutUserInput[]
    upsert?: ActivityUpsertWithWhereUniqueWithoutUserInput | ActivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityCreateManyUserInputEnvelope
    set?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    disconnect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    delete?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    connect?: ActivityWhereUniqueInput | ActivityWhereUniqueInput[]
    update?: ActivityUpdateWithWhereUniqueWithoutUserInput | ActivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityUpdateManyWithWhereWithoutUserInput | ActivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutAffiliateProfileInput = {
    create?: XOR<UserCreateWithoutAffiliateProfileInput, UserUncheckedCreateWithoutAffiliateProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutAffiliateProfileInput
    connect?: UserWhereUniqueInput
  }

  export type ClickCreateNestedManyWithoutAffiliateInput = {
    create?: XOR<ClickCreateWithoutAffiliateInput, ClickUncheckedCreateWithoutAffiliateInput> | ClickCreateWithoutAffiliateInput[] | ClickUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: ClickCreateOrConnectWithoutAffiliateInput | ClickCreateOrConnectWithoutAffiliateInput[]
    createMany?: ClickCreateManyAffiliateInputEnvelope
    connect?: ClickWhereUniqueInput | ClickWhereUniqueInput[]
  }

  export type ConversionCreateNestedManyWithoutAffiliateInput = {
    create?: XOR<ConversionCreateWithoutAffiliateInput, ConversionUncheckedCreateWithoutAffiliateInput> | ConversionCreateWithoutAffiliateInput[] | ConversionUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: ConversionCreateOrConnectWithoutAffiliateInput | ConversionCreateOrConnectWithoutAffiliateInput[]
    createMany?: ConversionCreateManyAffiliateInputEnvelope
    connect?: ConversionWhereUniqueInput | ConversionWhereUniqueInput[]
  }

  export type CommissionCreateNestedManyWithoutAffiliateInput = {
    create?: XOR<CommissionCreateWithoutAffiliateInput, CommissionUncheckedCreateWithoutAffiliateInput> | CommissionCreateWithoutAffiliateInput[] | CommissionUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: CommissionCreateOrConnectWithoutAffiliateInput | CommissionCreateOrConnectWithoutAffiliateInput[]
    createMany?: CommissionCreateManyAffiliateInputEnvelope
    connect?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
  }

  export type PayoutCreateNestedManyWithoutAffiliateInput = {
    create?: XOR<PayoutCreateWithoutAffiliateInput, PayoutUncheckedCreateWithoutAffiliateInput> | PayoutCreateWithoutAffiliateInput[] | PayoutUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: PayoutCreateOrConnectWithoutAffiliateInput | PayoutCreateOrConnectWithoutAffiliateInput[]
    createMany?: PayoutCreateManyAffiliateInputEnvelope
    connect?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
  }

  export type AffiliateLinkCreateNestedManyWithoutAffiliateInput = {
    create?: XOR<AffiliateLinkCreateWithoutAffiliateInput, AffiliateLinkUncheckedCreateWithoutAffiliateInput> | AffiliateLinkCreateWithoutAffiliateInput[] | AffiliateLinkUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: AffiliateLinkCreateOrConnectWithoutAffiliateInput | AffiliateLinkCreateOrConnectWithoutAffiliateInput[]
    createMany?: AffiliateLinkCreateManyAffiliateInputEnvelope
    connect?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
  }

  export type CouponCreateNestedManyWithoutAffiliateInput = {
    create?: XOR<CouponCreateWithoutAffiliateInput, CouponUncheckedCreateWithoutAffiliateInput> | CouponCreateWithoutAffiliateInput[] | CouponUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: CouponCreateOrConnectWithoutAffiliateInput | CouponCreateOrConnectWithoutAffiliateInput[]
    createMany?: CouponCreateManyAffiliateInputEnvelope
    connect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
  }

  export type OfferApplicationCreateNestedManyWithoutAffiliateInput = {
    create?: XOR<OfferApplicationCreateWithoutAffiliateInput, OfferApplicationUncheckedCreateWithoutAffiliateInput> | OfferApplicationCreateWithoutAffiliateInput[] | OfferApplicationUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: OfferApplicationCreateOrConnectWithoutAffiliateInput | OfferApplicationCreateOrConnectWithoutAffiliateInput[]
    createMany?: OfferApplicationCreateManyAffiliateInputEnvelope
    connect?: OfferApplicationWhereUniqueInput | OfferApplicationWhereUniqueInput[]
  }

  export type ClickUncheckedCreateNestedManyWithoutAffiliateInput = {
    create?: XOR<ClickCreateWithoutAffiliateInput, ClickUncheckedCreateWithoutAffiliateInput> | ClickCreateWithoutAffiliateInput[] | ClickUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: ClickCreateOrConnectWithoutAffiliateInput | ClickCreateOrConnectWithoutAffiliateInput[]
    createMany?: ClickCreateManyAffiliateInputEnvelope
    connect?: ClickWhereUniqueInput | ClickWhereUniqueInput[]
  }

  export type ConversionUncheckedCreateNestedManyWithoutAffiliateInput = {
    create?: XOR<ConversionCreateWithoutAffiliateInput, ConversionUncheckedCreateWithoutAffiliateInput> | ConversionCreateWithoutAffiliateInput[] | ConversionUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: ConversionCreateOrConnectWithoutAffiliateInput | ConversionCreateOrConnectWithoutAffiliateInput[]
    createMany?: ConversionCreateManyAffiliateInputEnvelope
    connect?: ConversionWhereUniqueInput | ConversionWhereUniqueInput[]
  }

  export type CommissionUncheckedCreateNestedManyWithoutAffiliateInput = {
    create?: XOR<CommissionCreateWithoutAffiliateInput, CommissionUncheckedCreateWithoutAffiliateInput> | CommissionCreateWithoutAffiliateInput[] | CommissionUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: CommissionCreateOrConnectWithoutAffiliateInput | CommissionCreateOrConnectWithoutAffiliateInput[]
    createMany?: CommissionCreateManyAffiliateInputEnvelope
    connect?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
  }

  export type PayoutUncheckedCreateNestedManyWithoutAffiliateInput = {
    create?: XOR<PayoutCreateWithoutAffiliateInput, PayoutUncheckedCreateWithoutAffiliateInput> | PayoutCreateWithoutAffiliateInput[] | PayoutUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: PayoutCreateOrConnectWithoutAffiliateInput | PayoutCreateOrConnectWithoutAffiliateInput[]
    createMany?: PayoutCreateManyAffiliateInputEnvelope
    connect?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
  }

  export type AffiliateLinkUncheckedCreateNestedManyWithoutAffiliateInput = {
    create?: XOR<AffiliateLinkCreateWithoutAffiliateInput, AffiliateLinkUncheckedCreateWithoutAffiliateInput> | AffiliateLinkCreateWithoutAffiliateInput[] | AffiliateLinkUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: AffiliateLinkCreateOrConnectWithoutAffiliateInput | AffiliateLinkCreateOrConnectWithoutAffiliateInput[]
    createMany?: AffiliateLinkCreateManyAffiliateInputEnvelope
    connect?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
  }

  export type CouponUncheckedCreateNestedManyWithoutAffiliateInput = {
    create?: XOR<CouponCreateWithoutAffiliateInput, CouponUncheckedCreateWithoutAffiliateInput> | CouponCreateWithoutAffiliateInput[] | CouponUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: CouponCreateOrConnectWithoutAffiliateInput | CouponCreateOrConnectWithoutAffiliateInput[]
    createMany?: CouponCreateManyAffiliateInputEnvelope
    connect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
  }

  export type OfferApplicationUncheckedCreateNestedManyWithoutAffiliateInput = {
    create?: XOR<OfferApplicationCreateWithoutAffiliateInput, OfferApplicationUncheckedCreateWithoutAffiliateInput> | OfferApplicationCreateWithoutAffiliateInput[] | OfferApplicationUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: OfferApplicationCreateOrConnectWithoutAffiliateInput | OfferApplicationCreateOrConnectWithoutAffiliateInput[]
    createMany?: OfferApplicationCreateManyAffiliateInputEnvelope
    connect?: OfferApplicationWhereUniqueInput | OfferApplicationWhereUniqueInput[]
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type EnumAffiliateTierFieldUpdateOperationsInput = {
    set?: $Enums.AffiliateTier
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAffiliateProfileNestedInput = {
    create?: XOR<UserCreateWithoutAffiliateProfileInput, UserUncheckedCreateWithoutAffiliateProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutAffiliateProfileInput
    upsert?: UserUpsertWithoutAffiliateProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAffiliateProfileInput, UserUpdateWithoutAffiliateProfileInput>, UserUncheckedUpdateWithoutAffiliateProfileInput>
  }

  export type ClickUpdateManyWithoutAffiliateNestedInput = {
    create?: XOR<ClickCreateWithoutAffiliateInput, ClickUncheckedCreateWithoutAffiliateInput> | ClickCreateWithoutAffiliateInput[] | ClickUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: ClickCreateOrConnectWithoutAffiliateInput | ClickCreateOrConnectWithoutAffiliateInput[]
    upsert?: ClickUpsertWithWhereUniqueWithoutAffiliateInput | ClickUpsertWithWhereUniqueWithoutAffiliateInput[]
    createMany?: ClickCreateManyAffiliateInputEnvelope
    set?: ClickWhereUniqueInput | ClickWhereUniqueInput[]
    disconnect?: ClickWhereUniqueInput | ClickWhereUniqueInput[]
    delete?: ClickWhereUniqueInput | ClickWhereUniqueInput[]
    connect?: ClickWhereUniqueInput | ClickWhereUniqueInput[]
    update?: ClickUpdateWithWhereUniqueWithoutAffiliateInput | ClickUpdateWithWhereUniqueWithoutAffiliateInput[]
    updateMany?: ClickUpdateManyWithWhereWithoutAffiliateInput | ClickUpdateManyWithWhereWithoutAffiliateInput[]
    deleteMany?: ClickScalarWhereInput | ClickScalarWhereInput[]
  }

  export type ConversionUpdateManyWithoutAffiliateNestedInput = {
    create?: XOR<ConversionCreateWithoutAffiliateInput, ConversionUncheckedCreateWithoutAffiliateInput> | ConversionCreateWithoutAffiliateInput[] | ConversionUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: ConversionCreateOrConnectWithoutAffiliateInput | ConversionCreateOrConnectWithoutAffiliateInput[]
    upsert?: ConversionUpsertWithWhereUniqueWithoutAffiliateInput | ConversionUpsertWithWhereUniqueWithoutAffiliateInput[]
    createMany?: ConversionCreateManyAffiliateInputEnvelope
    set?: ConversionWhereUniqueInput | ConversionWhereUniqueInput[]
    disconnect?: ConversionWhereUniqueInput | ConversionWhereUniqueInput[]
    delete?: ConversionWhereUniqueInput | ConversionWhereUniqueInput[]
    connect?: ConversionWhereUniqueInput | ConversionWhereUniqueInput[]
    update?: ConversionUpdateWithWhereUniqueWithoutAffiliateInput | ConversionUpdateWithWhereUniqueWithoutAffiliateInput[]
    updateMany?: ConversionUpdateManyWithWhereWithoutAffiliateInput | ConversionUpdateManyWithWhereWithoutAffiliateInput[]
    deleteMany?: ConversionScalarWhereInput | ConversionScalarWhereInput[]
  }

  export type CommissionUpdateManyWithoutAffiliateNestedInput = {
    create?: XOR<CommissionCreateWithoutAffiliateInput, CommissionUncheckedCreateWithoutAffiliateInput> | CommissionCreateWithoutAffiliateInput[] | CommissionUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: CommissionCreateOrConnectWithoutAffiliateInput | CommissionCreateOrConnectWithoutAffiliateInput[]
    upsert?: CommissionUpsertWithWhereUniqueWithoutAffiliateInput | CommissionUpsertWithWhereUniqueWithoutAffiliateInput[]
    createMany?: CommissionCreateManyAffiliateInputEnvelope
    set?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    disconnect?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    delete?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    connect?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    update?: CommissionUpdateWithWhereUniqueWithoutAffiliateInput | CommissionUpdateWithWhereUniqueWithoutAffiliateInput[]
    updateMany?: CommissionUpdateManyWithWhereWithoutAffiliateInput | CommissionUpdateManyWithWhereWithoutAffiliateInput[]
    deleteMany?: CommissionScalarWhereInput | CommissionScalarWhereInput[]
  }

  export type PayoutUpdateManyWithoutAffiliateNestedInput = {
    create?: XOR<PayoutCreateWithoutAffiliateInput, PayoutUncheckedCreateWithoutAffiliateInput> | PayoutCreateWithoutAffiliateInput[] | PayoutUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: PayoutCreateOrConnectWithoutAffiliateInput | PayoutCreateOrConnectWithoutAffiliateInput[]
    upsert?: PayoutUpsertWithWhereUniqueWithoutAffiliateInput | PayoutUpsertWithWhereUniqueWithoutAffiliateInput[]
    createMany?: PayoutCreateManyAffiliateInputEnvelope
    set?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
    disconnect?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
    delete?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
    connect?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
    update?: PayoutUpdateWithWhereUniqueWithoutAffiliateInput | PayoutUpdateWithWhereUniqueWithoutAffiliateInput[]
    updateMany?: PayoutUpdateManyWithWhereWithoutAffiliateInput | PayoutUpdateManyWithWhereWithoutAffiliateInput[]
    deleteMany?: PayoutScalarWhereInput | PayoutScalarWhereInput[]
  }

  export type AffiliateLinkUpdateManyWithoutAffiliateNestedInput = {
    create?: XOR<AffiliateLinkCreateWithoutAffiliateInput, AffiliateLinkUncheckedCreateWithoutAffiliateInput> | AffiliateLinkCreateWithoutAffiliateInput[] | AffiliateLinkUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: AffiliateLinkCreateOrConnectWithoutAffiliateInput | AffiliateLinkCreateOrConnectWithoutAffiliateInput[]
    upsert?: AffiliateLinkUpsertWithWhereUniqueWithoutAffiliateInput | AffiliateLinkUpsertWithWhereUniqueWithoutAffiliateInput[]
    createMany?: AffiliateLinkCreateManyAffiliateInputEnvelope
    set?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
    disconnect?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
    delete?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
    connect?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
    update?: AffiliateLinkUpdateWithWhereUniqueWithoutAffiliateInput | AffiliateLinkUpdateWithWhereUniqueWithoutAffiliateInput[]
    updateMany?: AffiliateLinkUpdateManyWithWhereWithoutAffiliateInput | AffiliateLinkUpdateManyWithWhereWithoutAffiliateInput[]
    deleteMany?: AffiliateLinkScalarWhereInput | AffiliateLinkScalarWhereInput[]
  }

  export type CouponUpdateManyWithoutAffiliateNestedInput = {
    create?: XOR<CouponCreateWithoutAffiliateInput, CouponUncheckedCreateWithoutAffiliateInput> | CouponCreateWithoutAffiliateInput[] | CouponUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: CouponCreateOrConnectWithoutAffiliateInput | CouponCreateOrConnectWithoutAffiliateInput[]
    upsert?: CouponUpsertWithWhereUniqueWithoutAffiliateInput | CouponUpsertWithWhereUniqueWithoutAffiliateInput[]
    createMany?: CouponCreateManyAffiliateInputEnvelope
    set?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    disconnect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    delete?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    connect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    update?: CouponUpdateWithWhereUniqueWithoutAffiliateInput | CouponUpdateWithWhereUniqueWithoutAffiliateInput[]
    updateMany?: CouponUpdateManyWithWhereWithoutAffiliateInput | CouponUpdateManyWithWhereWithoutAffiliateInput[]
    deleteMany?: CouponScalarWhereInput | CouponScalarWhereInput[]
  }

  export type OfferApplicationUpdateManyWithoutAffiliateNestedInput = {
    create?: XOR<OfferApplicationCreateWithoutAffiliateInput, OfferApplicationUncheckedCreateWithoutAffiliateInput> | OfferApplicationCreateWithoutAffiliateInput[] | OfferApplicationUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: OfferApplicationCreateOrConnectWithoutAffiliateInput | OfferApplicationCreateOrConnectWithoutAffiliateInput[]
    upsert?: OfferApplicationUpsertWithWhereUniqueWithoutAffiliateInput | OfferApplicationUpsertWithWhereUniqueWithoutAffiliateInput[]
    createMany?: OfferApplicationCreateManyAffiliateInputEnvelope
    set?: OfferApplicationWhereUniqueInput | OfferApplicationWhereUniqueInput[]
    disconnect?: OfferApplicationWhereUniqueInput | OfferApplicationWhereUniqueInput[]
    delete?: OfferApplicationWhereUniqueInput | OfferApplicationWhereUniqueInput[]
    connect?: OfferApplicationWhereUniqueInput | OfferApplicationWhereUniqueInput[]
    update?: OfferApplicationUpdateWithWhereUniqueWithoutAffiliateInput | OfferApplicationUpdateWithWhereUniqueWithoutAffiliateInput[]
    updateMany?: OfferApplicationUpdateManyWithWhereWithoutAffiliateInput | OfferApplicationUpdateManyWithWhereWithoutAffiliateInput[]
    deleteMany?: OfferApplicationScalarWhereInput | OfferApplicationScalarWhereInput[]
  }

  export type ClickUncheckedUpdateManyWithoutAffiliateNestedInput = {
    create?: XOR<ClickCreateWithoutAffiliateInput, ClickUncheckedCreateWithoutAffiliateInput> | ClickCreateWithoutAffiliateInput[] | ClickUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: ClickCreateOrConnectWithoutAffiliateInput | ClickCreateOrConnectWithoutAffiliateInput[]
    upsert?: ClickUpsertWithWhereUniqueWithoutAffiliateInput | ClickUpsertWithWhereUniqueWithoutAffiliateInput[]
    createMany?: ClickCreateManyAffiliateInputEnvelope
    set?: ClickWhereUniqueInput | ClickWhereUniqueInput[]
    disconnect?: ClickWhereUniqueInput | ClickWhereUniqueInput[]
    delete?: ClickWhereUniqueInput | ClickWhereUniqueInput[]
    connect?: ClickWhereUniqueInput | ClickWhereUniqueInput[]
    update?: ClickUpdateWithWhereUniqueWithoutAffiliateInput | ClickUpdateWithWhereUniqueWithoutAffiliateInput[]
    updateMany?: ClickUpdateManyWithWhereWithoutAffiliateInput | ClickUpdateManyWithWhereWithoutAffiliateInput[]
    deleteMany?: ClickScalarWhereInput | ClickScalarWhereInput[]
  }

  export type ConversionUncheckedUpdateManyWithoutAffiliateNestedInput = {
    create?: XOR<ConversionCreateWithoutAffiliateInput, ConversionUncheckedCreateWithoutAffiliateInput> | ConversionCreateWithoutAffiliateInput[] | ConversionUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: ConversionCreateOrConnectWithoutAffiliateInput | ConversionCreateOrConnectWithoutAffiliateInput[]
    upsert?: ConversionUpsertWithWhereUniqueWithoutAffiliateInput | ConversionUpsertWithWhereUniqueWithoutAffiliateInput[]
    createMany?: ConversionCreateManyAffiliateInputEnvelope
    set?: ConversionWhereUniqueInput | ConversionWhereUniqueInput[]
    disconnect?: ConversionWhereUniqueInput | ConversionWhereUniqueInput[]
    delete?: ConversionWhereUniqueInput | ConversionWhereUniqueInput[]
    connect?: ConversionWhereUniqueInput | ConversionWhereUniqueInput[]
    update?: ConversionUpdateWithWhereUniqueWithoutAffiliateInput | ConversionUpdateWithWhereUniqueWithoutAffiliateInput[]
    updateMany?: ConversionUpdateManyWithWhereWithoutAffiliateInput | ConversionUpdateManyWithWhereWithoutAffiliateInput[]
    deleteMany?: ConversionScalarWhereInput | ConversionScalarWhereInput[]
  }

  export type CommissionUncheckedUpdateManyWithoutAffiliateNestedInput = {
    create?: XOR<CommissionCreateWithoutAffiliateInput, CommissionUncheckedCreateWithoutAffiliateInput> | CommissionCreateWithoutAffiliateInput[] | CommissionUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: CommissionCreateOrConnectWithoutAffiliateInput | CommissionCreateOrConnectWithoutAffiliateInput[]
    upsert?: CommissionUpsertWithWhereUniqueWithoutAffiliateInput | CommissionUpsertWithWhereUniqueWithoutAffiliateInput[]
    createMany?: CommissionCreateManyAffiliateInputEnvelope
    set?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    disconnect?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    delete?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    connect?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    update?: CommissionUpdateWithWhereUniqueWithoutAffiliateInput | CommissionUpdateWithWhereUniqueWithoutAffiliateInput[]
    updateMany?: CommissionUpdateManyWithWhereWithoutAffiliateInput | CommissionUpdateManyWithWhereWithoutAffiliateInput[]
    deleteMany?: CommissionScalarWhereInput | CommissionScalarWhereInput[]
  }

  export type PayoutUncheckedUpdateManyWithoutAffiliateNestedInput = {
    create?: XOR<PayoutCreateWithoutAffiliateInput, PayoutUncheckedCreateWithoutAffiliateInput> | PayoutCreateWithoutAffiliateInput[] | PayoutUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: PayoutCreateOrConnectWithoutAffiliateInput | PayoutCreateOrConnectWithoutAffiliateInput[]
    upsert?: PayoutUpsertWithWhereUniqueWithoutAffiliateInput | PayoutUpsertWithWhereUniqueWithoutAffiliateInput[]
    createMany?: PayoutCreateManyAffiliateInputEnvelope
    set?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
    disconnect?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
    delete?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
    connect?: PayoutWhereUniqueInput | PayoutWhereUniqueInput[]
    update?: PayoutUpdateWithWhereUniqueWithoutAffiliateInput | PayoutUpdateWithWhereUniqueWithoutAffiliateInput[]
    updateMany?: PayoutUpdateManyWithWhereWithoutAffiliateInput | PayoutUpdateManyWithWhereWithoutAffiliateInput[]
    deleteMany?: PayoutScalarWhereInput | PayoutScalarWhereInput[]
  }

  export type AffiliateLinkUncheckedUpdateManyWithoutAffiliateNestedInput = {
    create?: XOR<AffiliateLinkCreateWithoutAffiliateInput, AffiliateLinkUncheckedCreateWithoutAffiliateInput> | AffiliateLinkCreateWithoutAffiliateInput[] | AffiliateLinkUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: AffiliateLinkCreateOrConnectWithoutAffiliateInput | AffiliateLinkCreateOrConnectWithoutAffiliateInput[]
    upsert?: AffiliateLinkUpsertWithWhereUniqueWithoutAffiliateInput | AffiliateLinkUpsertWithWhereUniqueWithoutAffiliateInput[]
    createMany?: AffiliateLinkCreateManyAffiliateInputEnvelope
    set?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
    disconnect?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
    delete?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
    connect?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
    update?: AffiliateLinkUpdateWithWhereUniqueWithoutAffiliateInput | AffiliateLinkUpdateWithWhereUniqueWithoutAffiliateInput[]
    updateMany?: AffiliateLinkUpdateManyWithWhereWithoutAffiliateInput | AffiliateLinkUpdateManyWithWhereWithoutAffiliateInput[]
    deleteMany?: AffiliateLinkScalarWhereInput | AffiliateLinkScalarWhereInput[]
  }

  export type CouponUncheckedUpdateManyWithoutAffiliateNestedInput = {
    create?: XOR<CouponCreateWithoutAffiliateInput, CouponUncheckedCreateWithoutAffiliateInput> | CouponCreateWithoutAffiliateInput[] | CouponUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: CouponCreateOrConnectWithoutAffiliateInput | CouponCreateOrConnectWithoutAffiliateInput[]
    upsert?: CouponUpsertWithWhereUniqueWithoutAffiliateInput | CouponUpsertWithWhereUniqueWithoutAffiliateInput[]
    createMany?: CouponCreateManyAffiliateInputEnvelope
    set?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    disconnect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    delete?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    connect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    update?: CouponUpdateWithWhereUniqueWithoutAffiliateInput | CouponUpdateWithWhereUniqueWithoutAffiliateInput[]
    updateMany?: CouponUpdateManyWithWhereWithoutAffiliateInput | CouponUpdateManyWithWhereWithoutAffiliateInput[]
    deleteMany?: CouponScalarWhereInput | CouponScalarWhereInput[]
  }

  export type OfferApplicationUncheckedUpdateManyWithoutAffiliateNestedInput = {
    create?: XOR<OfferApplicationCreateWithoutAffiliateInput, OfferApplicationUncheckedCreateWithoutAffiliateInput> | OfferApplicationCreateWithoutAffiliateInput[] | OfferApplicationUncheckedCreateWithoutAffiliateInput[]
    connectOrCreate?: OfferApplicationCreateOrConnectWithoutAffiliateInput | OfferApplicationCreateOrConnectWithoutAffiliateInput[]
    upsert?: OfferApplicationUpsertWithWhereUniqueWithoutAffiliateInput | OfferApplicationUpsertWithWhereUniqueWithoutAffiliateInput[]
    createMany?: OfferApplicationCreateManyAffiliateInputEnvelope
    set?: OfferApplicationWhereUniqueInput | OfferApplicationWhereUniqueInput[]
    disconnect?: OfferApplicationWhereUniqueInput | OfferApplicationWhereUniqueInput[]
    delete?: OfferApplicationWhereUniqueInput | OfferApplicationWhereUniqueInput[]
    connect?: OfferApplicationWhereUniqueInput | OfferApplicationWhereUniqueInput[]
    update?: OfferApplicationUpdateWithWhereUniqueWithoutAffiliateInput | OfferApplicationUpdateWithWhereUniqueWithoutAffiliateInput[]
    updateMany?: OfferApplicationUpdateManyWithWhereWithoutAffiliateInput | OfferApplicationUpdateManyWithWhereWithoutAffiliateInput[]
    deleteMany?: OfferApplicationScalarWhereInput | OfferApplicationScalarWhereInput[]
  }

  export type AdminProfileCreatepermissionsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutAdminProfileInput = {
    create?: XOR<UserCreateWithoutAdminProfileInput, UserUncheckedCreateWithoutAdminProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminProfileInput
    connect?: UserWhereUniqueInput
  }

  export type AdminProfileUpdatepermissionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutAdminProfileNestedInput = {
    create?: XOR<UserCreateWithoutAdminProfileInput, UserUncheckedCreateWithoutAdminProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminProfileInput
    upsert?: UserUpsertWithoutAdminProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminProfileInput, UserUpdateWithoutAdminProfileInput>, UserUncheckedUpdateWithoutAdminProfileInput>
  }

  export type OfferApplicationCreateNestedManyWithoutOfferInput = {
    create?: XOR<OfferApplicationCreateWithoutOfferInput, OfferApplicationUncheckedCreateWithoutOfferInput> | OfferApplicationCreateWithoutOfferInput[] | OfferApplicationUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: OfferApplicationCreateOrConnectWithoutOfferInput | OfferApplicationCreateOrConnectWithoutOfferInput[]
    createMany?: OfferApplicationCreateManyOfferInputEnvelope
    connect?: OfferApplicationWhereUniqueInput | OfferApplicationWhereUniqueInput[]
  }

  export type ConversionCreateNestedManyWithoutOfferInput = {
    create?: XOR<ConversionCreateWithoutOfferInput, ConversionUncheckedCreateWithoutOfferInput> | ConversionCreateWithoutOfferInput[] | ConversionUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: ConversionCreateOrConnectWithoutOfferInput | ConversionCreateOrConnectWithoutOfferInput[]
    createMany?: ConversionCreateManyOfferInputEnvelope
    connect?: ConversionWhereUniqueInput | ConversionWhereUniqueInput[]
  }

  export type AffiliateLinkCreateNestedManyWithoutOfferInput = {
    create?: XOR<AffiliateLinkCreateWithoutOfferInput, AffiliateLinkUncheckedCreateWithoutOfferInput> | AffiliateLinkCreateWithoutOfferInput[] | AffiliateLinkUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: AffiliateLinkCreateOrConnectWithoutOfferInput | AffiliateLinkCreateOrConnectWithoutOfferInput[]
    createMany?: AffiliateLinkCreateManyOfferInputEnvelope
    connect?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
  }

  export type CreativeCreateNestedManyWithoutOfferInput = {
    create?: XOR<CreativeCreateWithoutOfferInput, CreativeUncheckedCreateWithoutOfferInput> | CreativeCreateWithoutOfferInput[] | CreativeUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: CreativeCreateOrConnectWithoutOfferInput | CreativeCreateOrConnectWithoutOfferInput[]
    createMany?: CreativeCreateManyOfferInputEnvelope
    connect?: CreativeWhereUniqueInput | CreativeWhereUniqueInput[]
  }

  export type OfferApplicationUncheckedCreateNestedManyWithoutOfferInput = {
    create?: XOR<OfferApplicationCreateWithoutOfferInput, OfferApplicationUncheckedCreateWithoutOfferInput> | OfferApplicationCreateWithoutOfferInput[] | OfferApplicationUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: OfferApplicationCreateOrConnectWithoutOfferInput | OfferApplicationCreateOrConnectWithoutOfferInput[]
    createMany?: OfferApplicationCreateManyOfferInputEnvelope
    connect?: OfferApplicationWhereUniqueInput | OfferApplicationWhereUniqueInput[]
  }

  export type ConversionUncheckedCreateNestedManyWithoutOfferInput = {
    create?: XOR<ConversionCreateWithoutOfferInput, ConversionUncheckedCreateWithoutOfferInput> | ConversionCreateWithoutOfferInput[] | ConversionUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: ConversionCreateOrConnectWithoutOfferInput | ConversionCreateOrConnectWithoutOfferInput[]
    createMany?: ConversionCreateManyOfferInputEnvelope
    connect?: ConversionWhereUniqueInput | ConversionWhereUniqueInput[]
  }

  export type AffiliateLinkUncheckedCreateNestedManyWithoutOfferInput = {
    create?: XOR<AffiliateLinkCreateWithoutOfferInput, AffiliateLinkUncheckedCreateWithoutOfferInput> | AffiliateLinkCreateWithoutOfferInput[] | AffiliateLinkUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: AffiliateLinkCreateOrConnectWithoutOfferInput | AffiliateLinkCreateOrConnectWithoutOfferInput[]
    createMany?: AffiliateLinkCreateManyOfferInputEnvelope
    connect?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
  }

  export type CreativeUncheckedCreateNestedManyWithoutOfferInput = {
    create?: XOR<CreativeCreateWithoutOfferInput, CreativeUncheckedCreateWithoutOfferInput> | CreativeCreateWithoutOfferInput[] | CreativeUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: CreativeCreateOrConnectWithoutOfferInput | CreativeCreateOrConnectWithoutOfferInput[]
    createMany?: CreativeCreateManyOfferInputEnvelope
    connect?: CreativeWhereUniqueInput | CreativeWhereUniqueInput[]
  }

  export type EnumOfferStatusFieldUpdateOperationsInput = {
    set?: $Enums.OfferStatus
  }

  export type OfferApplicationUpdateManyWithoutOfferNestedInput = {
    create?: XOR<OfferApplicationCreateWithoutOfferInput, OfferApplicationUncheckedCreateWithoutOfferInput> | OfferApplicationCreateWithoutOfferInput[] | OfferApplicationUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: OfferApplicationCreateOrConnectWithoutOfferInput | OfferApplicationCreateOrConnectWithoutOfferInput[]
    upsert?: OfferApplicationUpsertWithWhereUniqueWithoutOfferInput | OfferApplicationUpsertWithWhereUniqueWithoutOfferInput[]
    createMany?: OfferApplicationCreateManyOfferInputEnvelope
    set?: OfferApplicationWhereUniqueInput | OfferApplicationWhereUniqueInput[]
    disconnect?: OfferApplicationWhereUniqueInput | OfferApplicationWhereUniqueInput[]
    delete?: OfferApplicationWhereUniqueInput | OfferApplicationWhereUniqueInput[]
    connect?: OfferApplicationWhereUniqueInput | OfferApplicationWhereUniqueInput[]
    update?: OfferApplicationUpdateWithWhereUniqueWithoutOfferInput | OfferApplicationUpdateWithWhereUniqueWithoutOfferInput[]
    updateMany?: OfferApplicationUpdateManyWithWhereWithoutOfferInput | OfferApplicationUpdateManyWithWhereWithoutOfferInput[]
    deleteMany?: OfferApplicationScalarWhereInput | OfferApplicationScalarWhereInput[]
  }

  export type ConversionUpdateManyWithoutOfferNestedInput = {
    create?: XOR<ConversionCreateWithoutOfferInput, ConversionUncheckedCreateWithoutOfferInput> | ConversionCreateWithoutOfferInput[] | ConversionUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: ConversionCreateOrConnectWithoutOfferInput | ConversionCreateOrConnectWithoutOfferInput[]
    upsert?: ConversionUpsertWithWhereUniqueWithoutOfferInput | ConversionUpsertWithWhereUniqueWithoutOfferInput[]
    createMany?: ConversionCreateManyOfferInputEnvelope
    set?: ConversionWhereUniqueInput | ConversionWhereUniqueInput[]
    disconnect?: ConversionWhereUniqueInput | ConversionWhereUniqueInput[]
    delete?: ConversionWhereUniqueInput | ConversionWhereUniqueInput[]
    connect?: ConversionWhereUniqueInput | ConversionWhereUniqueInput[]
    update?: ConversionUpdateWithWhereUniqueWithoutOfferInput | ConversionUpdateWithWhereUniqueWithoutOfferInput[]
    updateMany?: ConversionUpdateManyWithWhereWithoutOfferInput | ConversionUpdateManyWithWhereWithoutOfferInput[]
    deleteMany?: ConversionScalarWhereInput | ConversionScalarWhereInput[]
  }

  export type AffiliateLinkUpdateManyWithoutOfferNestedInput = {
    create?: XOR<AffiliateLinkCreateWithoutOfferInput, AffiliateLinkUncheckedCreateWithoutOfferInput> | AffiliateLinkCreateWithoutOfferInput[] | AffiliateLinkUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: AffiliateLinkCreateOrConnectWithoutOfferInput | AffiliateLinkCreateOrConnectWithoutOfferInput[]
    upsert?: AffiliateLinkUpsertWithWhereUniqueWithoutOfferInput | AffiliateLinkUpsertWithWhereUniqueWithoutOfferInput[]
    createMany?: AffiliateLinkCreateManyOfferInputEnvelope
    set?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
    disconnect?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
    delete?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
    connect?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
    update?: AffiliateLinkUpdateWithWhereUniqueWithoutOfferInput | AffiliateLinkUpdateWithWhereUniqueWithoutOfferInput[]
    updateMany?: AffiliateLinkUpdateManyWithWhereWithoutOfferInput | AffiliateLinkUpdateManyWithWhereWithoutOfferInput[]
    deleteMany?: AffiliateLinkScalarWhereInput | AffiliateLinkScalarWhereInput[]
  }

  export type CreativeUpdateManyWithoutOfferNestedInput = {
    create?: XOR<CreativeCreateWithoutOfferInput, CreativeUncheckedCreateWithoutOfferInput> | CreativeCreateWithoutOfferInput[] | CreativeUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: CreativeCreateOrConnectWithoutOfferInput | CreativeCreateOrConnectWithoutOfferInput[]
    upsert?: CreativeUpsertWithWhereUniqueWithoutOfferInput | CreativeUpsertWithWhereUniqueWithoutOfferInput[]
    createMany?: CreativeCreateManyOfferInputEnvelope
    set?: CreativeWhereUniqueInput | CreativeWhereUniqueInput[]
    disconnect?: CreativeWhereUniqueInput | CreativeWhereUniqueInput[]
    delete?: CreativeWhereUniqueInput | CreativeWhereUniqueInput[]
    connect?: CreativeWhereUniqueInput | CreativeWhereUniqueInput[]
    update?: CreativeUpdateWithWhereUniqueWithoutOfferInput | CreativeUpdateWithWhereUniqueWithoutOfferInput[]
    updateMany?: CreativeUpdateManyWithWhereWithoutOfferInput | CreativeUpdateManyWithWhereWithoutOfferInput[]
    deleteMany?: CreativeScalarWhereInput | CreativeScalarWhereInput[]
  }

  export type OfferApplicationUncheckedUpdateManyWithoutOfferNestedInput = {
    create?: XOR<OfferApplicationCreateWithoutOfferInput, OfferApplicationUncheckedCreateWithoutOfferInput> | OfferApplicationCreateWithoutOfferInput[] | OfferApplicationUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: OfferApplicationCreateOrConnectWithoutOfferInput | OfferApplicationCreateOrConnectWithoutOfferInput[]
    upsert?: OfferApplicationUpsertWithWhereUniqueWithoutOfferInput | OfferApplicationUpsertWithWhereUniqueWithoutOfferInput[]
    createMany?: OfferApplicationCreateManyOfferInputEnvelope
    set?: OfferApplicationWhereUniqueInput | OfferApplicationWhereUniqueInput[]
    disconnect?: OfferApplicationWhereUniqueInput | OfferApplicationWhereUniqueInput[]
    delete?: OfferApplicationWhereUniqueInput | OfferApplicationWhereUniqueInput[]
    connect?: OfferApplicationWhereUniqueInput | OfferApplicationWhereUniqueInput[]
    update?: OfferApplicationUpdateWithWhereUniqueWithoutOfferInput | OfferApplicationUpdateWithWhereUniqueWithoutOfferInput[]
    updateMany?: OfferApplicationUpdateManyWithWhereWithoutOfferInput | OfferApplicationUpdateManyWithWhereWithoutOfferInput[]
    deleteMany?: OfferApplicationScalarWhereInput | OfferApplicationScalarWhereInput[]
  }

  export type ConversionUncheckedUpdateManyWithoutOfferNestedInput = {
    create?: XOR<ConversionCreateWithoutOfferInput, ConversionUncheckedCreateWithoutOfferInput> | ConversionCreateWithoutOfferInput[] | ConversionUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: ConversionCreateOrConnectWithoutOfferInput | ConversionCreateOrConnectWithoutOfferInput[]
    upsert?: ConversionUpsertWithWhereUniqueWithoutOfferInput | ConversionUpsertWithWhereUniqueWithoutOfferInput[]
    createMany?: ConversionCreateManyOfferInputEnvelope
    set?: ConversionWhereUniqueInput | ConversionWhereUniqueInput[]
    disconnect?: ConversionWhereUniqueInput | ConversionWhereUniqueInput[]
    delete?: ConversionWhereUniqueInput | ConversionWhereUniqueInput[]
    connect?: ConversionWhereUniqueInput | ConversionWhereUniqueInput[]
    update?: ConversionUpdateWithWhereUniqueWithoutOfferInput | ConversionUpdateWithWhereUniqueWithoutOfferInput[]
    updateMany?: ConversionUpdateManyWithWhereWithoutOfferInput | ConversionUpdateManyWithWhereWithoutOfferInput[]
    deleteMany?: ConversionScalarWhereInput | ConversionScalarWhereInput[]
  }

  export type AffiliateLinkUncheckedUpdateManyWithoutOfferNestedInput = {
    create?: XOR<AffiliateLinkCreateWithoutOfferInput, AffiliateLinkUncheckedCreateWithoutOfferInput> | AffiliateLinkCreateWithoutOfferInput[] | AffiliateLinkUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: AffiliateLinkCreateOrConnectWithoutOfferInput | AffiliateLinkCreateOrConnectWithoutOfferInput[]
    upsert?: AffiliateLinkUpsertWithWhereUniqueWithoutOfferInput | AffiliateLinkUpsertWithWhereUniqueWithoutOfferInput[]
    createMany?: AffiliateLinkCreateManyOfferInputEnvelope
    set?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
    disconnect?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
    delete?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
    connect?: AffiliateLinkWhereUniqueInput | AffiliateLinkWhereUniqueInput[]
    update?: AffiliateLinkUpdateWithWhereUniqueWithoutOfferInput | AffiliateLinkUpdateWithWhereUniqueWithoutOfferInput[]
    updateMany?: AffiliateLinkUpdateManyWithWhereWithoutOfferInput | AffiliateLinkUpdateManyWithWhereWithoutOfferInput[]
    deleteMany?: AffiliateLinkScalarWhereInput | AffiliateLinkScalarWhereInput[]
  }

  export type CreativeUncheckedUpdateManyWithoutOfferNestedInput = {
    create?: XOR<CreativeCreateWithoutOfferInput, CreativeUncheckedCreateWithoutOfferInput> | CreativeCreateWithoutOfferInput[] | CreativeUncheckedCreateWithoutOfferInput[]
    connectOrCreate?: CreativeCreateOrConnectWithoutOfferInput | CreativeCreateOrConnectWithoutOfferInput[]
    upsert?: CreativeUpsertWithWhereUniqueWithoutOfferInput | CreativeUpsertWithWhereUniqueWithoutOfferInput[]
    createMany?: CreativeCreateManyOfferInputEnvelope
    set?: CreativeWhereUniqueInput | CreativeWhereUniqueInput[]
    disconnect?: CreativeWhereUniqueInput | CreativeWhereUniqueInput[]
    delete?: CreativeWhereUniqueInput | CreativeWhereUniqueInput[]
    connect?: CreativeWhereUniqueInput | CreativeWhereUniqueInput[]
    update?: CreativeUpdateWithWhereUniqueWithoutOfferInput | CreativeUpdateWithWhereUniqueWithoutOfferInput[]
    updateMany?: CreativeUpdateManyWithWhereWithoutOfferInput | CreativeUpdateManyWithWhereWithoutOfferInput[]
    deleteMany?: CreativeScalarWhereInput | CreativeScalarWhereInput[]
  }

  export type AffiliateProfileCreateNestedOneWithoutApplicationsInput = {
    create?: XOR<AffiliateProfileCreateWithoutApplicationsInput, AffiliateProfileUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: AffiliateProfileCreateOrConnectWithoutApplicationsInput
    connect?: AffiliateProfileWhereUniqueInput
  }

  export type OfferCreateNestedOneWithoutApplicationsInput = {
    create?: XOR<OfferCreateWithoutApplicationsInput, OfferUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: OfferCreateOrConnectWithoutApplicationsInput
    connect?: OfferWhereUniqueInput
  }

  export type EnumApplicationStatusFieldUpdateOperationsInput = {
    set?: $Enums.ApplicationStatus
  }

  export type AffiliateProfileUpdateOneRequiredWithoutApplicationsNestedInput = {
    create?: XOR<AffiliateProfileCreateWithoutApplicationsInput, AffiliateProfileUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: AffiliateProfileCreateOrConnectWithoutApplicationsInput
    upsert?: AffiliateProfileUpsertWithoutApplicationsInput
    connect?: AffiliateProfileWhereUniqueInput
    update?: XOR<XOR<AffiliateProfileUpdateToOneWithWhereWithoutApplicationsInput, AffiliateProfileUpdateWithoutApplicationsInput>, AffiliateProfileUncheckedUpdateWithoutApplicationsInput>
  }

  export type OfferUpdateOneRequiredWithoutApplicationsNestedInput = {
    create?: XOR<OfferCreateWithoutApplicationsInput, OfferUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: OfferCreateOrConnectWithoutApplicationsInput
    upsert?: OfferUpsertWithoutApplicationsInput
    connect?: OfferWhereUniqueInput
    update?: XOR<XOR<OfferUpdateToOneWithWhereWithoutApplicationsInput, OfferUpdateWithoutApplicationsInput>, OfferUncheckedUpdateWithoutApplicationsInput>
  }

  export type AffiliateProfileCreateNestedOneWithoutLinksInput = {
    create?: XOR<AffiliateProfileCreateWithoutLinksInput, AffiliateProfileUncheckedCreateWithoutLinksInput>
    connectOrCreate?: AffiliateProfileCreateOrConnectWithoutLinksInput
    connect?: AffiliateProfileWhereUniqueInput
  }

  export type OfferCreateNestedOneWithoutLinksInput = {
    create?: XOR<OfferCreateWithoutLinksInput, OfferUncheckedCreateWithoutLinksInput>
    connectOrCreate?: OfferCreateOrConnectWithoutLinksInput
    connect?: OfferWhereUniqueInput
  }

  export type ClickCreateNestedManyWithoutLinkInput = {
    create?: XOR<ClickCreateWithoutLinkInput, ClickUncheckedCreateWithoutLinkInput> | ClickCreateWithoutLinkInput[] | ClickUncheckedCreateWithoutLinkInput[]
    connectOrCreate?: ClickCreateOrConnectWithoutLinkInput | ClickCreateOrConnectWithoutLinkInput[]
    createMany?: ClickCreateManyLinkInputEnvelope
    connect?: ClickWhereUniqueInput | ClickWhereUniqueInput[]
  }

  export type ClickUncheckedCreateNestedManyWithoutLinkInput = {
    create?: XOR<ClickCreateWithoutLinkInput, ClickUncheckedCreateWithoutLinkInput> | ClickCreateWithoutLinkInput[] | ClickUncheckedCreateWithoutLinkInput[]
    connectOrCreate?: ClickCreateOrConnectWithoutLinkInput | ClickCreateOrConnectWithoutLinkInput[]
    createMany?: ClickCreateManyLinkInputEnvelope
    connect?: ClickWhereUniqueInput | ClickWhereUniqueInput[]
  }

  export type AffiliateProfileUpdateOneRequiredWithoutLinksNestedInput = {
    create?: XOR<AffiliateProfileCreateWithoutLinksInput, AffiliateProfileUncheckedCreateWithoutLinksInput>
    connectOrCreate?: AffiliateProfileCreateOrConnectWithoutLinksInput
    upsert?: AffiliateProfileUpsertWithoutLinksInput
    connect?: AffiliateProfileWhereUniqueInput
    update?: XOR<XOR<AffiliateProfileUpdateToOneWithWhereWithoutLinksInput, AffiliateProfileUpdateWithoutLinksInput>, AffiliateProfileUncheckedUpdateWithoutLinksInput>
  }

  export type OfferUpdateOneWithoutLinksNestedInput = {
    create?: XOR<OfferCreateWithoutLinksInput, OfferUncheckedCreateWithoutLinksInput>
    connectOrCreate?: OfferCreateOrConnectWithoutLinksInput
    upsert?: OfferUpsertWithoutLinksInput
    disconnect?: OfferWhereInput | boolean
    delete?: OfferWhereInput | boolean
    connect?: OfferWhereUniqueInput
    update?: XOR<XOR<OfferUpdateToOneWithWhereWithoutLinksInput, OfferUpdateWithoutLinksInput>, OfferUncheckedUpdateWithoutLinksInput>
  }

  export type ClickUpdateManyWithoutLinkNestedInput = {
    create?: XOR<ClickCreateWithoutLinkInput, ClickUncheckedCreateWithoutLinkInput> | ClickCreateWithoutLinkInput[] | ClickUncheckedCreateWithoutLinkInput[]
    connectOrCreate?: ClickCreateOrConnectWithoutLinkInput | ClickCreateOrConnectWithoutLinkInput[]
    upsert?: ClickUpsertWithWhereUniqueWithoutLinkInput | ClickUpsertWithWhereUniqueWithoutLinkInput[]
    createMany?: ClickCreateManyLinkInputEnvelope
    set?: ClickWhereUniqueInput | ClickWhereUniqueInput[]
    disconnect?: ClickWhereUniqueInput | ClickWhereUniqueInput[]
    delete?: ClickWhereUniqueInput | ClickWhereUniqueInput[]
    connect?: ClickWhereUniqueInput | ClickWhereUniqueInput[]
    update?: ClickUpdateWithWhereUniqueWithoutLinkInput | ClickUpdateWithWhereUniqueWithoutLinkInput[]
    updateMany?: ClickUpdateManyWithWhereWithoutLinkInput | ClickUpdateManyWithWhereWithoutLinkInput[]
    deleteMany?: ClickScalarWhereInput | ClickScalarWhereInput[]
  }

  export type ClickUncheckedUpdateManyWithoutLinkNestedInput = {
    create?: XOR<ClickCreateWithoutLinkInput, ClickUncheckedCreateWithoutLinkInput> | ClickCreateWithoutLinkInput[] | ClickUncheckedCreateWithoutLinkInput[]
    connectOrCreate?: ClickCreateOrConnectWithoutLinkInput | ClickCreateOrConnectWithoutLinkInput[]
    upsert?: ClickUpsertWithWhereUniqueWithoutLinkInput | ClickUpsertWithWhereUniqueWithoutLinkInput[]
    createMany?: ClickCreateManyLinkInputEnvelope
    set?: ClickWhereUniqueInput | ClickWhereUniqueInput[]
    disconnect?: ClickWhereUniqueInput | ClickWhereUniqueInput[]
    delete?: ClickWhereUniqueInput | ClickWhereUniqueInput[]
    connect?: ClickWhereUniqueInput | ClickWhereUniqueInput[]
    update?: ClickUpdateWithWhereUniqueWithoutLinkInput | ClickUpdateWithWhereUniqueWithoutLinkInput[]
    updateMany?: ClickUpdateManyWithWhereWithoutLinkInput | ClickUpdateManyWithWhereWithoutLinkInput[]
    deleteMany?: ClickScalarWhereInput | ClickScalarWhereInput[]
  }

  export type AffiliateLinkCreateNestedOneWithoutClickRecordsInput = {
    create?: XOR<AffiliateLinkCreateWithoutClickRecordsInput, AffiliateLinkUncheckedCreateWithoutClickRecordsInput>
    connectOrCreate?: AffiliateLinkCreateOrConnectWithoutClickRecordsInput
    connect?: AffiliateLinkWhereUniqueInput
  }

  export type AffiliateProfileCreateNestedOneWithoutClicksInput = {
    create?: XOR<AffiliateProfileCreateWithoutClicksInput, AffiliateProfileUncheckedCreateWithoutClicksInput>
    connectOrCreate?: AffiliateProfileCreateOrConnectWithoutClicksInput
    connect?: AffiliateProfileWhereUniqueInput
  }

  export type ConversionCreateNestedOneWithoutClickInput = {
    create?: XOR<ConversionCreateWithoutClickInput, ConversionUncheckedCreateWithoutClickInput>
    connectOrCreate?: ConversionCreateOrConnectWithoutClickInput
    connect?: ConversionWhereUniqueInput
  }

  export type ConversionUncheckedCreateNestedOneWithoutClickInput = {
    create?: XOR<ConversionCreateWithoutClickInput, ConversionUncheckedCreateWithoutClickInput>
    connectOrCreate?: ConversionCreateOrConnectWithoutClickInput
    connect?: ConversionWhereUniqueInput
  }

  export type AffiliateLinkUpdateOneRequiredWithoutClickRecordsNestedInput = {
    create?: XOR<AffiliateLinkCreateWithoutClickRecordsInput, AffiliateLinkUncheckedCreateWithoutClickRecordsInput>
    connectOrCreate?: AffiliateLinkCreateOrConnectWithoutClickRecordsInput
    upsert?: AffiliateLinkUpsertWithoutClickRecordsInput
    connect?: AffiliateLinkWhereUniqueInput
    update?: XOR<XOR<AffiliateLinkUpdateToOneWithWhereWithoutClickRecordsInput, AffiliateLinkUpdateWithoutClickRecordsInput>, AffiliateLinkUncheckedUpdateWithoutClickRecordsInput>
  }

  export type AffiliateProfileUpdateOneRequiredWithoutClicksNestedInput = {
    create?: XOR<AffiliateProfileCreateWithoutClicksInput, AffiliateProfileUncheckedCreateWithoutClicksInput>
    connectOrCreate?: AffiliateProfileCreateOrConnectWithoutClicksInput
    upsert?: AffiliateProfileUpsertWithoutClicksInput
    connect?: AffiliateProfileWhereUniqueInput
    update?: XOR<XOR<AffiliateProfileUpdateToOneWithWhereWithoutClicksInput, AffiliateProfileUpdateWithoutClicksInput>, AffiliateProfileUncheckedUpdateWithoutClicksInput>
  }

  export type ConversionUpdateOneWithoutClickNestedInput = {
    create?: XOR<ConversionCreateWithoutClickInput, ConversionUncheckedCreateWithoutClickInput>
    connectOrCreate?: ConversionCreateOrConnectWithoutClickInput
    upsert?: ConversionUpsertWithoutClickInput
    disconnect?: ConversionWhereInput | boolean
    delete?: ConversionWhereInput | boolean
    connect?: ConversionWhereUniqueInput
    update?: XOR<XOR<ConversionUpdateToOneWithWhereWithoutClickInput, ConversionUpdateWithoutClickInput>, ConversionUncheckedUpdateWithoutClickInput>
  }

  export type ConversionUncheckedUpdateOneWithoutClickNestedInput = {
    create?: XOR<ConversionCreateWithoutClickInput, ConversionUncheckedCreateWithoutClickInput>
    connectOrCreate?: ConversionCreateOrConnectWithoutClickInput
    upsert?: ConversionUpsertWithoutClickInput
    disconnect?: ConversionWhereInput | boolean
    delete?: ConversionWhereInput | boolean
    connect?: ConversionWhereUniqueInput
    update?: XOR<XOR<ConversionUpdateToOneWithWhereWithoutClickInput, ConversionUpdateWithoutClickInput>, ConversionUncheckedUpdateWithoutClickInput>
  }

  export type ClickCreateNestedOneWithoutConversionInput = {
    create?: XOR<ClickCreateWithoutConversionInput, ClickUncheckedCreateWithoutConversionInput>
    connectOrCreate?: ClickCreateOrConnectWithoutConversionInput
    connect?: ClickWhereUniqueInput
  }

  export type AffiliateProfileCreateNestedOneWithoutConversionsInput = {
    create?: XOR<AffiliateProfileCreateWithoutConversionsInput, AffiliateProfileUncheckedCreateWithoutConversionsInput>
    connectOrCreate?: AffiliateProfileCreateOrConnectWithoutConversionsInput
    connect?: AffiliateProfileWhereUniqueInput
  }

  export type OfferCreateNestedOneWithoutConversionsInput = {
    create?: XOR<OfferCreateWithoutConversionsInput, OfferUncheckedCreateWithoutConversionsInput>
    connectOrCreate?: OfferCreateOrConnectWithoutConversionsInput
    connect?: OfferWhereUniqueInput
  }

  export type CommissionCreateNestedOneWithoutConversionInput = {
    create?: XOR<CommissionCreateWithoutConversionInput, CommissionUncheckedCreateWithoutConversionInput>
    connectOrCreate?: CommissionCreateOrConnectWithoutConversionInput
    connect?: CommissionWhereUniqueInput
  }

  export type CommissionUncheckedCreateNestedOneWithoutConversionInput = {
    create?: XOR<CommissionCreateWithoutConversionInput, CommissionUncheckedCreateWithoutConversionInput>
    connectOrCreate?: CommissionCreateOrConnectWithoutConversionInput
    connect?: CommissionWhereUniqueInput
  }

  export type EnumConversionStatusFieldUpdateOperationsInput = {
    set?: $Enums.ConversionStatus
  }

  export type ClickUpdateOneRequiredWithoutConversionNestedInput = {
    create?: XOR<ClickCreateWithoutConversionInput, ClickUncheckedCreateWithoutConversionInput>
    connectOrCreate?: ClickCreateOrConnectWithoutConversionInput
    upsert?: ClickUpsertWithoutConversionInput
    connect?: ClickWhereUniqueInput
    update?: XOR<XOR<ClickUpdateToOneWithWhereWithoutConversionInput, ClickUpdateWithoutConversionInput>, ClickUncheckedUpdateWithoutConversionInput>
  }

  export type AffiliateProfileUpdateOneRequiredWithoutConversionsNestedInput = {
    create?: XOR<AffiliateProfileCreateWithoutConversionsInput, AffiliateProfileUncheckedCreateWithoutConversionsInput>
    connectOrCreate?: AffiliateProfileCreateOrConnectWithoutConversionsInput
    upsert?: AffiliateProfileUpsertWithoutConversionsInput
    connect?: AffiliateProfileWhereUniqueInput
    update?: XOR<XOR<AffiliateProfileUpdateToOneWithWhereWithoutConversionsInput, AffiliateProfileUpdateWithoutConversionsInput>, AffiliateProfileUncheckedUpdateWithoutConversionsInput>
  }

  export type OfferUpdateOneRequiredWithoutConversionsNestedInput = {
    create?: XOR<OfferCreateWithoutConversionsInput, OfferUncheckedCreateWithoutConversionsInput>
    connectOrCreate?: OfferCreateOrConnectWithoutConversionsInput
    upsert?: OfferUpsertWithoutConversionsInput
    connect?: OfferWhereUniqueInput
    update?: XOR<XOR<OfferUpdateToOneWithWhereWithoutConversionsInput, OfferUpdateWithoutConversionsInput>, OfferUncheckedUpdateWithoutConversionsInput>
  }

  export type CommissionUpdateOneWithoutConversionNestedInput = {
    create?: XOR<CommissionCreateWithoutConversionInput, CommissionUncheckedCreateWithoutConversionInput>
    connectOrCreate?: CommissionCreateOrConnectWithoutConversionInput
    upsert?: CommissionUpsertWithoutConversionInput
    disconnect?: CommissionWhereInput | boolean
    delete?: CommissionWhereInput | boolean
    connect?: CommissionWhereUniqueInput
    update?: XOR<XOR<CommissionUpdateToOneWithWhereWithoutConversionInput, CommissionUpdateWithoutConversionInput>, CommissionUncheckedUpdateWithoutConversionInput>
  }

  export type CommissionUncheckedUpdateOneWithoutConversionNestedInput = {
    create?: XOR<CommissionCreateWithoutConversionInput, CommissionUncheckedCreateWithoutConversionInput>
    connectOrCreate?: CommissionCreateOrConnectWithoutConversionInput
    upsert?: CommissionUpsertWithoutConversionInput
    disconnect?: CommissionWhereInput | boolean
    delete?: CommissionWhereInput | boolean
    connect?: CommissionWhereUniqueInput
    update?: XOR<XOR<CommissionUpdateToOneWithWhereWithoutConversionInput, CommissionUpdateWithoutConversionInput>, CommissionUncheckedUpdateWithoutConversionInput>
  }

  export type ConversionCreateNestedOneWithoutCommissionInput = {
    create?: XOR<ConversionCreateWithoutCommissionInput, ConversionUncheckedCreateWithoutCommissionInput>
    connectOrCreate?: ConversionCreateOrConnectWithoutCommissionInput
    connect?: ConversionWhereUniqueInput
  }

  export type AffiliateProfileCreateNestedOneWithoutCommissionsInput = {
    create?: XOR<AffiliateProfileCreateWithoutCommissionsInput, AffiliateProfileUncheckedCreateWithoutCommissionsInput>
    connectOrCreate?: AffiliateProfileCreateOrConnectWithoutCommissionsInput
    connect?: AffiliateProfileWhereUniqueInput
  }

  export type PayoutCreateNestedOneWithoutCommissionsInput = {
    create?: XOR<PayoutCreateWithoutCommissionsInput, PayoutUncheckedCreateWithoutCommissionsInput>
    connectOrCreate?: PayoutCreateOrConnectWithoutCommissionsInput
    connect?: PayoutWhereUniqueInput
  }

  export type EnumCommissionStatusFieldUpdateOperationsInput = {
    set?: $Enums.CommissionStatus
  }

  export type ConversionUpdateOneRequiredWithoutCommissionNestedInput = {
    create?: XOR<ConversionCreateWithoutCommissionInput, ConversionUncheckedCreateWithoutCommissionInput>
    connectOrCreate?: ConversionCreateOrConnectWithoutCommissionInput
    upsert?: ConversionUpsertWithoutCommissionInput
    connect?: ConversionWhereUniqueInput
    update?: XOR<XOR<ConversionUpdateToOneWithWhereWithoutCommissionInput, ConversionUpdateWithoutCommissionInput>, ConversionUncheckedUpdateWithoutCommissionInput>
  }

  export type AffiliateProfileUpdateOneRequiredWithoutCommissionsNestedInput = {
    create?: XOR<AffiliateProfileCreateWithoutCommissionsInput, AffiliateProfileUncheckedCreateWithoutCommissionsInput>
    connectOrCreate?: AffiliateProfileCreateOrConnectWithoutCommissionsInput
    upsert?: AffiliateProfileUpsertWithoutCommissionsInput
    connect?: AffiliateProfileWhereUniqueInput
    update?: XOR<XOR<AffiliateProfileUpdateToOneWithWhereWithoutCommissionsInput, AffiliateProfileUpdateWithoutCommissionsInput>, AffiliateProfileUncheckedUpdateWithoutCommissionsInput>
  }

  export type PayoutUpdateOneWithoutCommissionsNestedInput = {
    create?: XOR<PayoutCreateWithoutCommissionsInput, PayoutUncheckedCreateWithoutCommissionsInput>
    connectOrCreate?: PayoutCreateOrConnectWithoutCommissionsInput
    upsert?: PayoutUpsertWithoutCommissionsInput
    disconnect?: PayoutWhereInput | boolean
    delete?: PayoutWhereInput | boolean
    connect?: PayoutWhereUniqueInput
    update?: XOR<XOR<PayoutUpdateToOneWithWhereWithoutCommissionsInput, PayoutUpdateWithoutCommissionsInput>, PayoutUncheckedUpdateWithoutCommissionsInput>
  }

  export type AffiliateProfileCreateNestedOneWithoutPayoutsInput = {
    create?: XOR<AffiliateProfileCreateWithoutPayoutsInput, AffiliateProfileUncheckedCreateWithoutPayoutsInput>
    connectOrCreate?: AffiliateProfileCreateOrConnectWithoutPayoutsInput
    connect?: AffiliateProfileWhereUniqueInput
  }

  export type CommissionCreateNestedManyWithoutPayoutInput = {
    create?: XOR<CommissionCreateWithoutPayoutInput, CommissionUncheckedCreateWithoutPayoutInput> | CommissionCreateWithoutPayoutInput[] | CommissionUncheckedCreateWithoutPayoutInput[]
    connectOrCreate?: CommissionCreateOrConnectWithoutPayoutInput | CommissionCreateOrConnectWithoutPayoutInput[]
    createMany?: CommissionCreateManyPayoutInputEnvelope
    connect?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
  }

  export type CommissionUncheckedCreateNestedManyWithoutPayoutInput = {
    create?: XOR<CommissionCreateWithoutPayoutInput, CommissionUncheckedCreateWithoutPayoutInput> | CommissionCreateWithoutPayoutInput[] | CommissionUncheckedCreateWithoutPayoutInput[]
    connectOrCreate?: CommissionCreateOrConnectWithoutPayoutInput | CommissionCreateOrConnectWithoutPayoutInput[]
    createMany?: CommissionCreateManyPayoutInputEnvelope
    connect?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
  }

  export type EnumPayoutStatusFieldUpdateOperationsInput = {
    set?: $Enums.PayoutStatus
  }

  export type AffiliateProfileUpdateOneRequiredWithoutPayoutsNestedInput = {
    create?: XOR<AffiliateProfileCreateWithoutPayoutsInput, AffiliateProfileUncheckedCreateWithoutPayoutsInput>
    connectOrCreate?: AffiliateProfileCreateOrConnectWithoutPayoutsInput
    upsert?: AffiliateProfileUpsertWithoutPayoutsInput
    connect?: AffiliateProfileWhereUniqueInput
    update?: XOR<XOR<AffiliateProfileUpdateToOneWithWhereWithoutPayoutsInput, AffiliateProfileUpdateWithoutPayoutsInput>, AffiliateProfileUncheckedUpdateWithoutPayoutsInput>
  }

  export type CommissionUpdateManyWithoutPayoutNestedInput = {
    create?: XOR<CommissionCreateWithoutPayoutInput, CommissionUncheckedCreateWithoutPayoutInput> | CommissionCreateWithoutPayoutInput[] | CommissionUncheckedCreateWithoutPayoutInput[]
    connectOrCreate?: CommissionCreateOrConnectWithoutPayoutInput | CommissionCreateOrConnectWithoutPayoutInput[]
    upsert?: CommissionUpsertWithWhereUniqueWithoutPayoutInput | CommissionUpsertWithWhereUniqueWithoutPayoutInput[]
    createMany?: CommissionCreateManyPayoutInputEnvelope
    set?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    disconnect?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    delete?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    connect?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    update?: CommissionUpdateWithWhereUniqueWithoutPayoutInput | CommissionUpdateWithWhereUniqueWithoutPayoutInput[]
    updateMany?: CommissionUpdateManyWithWhereWithoutPayoutInput | CommissionUpdateManyWithWhereWithoutPayoutInput[]
    deleteMany?: CommissionScalarWhereInput | CommissionScalarWhereInput[]
  }

  export type CommissionUncheckedUpdateManyWithoutPayoutNestedInput = {
    create?: XOR<CommissionCreateWithoutPayoutInput, CommissionUncheckedCreateWithoutPayoutInput> | CommissionCreateWithoutPayoutInput[] | CommissionUncheckedCreateWithoutPayoutInput[]
    connectOrCreate?: CommissionCreateOrConnectWithoutPayoutInput | CommissionCreateOrConnectWithoutPayoutInput[]
    upsert?: CommissionUpsertWithWhereUniqueWithoutPayoutInput | CommissionUpsertWithWhereUniqueWithoutPayoutInput[]
    createMany?: CommissionCreateManyPayoutInputEnvelope
    set?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    disconnect?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    delete?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    connect?: CommissionWhereUniqueInput | CommissionWhereUniqueInput[]
    update?: CommissionUpdateWithWhereUniqueWithoutPayoutInput | CommissionUpdateWithWhereUniqueWithoutPayoutInput[]
    updateMany?: CommissionUpdateManyWithWhereWithoutPayoutInput | CommissionUpdateManyWithWhereWithoutPayoutInput[]
    deleteMany?: CommissionScalarWhereInput | CommissionScalarWhereInput[]
  }

  export type OfferCreateNestedOneWithoutCreativesInput = {
    create?: XOR<OfferCreateWithoutCreativesInput, OfferUncheckedCreateWithoutCreativesInput>
    connectOrCreate?: OfferCreateOrConnectWithoutCreativesInput
    connect?: OfferWhereUniqueInput
  }

  export type EnumCreativeTypeFieldUpdateOperationsInput = {
    set?: $Enums.CreativeType
  }

  export type OfferUpdateOneRequiredWithoutCreativesNestedInput = {
    create?: XOR<OfferCreateWithoutCreativesInput, OfferUncheckedCreateWithoutCreativesInput>
    connectOrCreate?: OfferCreateOrConnectWithoutCreativesInput
    upsert?: OfferUpsertWithoutCreativesInput
    connect?: OfferWhereUniqueInput
    update?: XOR<XOR<OfferUpdateToOneWithWhereWithoutCreativesInput, OfferUpdateWithoutCreativesInput>, OfferUncheckedUpdateWithoutCreativesInput>
  }

  export type AffiliateProfileCreateNestedOneWithoutCouponsInput = {
    create?: XOR<AffiliateProfileCreateWithoutCouponsInput, AffiliateProfileUncheckedCreateWithoutCouponsInput>
    connectOrCreate?: AffiliateProfileCreateOrConnectWithoutCouponsInput
    connect?: AffiliateProfileWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumCouponStatusFieldUpdateOperationsInput = {
    set?: $Enums.CouponStatus
  }

  export type AffiliateProfileUpdateOneRequiredWithoutCouponsNestedInput = {
    create?: XOR<AffiliateProfileCreateWithoutCouponsInput, AffiliateProfileUncheckedCreateWithoutCouponsInput>
    connectOrCreate?: AffiliateProfileCreateOrConnectWithoutCouponsInput
    upsert?: AffiliateProfileUpsertWithoutCouponsInput
    connect?: AffiliateProfileWhereUniqueInput
    update?: XOR<XOR<AffiliateProfileUpdateToOneWithWhereWithoutCouponsInput, AffiliateProfileUpdateWithoutCouponsInput>, AffiliateProfileUncheckedUpdateWithoutCouponsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivitiesInput
    upsert?: UserUpsertWithoutActivitiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivitiesInput, UserUpdateWithoutActivitiesInput>, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type WebhookCreateeventsInput = {
    set: string[]
  }

  export type WebhookUpdateeventsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumWebhookStatusFieldUpdateOperationsInput = {
    set?: $Enums.WebhookStatus
  }

  export type EnumRuleTypeFieldUpdateOperationsInput = {
    set?: $Enums.RuleType
  }

  export type EnumRuleActionFieldUpdateOperationsInput = {
    set?: $Enums.RuleAction
  }

  export type EnumRuleStatusFieldUpdateOperationsInput = {
    set?: $Enums.RuleStatus
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumAffiliateTierFilter<$PrismaModel = never> = {
    equals?: $Enums.AffiliateTier | EnumAffiliateTierFieldRefInput<$PrismaModel>
    in?: $Enums.AffiliateTier[] | ListEnumAffiliateTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.AffiliateTier[] | ListEnumAffiliateTierFieldRefInput<$PrismaModel>
    not?: NestedEnumAffiliateTierFilter<$PrismaModel> | $Enums.AffiliateTier
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumAffiliateTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AffiliateTier | EnumAffiliateTierFieldRefInput<$PrismaModel>
    in?: $Enums.AffiliateTier[] | ListEnumAffiliateTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.AffiliateTier[] | ListEnumAffiliateTierFieldRefInput<$PrismaModel>
    not?: NestedEnumAffiliateTierWithAggregatesFilter<$PrismaModel> | $Enums.AffiliateTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAffiliateTierFilter<$PrismaModel>
    _max?: NestedEnumAffiliateTierFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumOfferStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OfferStatus | EnumOfferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OfferStatus[] | ListEnumOfferStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OfferStatus[] | ListEnumOfferStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOfferStatusFilter<$PrismaModel> | $Enums.OfferStatus
  }

  export type NestedEnumOfferStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OfferStatus | EnumOfferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OfferStatus[] | ListEnumOfferStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OfferStatus[] | ListEnumOfferStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOfferStatusWithAggregatesFilter<$PrismaModel> | $Enums.OfferStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOfferStatusFilter<$PrismaModel>
    _max?: NestedEnumOfferStatusFilter<$PrismaModel>
  }

  export type NestedEnumApplicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusFilter<$PrismaModel> | $Enums.ApplicationStatus
  }

  export type NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicationStatus | EnumApplicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicationStatus[] | ListEnumApplicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApplicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicationStatusFilter<$PrismaModel>
    _max?: NestedEnumApplicationStatusFilter<$PrismaModel>
  }

  export type NestedEnumConversionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ConversionStatus | EnumConversionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConversionStatus[] | ListEnumConversionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConversionStatus[] | ListEnumConversionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConversionStatusFilter<$PrismaModel> | $Enums.ConversionStatus
  }

  export type NestedEnumConversionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConversionStatus | EnumConversionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConversionStatus[] | ListEnumConversionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConversionStatus[] | ListEnumConversionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConversionStatusWithAggregatesFilter<$PrismaModel> | $Enums.ConversionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConversionStatusFilter<$PrismaModel>
    _max?: NestedEnumConversionStatusFilter<$PrismaModel>
  }

  export type NestedEnumCommissionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CommissionStatus | EnumCommissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CommissionStatus[] | ListEnumCommissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommissionStatus[] | ListEnumCommissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCommissionStatusFilter<$PrismaModel> | $Enums.CommissionStatus
  }

  export type NestedEnumCommissionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommissionStatus | EnumCommissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CommissionStatus[] | ListEnumCommissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommissionStatus[] | ListEnumCommissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCommissionStatusWithAggregatesFilter<$PrismaModel> | $Enums.CommissionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommissionStatusFilter<$PrismaModel>
    _max?: NestedEnumCommissionStatusFilter<$PrismaModel>
  }

  export type NestedEnumPayoutStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PayoutStatus | EnumPayoutStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayoutStatusFilter<$PrismaModel> | $Enums.PayoutStatus
  }

  export type NestedEnumPayoutStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayoutStatus | EnumPayoutStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayoutStatusWithAggregatesFilter<$PrismaModel> | $Enums.PayoutStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayoutStatusFilter<$PrismaModel>
    _max?: NestedEnumPayoutStatusFilter<$PrismaModel>
  }

  export type NestedEnumCreativeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CreativeType | EnumCreativeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CreativeType[] | ListEnumCreativeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreativeType[] | ListEnumCreativeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCreativeTypeFilter<$PrismaModel> | $Enums.CreativeType
  }

  export type NestedEnumCreativeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CreativeType | EnumCreativeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CreativeType[] | ListEnumCreativeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreativeType[] | ListEnumCreativeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCreativeTypeWithAggregatesFilter<$PrismaModel> | $Enums.CreativeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCreativeTypeFilter<$PrismaModel>
    _max?: NestedEnumCreativeTypeFilter<$PrismaModel>
  }

  export type NestedEnumCouponStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CouponStatus | EnumCouponStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CouponStatus[] | ListEnumCouponStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CouponStatus[] | ListEnumCouponStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCouponStatusFilter<$PrismaModel> | $Enums.CouponStatus
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumCouponStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CouponStatus | EnumCouponStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CouponStatus[] | ListEnumCouponStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CouponStatus[] | ListEnumCouponStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCouponStatusWithAggregatesFilter<$PrismaModel> | $Enums.CouponStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCouponStatusFilter<$PrismaModel>
    _max?: NestedEnumCouponStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumWebhookStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WebhookStatus | EnumWebhookStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WebhookStatus[] | ListEnumWebhookStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WebhookStatus[] | ListEnumWebhookStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWebhookStatusFilter<$PrismaModel> | $Enums.WebhookStatus
  }

  export type NestedEnumWebhookStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WebhookStatus | EnumWebhookStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WebhookStatus[] | ListEnumWebhookStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WebhookStatus[] | ListEnumWebhookStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWebhookStatusWithAggregatesFilter<$PrismaModel> | $Enums.WebhookStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWebhookStatusFilter<$PrismaModel>
    _max?: NestedEnumWebhookStatusFilter<$PrismaModel>
  }

  export type NestedEnumRuleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RuleType | EnumRuleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RuleType[] | ListEnumRuleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RuleType[] | ListEnumRuleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRuleTypeFilter<$PrismaModel> | $Enums.RuleType
  }

  export type NestedEnumRuleActionFilter<$PrismaModel = never> = {
    equals?: $Enums.RuleAction | EnumRuleActionFieldRefInput<$PrismaModel>
    in?: $Enums.RuleAction[] | ListEnumRuleActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.RuleAction[] | ListEnumRuleActionFieldRefInput<$PrismaModel>
    not?: NestedEnumRuleActionFilter<$PrismaModel> | $Enums.RuleAction
  }

  export type NestedEnumRuleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RuleStatus | EnumRuleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RuleStatus[] | ListEnumRuleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RuleStatus[] | ListEnumRuleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRuleStatusFilter<$PrismaModel> | $Enums.RuleStatus
  }

  export type NestedEnumRuleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RuleType | EnumRuleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RuleType[] | ListEnumRuleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RuleType[] | ListEnumRuleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRuleTypeWithAggregatesFilter<$PrismaModel> | $Enums.RuleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRuleTypeFilter<$PrismaModel>
    _max?: NestedEnumRuleTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumRuleActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RuleAction | EnumRuleActionFieldRefInput<$PrismaModel>
    in?: $Enums.RuleAction[] | ListEnumRuleActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.RuleAction[] | ListEnumRuleActionFieldRefInput<$PrismaModel>
    not?: NestedEnumRuleActionWithAggregatesFilter<$PrismaModel> | $Enums.RuleAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRuleActionFilter<$PrismaModel>
    _max?: NestedEnumRuleActionFilter<$PrismaModel>
  }

  export type NestedEnumRuleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RuleStatus | EnumRuleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RuleStatus[] | ListEnumRuleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RuleStatus[] | ListEnumRuleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRuleStatusWithAggregatesFilter<$PrismaModel> | $Enums.RuleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRuleStatusFilter<$PrismaModel>
    _max?: NestedEnumRuleStatusFilter<$PrismaModel>
  }

  export type AffiliateProfileCreateWithoutUserInput = {
    id?: string
    companyName?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: $Enums.PaymentMethod
    paymentEmail?: string | null
    taxId?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    tier?: $Enums.AffiliateTier
    commissionRate?: number
    totalEarnings?: number
    totalClicks?: number
    totalConversions?: number
    conversionRate?: number
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clicks?: ClickCreateNestedManyWithoutAffiliateInput
    conversions?: ConversionCreateNestedManyWithoutAffiliateInput
    commissions?: CommissionCreateNestedManyWithoutAffiliateInput
    payouts?: PayoutCreateNestedManyWithoutAffiliateInput
    links?: AffiliateLinkCreateNestedManyWithoutAffiliateInput
    coupons?: CouponCreateNestedManyWithoutAffiliateInput
    applications?: OfferApplicationCreateNestedManyWithoutAffiliateInput
  }

  export type AffiliateProfileUncheckedCreateWithoutUserInput = {
    id?: string
    companyName?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: $Enums.PaymentMethod
    paymentEmail?: string | null
    taxId?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    tier?: $Enums.AffiliateTier
    commissionRate?: number
    totalEarnings?: number
    totalClicks?: number
    totalConversions?: number
    conversionRate?: number
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clicks?: ClickUncheckedCreateNestedManyWithoutAffiliateInput
    conversions?: ConversionUncheckedCreateNestedManyWithoutAffiliateInput
    commissions?: CommissionUncheckedCreateNestedManyWithoutAffiliateInput
    payouts?: PayoutUncheckedCreateNestedManyWithoutAffiliateInput
    links?: AffiliateLinkUncheckedCreateNestedManyWithoutAffiliateInput
    coupons?: CouponUncheckedCreateNestedManyWithoutAffiliateInput
    applications?: OfferApplicationUncheckedCreateNestedManyWithoutAffiliateInput
  }

  export type AffiliateProfileCreateOrConnectWithoutUserInput = {
    where: AffiliateProfileWhereUniqueInput
    create: XOR<AffiliateProfileCreateWithoutUserInput, AffiliateProfileUncheckedCreateWithoutUserInput>
  }

  export type AdminProfileCreateWithoutUserInput = {
    id?: string
    permissions?: AdminProfileCreatepermissionsInput | string[]
    department?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminProfileUncheckedCreateWithoutUserInput = {
    id?: string
    permissions?: AdminProfileCreatepermissionsInput | string[]
    department?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminProfileCreateOrConnectWithoutUserInput = {
    where: AdminProfileWhereUniqueInput
    create: XOR<AdminProfileCreateWithoutUserInput, AdminProfileUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    read?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    read?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ActivityCreateWithoutUserInput = {
    id?: string
    action: string
    resource: string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type ActivityUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    resource: string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type ActivityCreateOrConnectWithoutUserInput = {
    where: ActivityWhereUniqueInput
    create: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput>
  }

  export type ActivityCreateManyUserInputEnvelope = {
    data: ActivityCreateManyUserInput | ActivityCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AffiliateProfileUpsertWithoutUserInput = {
    update: XOR<AffiliateProfileUpdateWithoutUserInput, AffiliateProfileUncheckedUpdateWithoutUserInput>
    create: XOR<AffiliateProfileCreateWithoutUserInput, AffiliateProfileUncheckedCreateWithoutUserInput>
    where?: AffiliateProfileWhereInput
  }

  export type AffiliateProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: AffiliateProfileWhereInput
    data: XOR<AffiliateProfileUpdateWithoutUserInput, AffiliateProfileUncheckedUpdateWithoutUserInput>
  }

  export type AffiliateProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    tier?: EnumAffiliateTierFieldUpdateOperationsInput | $Enums.AffiliateTier
    commissionRate?: FloatFieldUpdateOperationsInput | number
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clicks?: ClickUpdateManyWithoutAffiliateNestedInput
    conversions?: ConversionUpdateManyWithoutAffiliateNestedInput
    commissions?: CommissionUpdateManyWithoutAffiliateNestedInput
    payouts?: PayoutUpdateManyWithoutAffiliateNestedInput
    links?: AffiliateLinkUpdateManyWithoutAffiliateNestedInput
    coupons?: CouponUpdateManyWithoutAffiliateNestedInput
    applications?: OfferApplicationUpdateManyWithoutAffiliateNestedInput
  }

  export type AffiliateProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    tier?: EnumAffiliateTierFieldUpdateOperationsInput | $Enums.AffiliateTier
    commissionRate?: FloatFieldUpdateOperationsInput | number
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clicks?: ClickUncheckedUpdateManyWithoutAffiliateNestedInput
    conversions?: ConversionUncheckedUpdateManyWithoutAffiliateNestedInput
    commissions?: CommissionUncheckedUpdateManyWithoutAffiliateNestedInput
    payouts?: PayoutUncheckedUpdateManyWithoutAffiliateNestedInput
    links?: AffiliateLinkUncheckedUpdateManyWithoutAffiliateNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutAffiliateNestedInput
    applications?: OfferApplicationUncheckedUpdateManyWithoutAffiliateNestedInput
  }

  export type AdminProfileUpsertWithoutUserInput = {
    update: XOR<AdminProfileUpdateWithoutUserInput, AdminProfileUncheckedUpdateWithoutUserInput>
    create: XOR<AdminProfileCreateWithoutUserInput, AdminProfileUncheckedCreateWithoutUserInput>
    where?: AdminProfileWhereInput
  }

  export type AdminProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: AdminProfileWhereInput
    data: XOR<AdminProfileUpdateWithoutUserInput, AdminProfileUncheckedUpdateWithoutUserInput>
  }

  export type AdminProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissions?: AdminProfileUpdatepermissionsInput | string[]
    department?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissions?: AdminProfileUpdatepermissionsInput | string[]
    department?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    read?: BoolFilter<"Notification"> | boolean
    data?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type ActivityUpsertWithWhereUniqueWithoutUserInput = {
    where: ActivityWhereUniqueInput
    update: XOR<ActivityUpdateWithoutUserInput, ActivityUncheckedUpdateWithoutUserInput>
    create: XOR<ActivityCreateWithoutUserInput, ActivityUncheckedCreateWithoutUserInput>
  }

  export type ActivityUpdateWithWhereUniqueWithoutUserInput = {
    where: ActivityWhereUniqueInput
    data: XOR<ActivityUpdateWithoutUserInput, ActivityUncheckedUpdateWithoutUserInput>
  }

  export type ActivityUpdateManyWithWhereWithoutUserInput = {
    where: ActivityScalarWhereInput
    data: XOR<ActivityUpdateManyMutationInput, ActivityUncheckedUpdateManyWithoutUserInput>
  }

  export type ActivityScalarWhereInput = {
    AND?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    OR?: ActivityScalarWhereInput[]
    NOT?: ActivityScalarWhereInput | ActivityScalarWhereInput[]
    id?: StringFilter<"Activity"> | string
    userId?: StringFilter<"Activity"> | string
    action?: StringFilter<"Activity"> | string
    resource?: StringFilter<"Activity"> | string
    details?: JsonNullableFilter<"Activity">
    ipAddress?: StringNullableFilter<"Activity"> | string | null
    userAgent?: StringNullableFilter<"Activity"> | string | null
    createdAt?: DateTimeFilter<"Activity"> | Date | string
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    avatar?: string | null
    phone?: string | null
    timezone?: string
    language?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    affiliateProfile?: AffiliateProfileCreateNestedOneWithoutUserInput
    adminProfile?: AdminProfileCreateNestedOneWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    avatar?: string | null
    phone?: string | null
    timezone?: string
    language?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    affiliateProfile?: AffiliateProfileUncheckedCreateNestedOneWithoutUserInput
    adminProfile?: AdminProfileUncheckedCreateNestedOneWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateProfile?: AffiliateProfileUpdateOneWithoutUserNestedInput
    adminProfile?: AdminProfileUpdateOneWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateProfile?: AffiliateProfileUncheckedUpdateOneWithoutUserNestedInput
    adminProfile?: AdminProfileUncheckedUpdateOneWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAffiliateProfileInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    avatar?: string | null
    phone?: string | null
    timezone?: string
    language?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    adminProfile?: AdminProfileCreateNestedOneWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAffiliateProfileInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    avatar?: string | null
    phone?: string | null
    timezone?: string
    language?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    adminProfile?: AdminProfileUncheckedCreateNestedOneWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAffiliateProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAffiliateProfileInput, UserUncheckedCreateWithoutAffiliateProfileInput>
  }

  export type ClickCreateWithoutAffiliateInput = {
    id?: string
    ipAddress: string
    userAgent: string
    referrer?: string | null
    country?: string | null
    city?: string | null
    device?: string | null
    browser?: string | null
    os?: string | null
    converted?: boolean
    conversionId?: string | null
    createdAt?: Date | string
    link: AffiliateLinkCreateNestedOneWithoutClickRecordsInput
    conversion?: ConversionCreateNestedOneWithoutClickInput
  }

  export type ClickUncheckedCreateWithoutAffiliateInput = {
    id?: string
    linkId: string
    ipAddress: string
    userAgent: string
    referrer?: string | null
    country?: string | null
    city?: string | null
    device?: string | null
    browser?: string | null
    os?: string | null
    converted?: boolean
    conversionId?: string | null
    createdAt?: Date | string
    conversion?: ConversionUncheckedCreateNestedOneWithoutClickInput
  }

  export type ClickCreateOrConnectWithoutAffiliateInput = {
    where: ClickWhereUniqueInput
    create: XOR<ClickCreateWithoutAffiliateInput, ClickUncheckedCreateWithoutAffiliateInput>
  }

  export type ClickCreateManyAffiliateInputEnvelope = {
    data: ClickCreateManyAffiliateInput | ClickCreateManyAffiliateInput[]
    skipDuplicates?: boolean
  }

  export type ConversionCreateWithoutAffiliateInput = {
    id?: string
    customerEmail?: string | null
    customerValue: number
    commissionAmount: number
    status?: $Enums.ConversionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    click: ClickCreateNestedOneWithoutConversionInput
    offer: OfferCreateNestedOneWithoutConversionsInput
    commission?: CommissionCreateNestedOneWithoutConversionInput
  }

  export type ConversionUncheckedCreateWithoutAffiliateInput = {
    id?: string
    clickId: string
    offerId: string
    customerEmail?: string | null
    customerValue: number
    commissionAmount: number
    status?: $Enums.ConversionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    commission?: CommissionUncheckedCreateNestedOneWithoutConversionInput
  }

  export type ConversionCreateOrConnectWithoutAffiliateInput = {
    where: ConversionWhereUniqueInput
    create: XOR<ConversionCreateWithoutAffiliateInput, ConversionUncheckedCreateWithoutAffiliateInput>
  }

  export type ConversionCreateManyAffiliateInputEnvelope = {
    data: ConversionCreateManyAffiliateInput | ConversionCreateManyAffiliateInput[]
    skipDuplicates?: boolean
  }

  export type CommissionCreateWithoutAffiliateInput = {
    id?: string
    amount: number
    rate: number
    status?: $Enums.CommissionStatus
    payoutDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conversion: ConversionCreateNestedOneWithoutCommissionInput
    payout?: PayoutCreateNestedOneWithoutCommissionsInput
  }

  export type CommissionUncheckedCreateWithoutAffiliateInput = {
    id?: string
    conversionId: string
    payoutId?: string | null
    amount: number
    rate: number
    status?: $Enums.CommissionStatus
    payoutDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommissionCreateOrConnectWithoutAffiliateInput = {
    where: CommissionWhereUniqueInput
    create: XOR<CommissionCreateWithoutAffiliateInput, CommissionUncheckedCreateWithoutAffiliateInput>
  }

  export type CommissionCreateManyAffiliateInputEnvelope = {
    data: CommissionCreateManyAffiliateInput | CommissionCreateManyAffiliateInput[]
    skipDuplicates?: boolean
  }

  export type PayoutCreateWithoutAffiliateInput = {
    id?: string
    amount: number
    method: $Enums.PaymentMethod
    status?: $Enums.PayoutStatus
    referenceId?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    commissions?: CommissionCreateNestedManyWithoutPayoutInput
  }

  export type PayoutUncheckedCreateWithoutAffiliateInput = {
    id?: string
    amount: number
    method: $Enums.PaymentMethod
    status?: $Enums.PayoutStatus
    referenceId?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    commissions?: CommissionUncheckedCreateNestedManyWithoutPayoutInput
  }

  export type PayoutCreateOrConnectWithoutAffiliateInput = {
    where: PayoutWhereUniqueInput
    create: XOR<PayoutCreateWithoutAffiliateInput, PayoutUncheckedCreateWithoutAffiliateInput>
  }

  export type PayoutCreateManyAffiliateInputEnvelope = {
    data: PayoutCreateManyAffiliateInput | PayoutCreateManyAffiliateInput[]
    skipDuplicates?: boolean
  }

  export type AffiliateLinkCreateWithoutAffiliateInput = {
    id?: string
    originalUrl: string
    shortUrl: string
    customSlug?: string | null
    clicks?: number
    conversions?: number
    earnings?: number
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    offer?: OfferCreateNestedOneWithoutLinksInput
    clickRecords?: ClickCreateNestedManyWithoutLinkInput
  }

  export type AffiliateLinkUncheckedCreateWithoutAffiliateInput = {
    id?: string
    offerId?: string | null
    originalUrl: string
    shortUrl: string
    customSlug?: string | null
    clicks?: number
    conversions?: number
    earnings?: number
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clickRecords?: ClickUncheckedCreateNestedManyWithoutLinkInput
  }

  export type AffiliateLinkCreateOrConnectWithoutAffiliateInput = {
    where: AffiliateLinkWhereUniqueInput
    create: XOR<AffiliateLinkCreateWithoutAffiliateInput, AffiliateLinkUncheckedCreateWithoutAffiliateInput>
  }

  export type AffiliateLinkCreateManyAffiliateInputEnvelope = {
    data: AffiliateLinkCreateManyAffiliateInput | AffiliateLinkCreateManyAffiliateInput[]
    skipDuplicates?: boolean
  }

  export type CouponCreateWithoutAffiliateInput = {
    id?: string
    code: string
    description: string
    discount: string
    validUntil: Date | string
    usage?: number
    maxUsage?: number | null
    status?: $Enums.CouponStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CouponUncheckedCreateWithoutAffiliateInput = {
    id?: string
    code: string
    description: string
    discount: string
    validUntil: Date | string
    usage?: number
    maxUsage?: number | null
    status?: $Enums.CouponStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CouponCreateOrConnectWithoutAffiliateInput = {
    where: CouponWhereUniqueInput
    create: XOR<CouponCreateWithoutAffiliateInput, CouponUncheckedCreateWithoutAffiliateInput>
  }

  export type CouponCreateManyAffiliateInputEnvelope = {
    data: CouponCreateManyAffiliateInput | CouponCreateManyAffiliateInput[]
    skipDuplicates?: boolean
  }

  export type OfferApplicationCreateWithoutAffiliateInput = {
    id?: string
    status?: $Enums.ApplicationStatus
    message?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    offer: OfferCreateNestedOneWithoutApplicationsInput
  }

  export type OfferApplicationUncheckedCreateWithoutAffiliateInput = {
    id?: string
    offerId: string
    status?: $Enums.ApplicationStatus
    message?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferApplicationCreateOrConnectWithoutAffiliateInput = {
    where: OfferApplicationWhereUniqueInput
    create: XOR<OfferApplicationCreateWithoutAffiliateInput, OfferApplicationUncheckedCreateWithoutAffiliateInput>
  }

  export type OfferApplicationCreateManyAffiliateInputEnvelope = {
    data: OfferApplicationCreateManyAffiliateInput | OfferApplicationCreateManyAffiliateInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAffiliateProfileInput = {
    update: XOR<UserUpdateWithoutAffiliateProfileInput, UserUncheckedUpdateWithoutAffiliateProfileInput>
    create: XOR<UserCreateWithoutAffiliateProfileInput, UserUncheckedCreateWithoutAffiliateProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAffiliateProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAffiliateProfileInput, UserUncheckedUpdateWithoutAffiliateProfileInput>
  }

  export type UserUpdateWithoutAffiliateProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminProfile?: AdminProfileUpdateOneWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAffiliateProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    adminProfile?: AdminProfileUncheckedUpdateOneWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ClickUpsertWithWhereUniqueWithoutAffiliateInput = {
    where: ClickWhereUniqueInput
    update: XOR<ClickUpdateWithoutAffiliateInput, ClickUncheckedUpdateWithoutAffiliateInput>
    create: XOR<ClickCreateWithoutAffiliateInput, ClickUncheckedCreateWithoutAffiliateInput>
  }

  export type ClickUpdateWithWhereUniqueWithoutAffiliateInput = {
    where: ClickWhereUniqueInput
    data: XOR<ClickUpdateWithoutAffiliateInput, ClickUncheckedUpdateWithoutAffiliateInput>
  }

  export type ClickUpdateManyWithWhereWithoutAffiliateInput = {
    where: ClickScalarWhereInput
    data: XOR<ClickUpdateManyMutationInput, ClickUncheckedUpdateManyWithoutAffiliateInput>
  }

  export type ClickScalarWhereInput = {
    AND?: ClickScalarWhereInput | ClickScalarWhereInput[]
    OR?: ClickScalarWhereInput[]
    NOT?: ClickScalarWhereInput | ClickScalarWhereInput[]
    id?: StringFilter<"Click"> | string
    linkId?: StringFilter<"Click"> | string
    affiliateId?: StringFilter<"Click"> | string
    ipAddress?: StringFilter<"Click"> | string
    userAgent?: StringFilter<"Click"> | string
    referrer?: StringNullableFilter<"Click"> | string | null
    country?: StringNullableFilter<"Click"> | string | null
    city?: StringNullableFilter<"Click"> | string | null
    device?: StringNullableFilter<"Click"> | string | null
    browser?: StringNullableFilter<"Click"> | string | null
    os?: StringNullableFilter<"Click"> | string | null
    converted?: BoolFilter<"Click"> | boolean
    conversionId?: StringNullableFilter<"Click"> | string | null
    createdAt?: DateTimeFilter<"Click"> | Date | string
  }

  export type ConversionUpsertWithWhereUniqueWithoutAffiliateInput = {
    where: ConversionWhereUniqueInput
    update: XOR<ConversionUpdateWithoutAffiliateInput, ConversionUncheckedUpdateWithoutAffiliateInput>
    create: XOR<ConversionCreateWithoutAffiliateInput, ConversionUncheckedCreateWithoutAffiliateInput>
  }

  export type ConversionUpdateWithWhereUniqueWithoutAffiliateInput = {
    where: ConversionWhereUniqueInput
    data: XOR<ConversionUpdateWithoutAffiliateInput, ConversionUncheckedUpdateWithoutAffiliateInput>
  }

  export type ConversionUpdateManyWithWhereWithoutAffiliateInput = {
    where: ConversionScalarWhereInput
    data: XOR<ConversionUpdateManyMutationInput, ConversionUncheckedUpdateManyWithoutAffiliateInput>
  }

  export type ConversionScalarWhereInput = {
    AND?: ConversionScalarWhereInput | ConversionScalarWhereInput[]
    OR?: ConversionScalarWhereInput[]
    NOT?: ConversionScalarWhereInput | ConversionScalarWhereInput[]
    id?: StringFilter<"Conversion"> | string
    clickId?: StringFilter<"Conversion"> | string
    affiliateId?: StringFilter<"Conversion"> | string
    offerId?: StringFilter<"Conversion"> | string
    customerEmail?: StringNullableFilter<"Conversion"> | string | null
    customerValue?: FloatFilter<"Conversion"> | number
    commissionAmount?: FloatFilter<"Conversion"> | number
    status?: EnumConversionStatusFilter<"Conversion"> | $Enums.ConversionStatus
    createdAt?: DateTimeFilter<"Conversion"> | Date | string
    updatedAt?: DateTimeFilter<"Conversion"> | Date | string
  }

  export type CommissionUpsertWithWhereUniqueWithoutAffiliateInput = {
    where: CommissionWhereUniqueInput
    update: XOR<CommissionUpdateWithoutAffiliateInput, CommissionUncheckedUpdateWithoutAffiliateInput>
    create: XOR<CommissionCreateWithoutAffiliateInput, CommissionUncheckedCreateWithoutAffiliateInput>
  }

  export type CommissionUpdateWithWhereUniqueWithoutAffiliateInput = {
    where: CommissionWhereUniqueInput
    data: XOR<CommissionUpdateWithoutAffiliateInput, CommissionUncheckedUpdateWithoutAffiliateInput>
  }

  export type CommissionUpdateManyWithWhereWithoutAffiliateInput = {
    where: CommissionScalarWhereInput
    data: XOR<CommissionUpdateManyMutationInput, CommissionUncheckedUpdateManyWithoutAffiliateInput>
  }

  export type CommissionScalarWhereInput = {
    AND?: CommissionScalarWhereInput | CommissionScalarWhereInput[]
    OR?: CommissionScalarWhereInput[]
    NOT?: CommissionScalarWhereInput | CommissionScalarWhereInput[]
    id?: StringFilter<"Commission"> | string
    conversionId?: StringFilter<"Commission"> | string
    affiliateId?: StringFilter<"Commission"> | string
    payoutId?: StringNullableFilter<"Commission"> | string | null
    amount?: FloatFilter<"Commission"> | number
    rate?: FloatFilter<"Commission"> | number
    status?: EnumCommissionStatusFilter<"Commission"> | $Enums.CommissionStatus
    payoutDate?: DateTimeNullableFilter<"Commission"> | Date | string | null
    createdAt?: DateTimeFilter<"Commission"> | Date | string
    updatedAt?: DateTimeFilter<"Commission"> | Date | string
  }

  export type PayoutUpsertWithWhereUniqueWithoutAffiliateInput = {
    where: PayoutWhereUniqueInput
    update: XOR<PayoutUpdateWithoutAffiliateInput, PayoutUncheckedUpdateWithoutAffiliateInput>
    create: XOR<PayoutCreateWithoutAffiliateInput, PayoutUncheckedCreateWithoutAffiliateInput>
  }

  export type PayoutUpdateWithWhereUniqueWithoutAffiliateInput = {
    where: PayoutWhereUniqueInput
    data: XOR<PayoutUpdateWithoutAffiliateInput, PayoutUncheckedUpdateWithoutAffiliateInput>
  }

  export type PayoutUpdateManyWithWhereWithoutAffiliateInput = {
    where: PayoutScalarWhereInput
    data: XOR<PayoutUpdateManyMutationInput, PayoutUncheckedUpdateManyWithoutAffiliateInput>
  }

  export type PayoutScalarWhereInput = {
    AND?: PayoutScalarWhereInput | PayoutScalarWhereInput[]
    OR?: PayoutScalarWhereInput[]
    NOT?: PayoutScalarWhereInput | PayoutScalarWhereInput[]
    id?: StringFilter<"Payout"> | string
    affiliateId?: StringFilter<"Payout"> | string
    amount?: FloatFilter<"Payout"> | number
    method?: EnumPaymentMethodFilter<"Payout"> | $Enums.PaymentMethod
    status?: EnumPayoutStatusFilter<"Payout"> | $Enums.PayoutStatus
    referenceId?: StringNullableFilter<"Payout"> | string | null
    processedAt?: DateTimeNullableFilter<"Payout"> | Date | string | null
    createdAt?: DateTimeFilter<"Payout"> | Date | string
    updatedAt?: DateTimeFilter<"Payout"> | Date | string
  }

  export type AffiliateLinkUpsertWithWhereUniqueWithoutAffiliateInput = {
    where: AffiliateLinkWhereUniqueInput
    update: XOR<AffiliateLinkUpdateWithoutAffiliateInput, AffiliateLinkUncheckedUpdateWithoutAffiliateInput>
    create: XOR<AffiliateLinkCreateWithoutAffiliateInput, AffiliateLinkUncheckedCreateWithoutAffiliateInput>
  }

  export type AffiliateLinkUpdateWithWhereUniqueWithoutAffiliateInput = {
    where: AffiliateLinkWhereUniqueInput
    data: XOR<AffiliateLinkUpdateWithoutAffiliateInput, AffiliateLinkUncheckedUpdateWithoutAffiliateInput>
  }

  export type AffiliateLinkUpdateManyWithWhereWithoutAffiliateInput = {
    where: AffiliateLinkScalarWhereInput
    data: XOR<AffiliateLinkUpdateManyMutationInput, AffiliateLinkUncheckedUpdateManyWithoutAffiliateInput>
  }

  export type AffiliateLinkScalarWhereInput = {
    AND?: AffiliateLinkScalarWhereInput | AffiliateLinkScalarWhereInput[]
    OR?: AffiliateLinkScalarWhereInput[]
    NOT?: AffiliateLinkScalarWhereInput | AffiliateLinkScalarWhereInput[]
    id?: StringFilter<"AffiliateLink"> | string
    affiliateId?: StringFilter<"AffiliateLink"> | string
    offerId?: StringNullableFilter<"AffiliateLink"> | string | null
    originalUrl?: StringFilter<"AffiliateLink"> | string
    shortUrl?: StringFilter<"AffiliateLink"> | string
    customSlug?: StringNullableFilter<"AffiliateLink"> | string | null
    clicks?: IntFilter<"AffiliateLink"> | number
    conversions?: IntFilter<"AffiliateLink"> | number
    earnings?: FloatFilter<"AffiliateLink"> | number
    isActive?: BoolFilter<"AffiliateLink"> | boolean
    expiresAt?: DateTimeNullableFilter<"AffiliateLink"> | Date | string | null
    createdAt?: DateTimeFilter<"AffiliateLink"> | Date | string
    updatedAt?: DateTimeFilter<"AffiliateLink"> | Date | string
  }

  export type CouponUpsertWithWhereUniqueWithoutAffiliateInput = {
    where: CouponWhereUniqueInput
    update: XOR<CouponUpdateWithoutAffiliateInput, CouponUncheckedUpdateWithoutAffiliateInput>
    create: XOR<CouponCreateWithoutAffiliateInput, CouponUncheckedCreateWithoutAffiliateInput>
  }

  export type CouponUpdateWithWhereUniqueWithoutAffiliateInput = {
    where: CouponWhereUniqueInput
    data: XOR<CouponUpdateWithoutAffiliateInput, CouponUncheckedUpdateWithoutAffiliateInput>
  }

  export type CouponUpdateManyWithWhereWithoutAffiliateInput = {
    where: CouponScalarWhereInput
    data: XOR<CouponUpdateManyMutationInput, CouponUncheckedUpdateManyWithoutAffiliateInput>
  }

  export type CouponScalarWhereInput = {
    AND?: CouponScalarWhereInput | CouponScalarWhereInput[]
    OR?: CouponScalarWhereInput[]
    NOT?: CouponScalarWhereInput | CouponScalarWhereInput[]
    id?: StringFilter<"Coupon"> | string
    affiliateId?: StringFilter<"Coupon"> | string
    code?: StringFilter<"Coupon"> | string
    description?: StringFilter<"Coupon"> | string
    discount?: StringFilter<"Coupon"> | string
    validUntil?: DateTimeFilter<"Coupon"> | Date | string
    usage?: IntFilter<"Coupon"> | number
    maxUsage?: IntNullableFilter<"Coupon"> | number | null
    status?: EnumCouponStatusFilter<"Coupon"> | $Enums.CouponStatus
    createdAt?: DateTimeFilter<"Coupon"> | Date | string
    updatedAt?: DateTimeFilter<"Coupon"> | Date | string
  }

  export type OfferApplicationUpsertWithWhereUniqueWithoutAffiliateInput = {
    where: OfferApplicationWhereUniqueInput
    update: XOR<OfferApplicationUpdateWithoutAffiliateInput, OfferApplicationUncheckedUpdateWithoutAffiliateInput>
    create: XOR<OfferApplicationCreateWithoutAffiliateInput, OfferApplicationUncheckedCreateWithoutAffiliateInput>
  }

  export type OfferApplicationUpdateWithWhereUniqueWithoutAffiliateInput = {
    where: OfferApplicationWhereUniqueInput
    data: XOR<OfferApplicationUpdateWithoutAffiliateInput, OfferApplicationUncheckedUpdateWithoutAffiliateInput>
  }

  export type OfferApplicationUpdateManyWithWhereWithoutAffiliateInput = {
    where: OfferApplicationScalarWhereInput
    data: XOR<OfferApplicationUpdateManyMutationInput, OfferApplicationUncheckedUpdateManyWithoutAffiliateInput>
  }

  export type OfferApplicationScalarWhereInput = {
    AND?: OfferApplicationScalarWhereInput | OfferApplicationScalarWhereInput[]
    OR?: OfferApplicationScalarWhereInput[]
    NOT?: OfferApplicationScalarWhereInput | OfferApplicationScalarWhereInput[]
    id?: StringFilter<"OfferApplication"> | string
    affiliateId?: StringFilter<"OfferApplication"> | string
    offerId?: StringFilter<"OfferApplication"> | string
    status?: EnumApplicationStatusFilter<"OfferApplication"> | $Enums.ApplicationStatus
    message?: StringNullableFilter<"OfferApplication"> | string | null
    createdAt?: DateTimeFilter<"OfferApplication"> | Date | string
    updatedAt?: DateTimeFilter<"OfferApplication"> | Date | string
  }

  export type UserCreateWithoutAdminProfileInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    avatar?: string | null
    phone?: string | null
    timezone?: string
    language?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    affiliateProfile?: AffiliateProfileCreateNestedOneWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdminProfileInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    avatar?: string | null
    phone?: string | null
    timezone?: string
    language?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    affiliateProfile?: AffiliateProfileUncheckedCreateNestedOneWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdminProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminProfileInput, UserUncheckedCreateWithoutAdminProfileInput>
  }

  export type UserUpsertWithoutAdminProfileInput = {
    update: XOR<UserUpdateWithoutAdminProfileInput, UserUncheckedUpdateWithoutAdminProfileInput>
    create: XOR<UserCreateWithoutAdminProfileInput, UserUncheckedCreateWithoutAdminProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminProfileInput, UserUncheckedUpdateWithoutAdminProfileInput>
  }

  export type UserUpdateWithoutAdminProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateProfile?: AffiliateProfileUpdateOneWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateProfile?: AffiliateProfileUncheckedUpdateOneWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OfferApplicationCreateWithoutOfferInput = {
    id?: string
    status?: $Enums.ApplicationStatus
    message?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    affiliate: AffiliateProfileCreateNestedOneWithoutApplicationsInput
  }

  export type OfferApplicationUncheckedCreateWithoutOfferInput = {
    id?: string
    affiliateId: string
    status?: $Enums.ApplicationStatus
    message?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferApplicationCreateOrConnectWithoutOfferInput = {
    where: OfferApplicationWhereUniqueInput
    create: XOR<OfferApplicationCreateWithoutOfferInput, OfferApplicationUncheckedCreateWithoutOfferInput>
  }

  export type OfferApplicationCreateManyOfferInputEnvelope = {
    data: OfferApplicationCreateManyOfferInput | OfferApplicationCreateManyOfferInput[]
    skipDuplicates?: boolean
  }

  export type ConversionCreateWithoutOfferInput = {
    id?: string
    customerEmail?: string | null
    customerValue: number
    commissionAmount: number
    status?: $Enums.ConversionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    click: ClickCreateNestedOneWithoutConversionInput
    affiliate: AffiliateProfileCreateNestedOneWithoutConversionsInput
    commission?: CommissionCreateNestedOneWithoutConversionInput
  }

  export type ConversionUncheckedCreateWithoutOfferInput = {
    id?: string
    clickId: string
    affiliateId: string
    customerEmail?: string | null
    customerValue: number
    commissionAmount: number
    status?: $Enums.ConversionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    commission?: CommissionUncheckedCreateNestedOneWithoutConversionInput
  }

  export type ConversionCreateOrConnectWithoutOfferInput = {
    where: ConversionWhereUniqueInput
    create: XOR<ConversionCreateWithoutOfferInput, ConversionUncheckedCreateWithoutOfferInput>
  }

  export type ConversionCreateManyOfferInputEnvelope = {
    data: ConversionCreateManyOfferInput | ConversionCreateManyOfferInput[]
    skipDuplicates?: boolean
  }

  export type AffiliateLinkCreateWithoutOfferInput = {
    id?: string
    originalUrl: string
    shortUrl: string
    customSlug?: string | null
    clicks?: number
    conversions?: number
    earnings?: number
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    affiliate: AffiliateProfileCreateNestedOneWithoutLinksInput
    clickRecords?: ClickCreateNestedManyWithoutLinkInput
  }

  export type AffiliateLinkUncheckedCreateWithoutOfferInput = {
    id?: string
    affiliateId: string
    originalUrl: string
    shortUrl: string
    customSlug?: string | null
    clicks?: number
    conversions?: number
    earnings?: number
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clickRecords?: ClickUncheckedCreateNestedManyWithoutLinkInput
  }

  export type AffiliateLinkCreateOrConnectWithoutOfferInput = {
    where: AffiliateLinkWhereUniqueInput
    create: XOR<AffiliateLinkCreateWithoutOfferInput, AffiliateLinkUncheckedCreateWithoutOfferInput>
  }

  export type AffiliateLinkCreateManyOfferInputEnvelope = {
    data: AffiliateLinkCreateManyOfferInput | AffiliateLinkCreateManyOfferInput[]
    skipDuplicates?: boolean
  }

  export type CreativeCreateWithoutOfferInput = {
    id?: string
    name: string
    type: $Enums.CreativeType
    size: string
    format: string
    url: string
    downloadUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CreativeUncheckedCreateWithoutOfferInput = {
    id?: string
    name: string
    type: $Enums.CreativeType
    size: string
    format: string
    url: string
    downloadUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CreativeCreateOrConnectWithoutOfferInput = {
    where: CreativeWhereUniqueInput
    create: XOR<CreativeCreateWithoutOfferInput, CreativeUncheckedCreateWithoutOfferInput>
  }

  export type CreativeCreateManyOfferInputEnvelope = {
    data: CreativeCreateManyOfferInput | CreativeCreateManyOfferInput[]
    skipDuplicates?: boolean
  }

  export type OfferApplicationUpsertWithWhereUniqueWithoutOfferInput = {
    where: OfferApplicationWhereUniqueInput
    update: XOR<OfferApplicationUpdateWithoutOfferInput, OfferApplicationUncheckedUpdateWithoutOfferInput>
    create: XOR<OfferApplicationCreateWithoutOfferInput, OfferApplicationUncheckedCreateWithoutOfferInput>
  }

  export type OfferApplicationUpdateWithWhereUniqueWithoutOfferInput = {
    where: OfferApplicationWhereUniqueInput
    data: XOR<OfferApplicationUpdateWithoutOfferInput, OfferApplicationUncheckedUpdateWithoutOfferInput>
  }

  export type OfferApplicationUpdateManyWithWhereWithoutOfferInput = {
    where: OfferApplicationScalarWhereInput
    data: XOR<OfferApplicationUpdateManyMutationInput, OfferApplicationUncheckedUpdateManyWithoutOfferInput>
  }

  export type ConversionUpsertWithWhereUniqueWithoutOfferInput = {
    where: ConversionWhereUniqueInput
    update: XOR<ConversionUpdateWithoutOfferInput, ConversionUncheckedUpdateWithoutOfferInput>
    create: XOR<ConversionCreateWithoutOfferInput, ConversionUncheckedCreateWithoutOfferInput>
  }

  export type ConversionUpdateWithWhereUniqueWithoutOfferInput = {
    where: ConversionWhereUniqueInput
    data: XOR<ConversionUpdateWithoutOfferInput, ConversionUncheckedUpdateWithoutOfferInput>
  }

  export type ConversionUpdateManyWithWhereWithoutOfferInput = {
    where: ConversionScalarWhereInput
    data: XOR<ConversionUpdateManyMutationInput, ConversionUncheckedUpdateManyWithoutOfferInput>
  }

  export type AffiliateLinkUpsertWithWhereUniqueWithoutOfferInput = {
    where: AffiliateLinkWhereUniqueInput
    update: XOR<AffiliateLinkUpdateWithoutOfferInput, AffiliateLinkUncheckedUpdateWithoutOfferInput>
    create: XOR<AffiliateLinkCreateWithoutOfferInput, AffiliateLinkUncheckedCreateWithoutOfferInput>
  }

  export type AffiliateLinkUpdateWithWhereUniqueWithoutOfferInput = {
    where: AffiliateLinkWhereUniqueInput
    data: XOR<AffiliateLinkUpdateWithoutOfferInput, AffiliateLinkUncheckedUpdateWithoutOfferInput>
  }

  export type AffiliateLinkUpdateManyWithWhereWithoutOfferInput = {
    where: AffiliateLinkScalarWhereInput
    data: XOR<AffiliateLinkUpdateManyMutationInput, AffiliateLinkUncheckedUpdateManyWithoutOfferInput>
  }

  export type CreativeUpsertWithWhereUniqueWithoutOfferInput = {
    where: CreativeWhereUniqueInput
    update: XOR<CreativeUpdateWithoutOfferInput, CreativeUncheckedUpdateWithoutOfferInput>
    create: XOR<CreativeCreateWithoutOfferInput, CreativeUncheckedCreateWithoutOfferInput>
  }

  export type CreativeUpdateWithWhereUniqueWithoutOfferInput = {
    where: CreativeWhereUniqueInput
    data: XOR<CreativeUpdateWithoutOfferInput, CreativeUncheckedUpdateWithoutOfferInput>
  }

  export type CreativeUpdateManyWithWhereWithoutOfferInput = {
    where: CreativeScalarWhereInput
    data: XOR<CreativeUpdateManyMutationInput, CreativeUncheckedUpdateManyWithoutOfferInput>
  }

  export type CreativeScalarWhereInput = {
    AND?: CreativeScalarWhereInput | CreativeScalarWhereInput[]
    OR?: CreativeScalarWhereInput[]
    NOT?: CreativeScalarWhereInput | CreativeScalarWhereInput[]
    id?: StringFilter<"Creative"> | string
    offerId?: StringFilter<"Creative"> | string
    name?: StringFilter<"Creative"> | string
    type?: EnumCreativeTypeFilter<"Creative"> | $Enums.CreativeType
    size?: StringFilter<"Creative"> | string
    format?: StringFilter<"Creative"> | string
    url?: StringFilter<"Creative"> | string
    downloadUrl?: StringFilter<"Creative"> | string
    createdAt?: DateTimeFilter<"Creative"> | Date | string
    updatedAt?: DateTimeFilter<"Creative"> | Date | string
  }

  export type AffiliateProfileCreateWithoutApplicationsInput = {
    id?: string
    companyName?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: $Enums.PaymentMethod
    paymentEmail?: string | null
    taxId?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    tier?: $Enums.AffiliateTier
    commissionRate?: number
    totalEarnings?: number
    totalClicks?: number
    totalConversions?: number
    conversionRate?: number
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAffiliateProfileInput
    clicks?: ClickCreateNestedManyWithoutAffiliateInput
    conversions?: ConversionCreateNestedManyWithoutAffiliateInput
    commissions?: CommissionCreateNestedManyWithoutAffiliateInput
    payouts?: PayoutCreateNestedManyWithoutAffiliateInput
    links?: AffiliateLinkCreateNestedManyWithoutAffiliateInput
    coupons?: CouponCreateNestedManyWithoutAffiliateInput
  }

  export type AffiliateProfileUncheckedCreateWithoutApplicationsInput = {
    id?: string
    userId: string
    companyName?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: $Enums.PaymentMethod
    paymentEmail?: string | null
    taxId?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    tier?: $Enums.AffiliateTier
    commissionRate?: number
    totalEarnings?: number
    totalClicks?: number
    totalConversions?: number
    conversionRate?: number
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clicks?: ClickUncheckedCreateNestedManyWithoutAffiliateInput
    conversions?: ConversionUncheckedCreateNestedManyWithoutAffiliateInput
    commissions?: CommissionUncheckedCreateNestedManyWithoutAffiliateInput
    payouts?: PayoutUncheckedCreateNestedManyWithoutAffiliateInput
    links?: AffiliateLinkUncheckedCreateNestedManyWithoutAffiliateInput
    coupons?: CouponUncheckedCreateNestedManyWithoutAffiliateInput
  }

  export type AffiliateProfileCreateOrConnectWithoutApplicationsInput = {
    where: AffiliateProfileWhereUniqueInput
    create: XOR<AffiliateProfileCreateWithoutApplicationsInput, AffiliateProfileUncheckedCreateWithoutApplicationsInput>
  }

  export type OfferCreateWithoutApplicationsInput = {
    id?: string
    name: string
    description: string
    category: string
    commissionRate: number
    status?: $Enums.OfferStatus
    startDate: Date | string
    endDate?: Date | string | null
    terms?: string | null
    requirements?: string | null
    totalClicks?: number
    totalConversions?: number
    totalRevenue?: number
    totalCommissions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    conversions?: ConversionCreateNestedManyWithoutOfferInput
    links?: AffiliateLinkCreateNestedManyWithoutOfferInput
    creatives?: CreativeCreateNestedManyWithoutOfferInput
  }

  export type OfferUncheckedCreateWithoutApplicationsInput = {
    id?: string
    name: string
    description: string
    category: string
    commissionRate: number
    status?: $Enums.OfferStatus
    startDate: Date | string
    endDate?: Date | string | null
    terms?: string | null
    requirements?: string | null
    totalClicks?: number
    totalConversions?: number
    totalRevenue?: number
    totalCommissions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    conversions?: ConversionUncheckedCreateNestedManyWithoutOfferInput
    links?: AffiliateLinkUncheckedCreateNestedManyWithoutOfferInput
    creatives?: CreativeUncheckedCreateNestedManyWithoutOfferInput
  }

  export type OfferCreateOrConnectWithoutApplicationsInput = {
    where: OfferWhereUniqueInput
    create: XOR<OfferCreateWithoutApplicationsInput, OfferUncheckedCreateWithoutApplicationsInput>
  }

  export type AffiliateProfileUpsertWithoutApplicationsInput = {
    update: XOR<AffiliateProfileUpdateWithoutApplicationsInput, AffiliateProfileUncheckedUpdateWithoutApplicationsInput>
    create: XOR<AffiliateProfileCreateWithoutApplicationsInput, AffiliateProfileUncheckedCreateWithoutApplicationsInput>
    where?: AffiliateProfileWhereInput
  }

  export type AffiliateProfileUpdateToOneWithWhereWithoutApplicationsInput = {
    where?: AffiliateProfileWhereInput
    data: XOR<AffiliateProfileUpdateWithoutApplicationsInput, AffiliateProfileUncheckedUpdateWithoutApplicationsInput>
  }

  export type AffiliateProfileUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    tier?: EnumAffiliateTierFieldUpdateOperationsInput | $Enums.AffiliateTier
    commissionRate?: FloatFieldUpdateOperationsInput | number
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAffiliateProfileNestedInput
    clicks?: ClickUpdateManyWithoutAffiliateNestedInput
    conversions?: ConversionUpdateManyWithoutAffiliateNestedInput
    commissions?: CommissionUpdateManyWithoutAffiliateNestedInput
    payouts?: PayoutUpdateManyWithoutAffiliateNestedInput
    links?: AffiliateLinkUpdateManyWithoutAffiliateNestedInput
    coupons?: CouponUpdateManyWithoutAffiliateNestedInput
  }

  export type AffiliateProfileUncheckedUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    tier?: EnumAffiliateTierFieldUpdateOperationsInput | $Enums.AffiliateTier
    commissionRate?: FloatFieldUpdateOperationsInput | number
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clicks?: ClickUncheckedUpdateManyWithoutAffiliateNestedInput
    conversions?: ConversionUncheckedUpdateManyWithoutAffiliateNestedInput
    commissions?: CommissionUncheckedUpdateManyWithoutAffiliateNestedInput
    payouts?: PayoutUncheckedUpdateManyWithoutAffiliateNestedInput
    links?: AffiliateLinkUncheckedUpdateManyWithoutAffiliateNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutAffiliateNestedInput
  }

  export type OfferUpsertWithoutApplicationsInput = {
    update: XOR<OfferUpdateWithoutApplicationsInput, OfferUncheckedUpdateWithoutApplicationsInput>
    create: XOR<OfferCreateWithoutApplicationsInput, OfferUncheckedCreateWithoutApplicationsInput>
    where?: OfferWhereInput
  }

  export type OfferUpdateToOneWithWhereWithoutApplicationsInput = {
    where?: OfferWhereInput
    data: XOR<OfferUpdateWithoutApplicationsInput, OfferUncheckedUpdateWithoutApplicationsInput>
  }

  export type OfferUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    commissionRate?: FloatFieldUpdateOperationsInput | number
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    totalCommissions?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversions?: ConversionUpdateManyWithoutOfferNestedInput
    links?: AffiliateLinkUpdateManyWithoutOfferNestedInput
    creatives?: CreativeUpdateManyWithoutOfferNestedInput
  }

  export type OfferUncheckedUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    commissionRate?: FloatFieldUpdateOperationsInput | number
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    totalCommissions?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversions?: ConversionUncheckedUpdateManyWithoutOfferNestedInput
    links?: AffiliateLinkUncheckedUpdateManyWithoutOfferNestedInput
    creatives?: CreativeUncheckedUpdateManyWithoutOfferNestedInput
  }

  export type AffiliateProfileCreateWithoutLinksInput = {
    id?: string
    companyName?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: $Enums.PaymentMethod
    paymentEmail?: string | null
    taxId?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    tier?: $Enums.AffiliateTier
    commissionRate?: number
    totalEarnings?: number
    totalClicks?: number
    totalConversions?: number
    conversionRate?: number
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAffiliateProfileInput
    clicks?: ClickCreateNestedManyWithoutAffiliateInput
    conversions?: ConversionCreateNestedManyWithoutAffiliateInput
    commissions?: CommissionCreateNestedManyWithoutAffiliateInput
    payouts?: PayoutCreateNestedManyWithoutAffiliateInput
    coupons?: CouponCreateNestedManyWithoutAffiliateInput
    applications?: OfferApplicationCreateNestedManyWithoutAffiliateInput
  }

  export type AffiliateProfileUncheckedCreateWithoutLinksInput = {
    id?: string
    userId: string
    companyName?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: $Enums.PaymentMethod
    paymentEmail?: string | null
    taxId?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    tier?: $Enums.AffiliateTier
    commissionRate?: number
    totalEarnings?: number
    totalClicks?: number
    totalConversions?: number
    conversionRate?: number
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clicks?: ClickUncheckedCreateNestedManyWithoutAffiliateInput
    conversions?: ConversionUncheckedCreateNestedManyWithoutAffiliateInput
    commissions?: CommissionUncheckedCreateNestedManyWithoutAffiliateInput
    payouts?: PayoutUncheckedCreateNestedManyWithoutAffiliateInput
    coupons?: CouponUncheckedCreateNestedManyWithoutAffiliateInput
    applications?: OfferApplicationUncheckedCreateNestedManyWithoutAffiliateInput
  }

  export type AffiliateProfileCreateOrConnectWithoutLinksInput = {
    where: AffiliateProfileWhereUniqueInput
    create: XOR<AffiliateProfileCreateWithoutLinksInput, AffiliateProfileUncheckedCreateWithoutLinksInput>
  }

  export type OfferCreateWithoutLinksInput = {
    id?: string
    name: string
    description: string
    category: string
    commissionRate: number
    status?: $Enums.OfferStatus
    startDate: Date | string
    endDate?: Date | string | null
    terms?: string | null
    requirements?: string | null
    totalClicks?: number
    totalConversions?: number
    totalRevenue?: number
    totalCommissions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: OfferApplicationCreateNestedManyWithoutOfferInput
    conversions?: ConversionCreateNestedManyWithoutOfferInput
    creatives?: CreativeCreateNestedManyWithoutOfferInput
  }

  export type OfferUncheckedCreateWithoutLinksInput = {
    id?: string
    name: string
    description: string
    category: string
    commissionRate: number
    status?: $Enums.OfferStatus
    startDate: Date | string
    endDate?: Date | string | null
    terms?: string | null
    requirements?: string | null
    totalClicks?: number
    totalConversions?: number
    totalRevenue?: number
    totalCommissions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: OfferApplicationUncheckedCreateNestedManyWithoutOfferInput
    conversions?: ConversionUncheckedCreateNestedManyWithoutOfferInput
    creatives?: CreativeUncheckedCreateNestedManyWithoutOfferInput
  }

  export type OfferCreateOrConnectWithoutLinksInput = {
    where: OfferWhereUniqueInput
    create: XOR<OfferCreateWithoutLinksInput, OfferUncheckedCreateWithoutLinksInput>
  }

  export type ClickCreateWithoutLinkInput = {
    id?: string
    ipAddress: string
    userAgent: string
    referrer?: string | null
    country?: string | null
    city?: string | null
    device?: string | null
    browser?: string | null
    os?: string | null
    converted?: boolean
    conversionId?: string | null
    createdAt?: Date | string
    affiliate: AffiliateProfileCreateNestedOneWithoutClicksInput
    conversion?: ConversionCreateNestedOneWithoutClickInput
  }

  export type ClickUncheckedCreateWithoutLinkInput = {
    id?: string
    affiliateId: string
    ipAddress: string
    userAgent: string
    referrer?: string | null
    country?: string | null
    city?: string | null
    device?: string | null
    browser?: string | null
    os?: string | null
    converted?: boolean
    conversionId?: string | null
    createdAt?: Date | string
    conversion?: ConversionUncheckedCreateNestedOneWithoutClickInput
  }

  export type ClickCreateOrConnectWithoutLinkInput = {
    where: ClickWhereUniqueInput
    create: XOR<ClickCreateWithoutLinkInput, ClickUncheckedCreateWithoutLinkInput>
  }

  export type ClickCreateManyLinkInputEnvelope = {
    data: ClickCreateManyLinkInput | ClickCreateManyLinkInput[]
    skipDuplicates?: boolean
  }

  export type AffiliateProfileUpsertWithoutLinksInput = {
    update: XOR<AffiliateProfileUpdateWithoutLinksInput, AffiliateProfileUncheckedUpdateWithoutLinksInput>
    create: XOR<AffiliateProfileCreateWithoutLinksInput, AffiliateProfileUncheckedCreateWithoutLinksInput>
    where?: AffiliateProfileWhereInput
  }

  export type AffiliateProfileUpdateToOneWithWhereWithoutLinksInput = {
    where?: AffiliateProfileWhereInput
    data: XOR<AffiliateProfileUpdateWithoutLinksInput, AffiliateProfileUncheckedUpdateWithoutLinksInput>
  }

  export type AffiliateProfileUpdateWithoutLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    tier?: EnumAffiliateTierFieldUpdateOperationsInput | $Enums.AffiliateTier
    commissionRate?: FloatFieldUpdateOperationsInput | number
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAffiliateProfileNestedInput
    clicks?: ClickUpdateManyWithoutAffiliateNestedInput
    conversions?: ConversionUpdateManyWithoutAffiliateNestedInput
    commissions?: CommissionUpdateManyWithoutAffiliateNestedInput
    payouts?: PayoutUpdateManyWithoutAffiliateNestedInput
    coupons?: CouponUpdateManyWithoutAffiliateNestedInput
    applications?: OfferApplicationUpdateManyWithoutAffiliateNestedInput
  }

  export type AffiliateProfileUncheckedUpdateWithoutLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    tier?: EnumAffiliateTierFieldUpdateOperationsInput | $Enums.AffiliateTier
    commissionRate?: FloatFieldUpdateOperationsInput | number
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clicks?: ClickUncheckedUpdateManyWithoutAffiliateNestedInput
    conversions?: ConversionUncheckedUpdateManyWithoutAffiliateNestedInput
    commissions?: CommissionUncheckedUpdateManyWithoutAffiliateNestedInput
    payouts?: PayoutUncheckedUpdateManyWithoutAffiliateNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutAffiliateNestedInput
    applications?: OfferApplicationUncheckedUpdateManyWithoutAffiliateNestedInput
  }

  export type OfferUpsertWithoutLinksInput = {
    update: XOR<OfferUpdateWithoutLinksInput, OfferUncheckedUpdateWithoutLinksInput>
    create: XOR<OfferCreateWithoutLinksInput, OfferUncheckedCreateWithoutLinksInput>
    where?: OfferWhereInput
  }

  export type OfferUpdateToOneWithWhereWithoutLinksInput = {
    where?: OfferWhereInput
    data: XOR<OfferUpdateWithoutLinksInput, OfferUncheckedUpdateWithoutLinksInput>
  }

  export type OfferUpdateWithoutLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    commissionRate?: FloatFieldUpdateOperationsInput | number
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    totalCommissions?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: OfferApplicationUpdateManyWithoutOfferNestedInput
    conversions?: ConversionUpdateManyWithoutOfferNestedInput
    creatives?: CreativeUpdateManyWithoutOfferNestedInput
  }

  export type OfferUncheckedUpdateWithoutLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    commissionRate?: FloatFieldUpdateOperationsInput | number
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    totalCommissions?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: OfferApplicationUncheckedUpdateManyWithoutOfferNestedInput
    conversions?: ConversionUncheckedUpdateManyWithoutOfferNestedInput
    creatives?: CreativeUncheckedUpdateManyWithoutOfferNestedInput
  }

  export type ClickUpsertWithWhereUniqueWithoutLinkInput = {
    where: ClickWhereUniqueInput
    update: XOR<ClickUpdateWithoutLinkInput, ClickUncheckedUpdateWithoutLinkInput>
    create: XOR<ClickCreateWithoutLinkInput, ClickUncheckedCreateWithoutLinkInput>
  }

  export type ClickUpdateWithWhereUniqueWithoutLinkInput = {
    where: ClickWhereUniqueInput
    data: XOR<ClickUpdateWithoutLinkInput, ClickUncheckedUpdateWithoutLinkInput>
  }

  export type ClickUpdateManyWithWhereWithoutLinkInput = {
    where: ClickScalarWhereInput
    data: XOR<ClickUpdateManyMutationInput, ClickUncheckedUpdateManyWithoutLinkInput>
  }

  export type AffiliateLinkCreateWithoutClickRecordsInput = {
    id?: string
    originalUrl: string
    shortUrl: string
    customSlug?: string | null
    clicks?: number
    conversions?: number
    earnings?: number
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    affiliate: AffiliateProfileCreateNestedOneWithoutLinksInput
    offer?: OfferCreateNestedOneWithoutLinksInput
  }

  export type AffiliateLinkUncheckedCreateWithoutClickRecordsInput = {
    id?: string
    affiliateId: string
    offerId?: string | null
    originalUrl: string
    shortUrl: string
    customSlug?: string | null
    clicks?: number
    conversions?: number
    earnings?: number
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AffiliateLinkCreateOrConnectWithoutClickRecordsInput = {
    where: AffiliateLinkWhereUniqueInput
    create: XOR<AffiliateLinkCreateWithoutClickRecordsInput, AffiliateLinkUncheckedCreateWithoutClickRecordsInput>
  }

  export type AffiliateProfileCreateWithoutClicksInput = {
    id?: string
    companyName?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: $Enums.PaymentMethod
    paymentEmail?: string | null
    taxId?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    tier?: $Enums.AffiliateTier
    commissionRate?: number
    totalEarnings?: number
    totalClicks?: number
    totalConversions?: number
    conversionRate?: number
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAffiliateProfileInput
    conversions?: ConversionCreateNestedManyWithoutAffiliateInput
    commissions?: CommissionCreateNestedManyWithoutAffiliateInput
    payouts?: PayoutCreateNestedManyWithoutAffiliateInput
    links?: AffiliateLinkCreateNestedManyWithoutAffiliateInput
    coupons?: CouponCreateNestedManyWithoutAffiliateInput
    applications?: OfferApplicationCreateNestedManyWithoutAffiliateInput
  }

  export type AffiliateProfileUncheckedCreateWithoutClicksInput = {
    id?: string
    userId: string
    companyName?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: $Enums.PaymentMethod
    paymentEmail?: string | null
    taxId?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    tier?: $Enums.AffiliateTier
    commissionRate?: number
    totalEarnings?: number
    totalClicks?: number
    totalConversions?: number
    conversionRate?: number
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conversions?: ConversionUncheckedCreateNestedManyWithoutAffiliateInput
    commissions?: CommissionUncheckedCreateNestedManyWithoutAffiliateInput
    payouts?: PayoutUncheckedCreateNestedManyWithoutAffiliateInput
    links?: AffiliateLinkUncheckedCreateNestedManyWithoutAffiliateInput
    coupons?: CouponUncheckedCreateNestedManyWithoutAffiliateInput
    applications?: OfferApplicationUncheckedCreateNestedManyWithoutAffiliateInput
  }

  export type AffiliateProfileCreateOrConnectWithoutClicksInput = {
    where: AffiliateProfileWhereUniqueInput
    create: XOR<AffiliateProfileCreateWithoutClicksInput, AffiliateProfileUncheckedCreateWithoutClicksInput>
  }

  export type ConversionCreateWithoutClickInput = {
    id?: string
    customerEmail?: string | null
    customerValue: number
    commissionAmount: number
    status?: $Enums.ConversionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    affiliate: AffiliateProfileCreateNestedOneWithoutConversionsInput
    offer: OfferCreateNestedOneWithoutConversionsInput
    commission?: CommissionCreateNestedOneWithoutConversionInput
  }

  export type ConversionUncheckedCreateWithoutClickInput = {
    id?: string
    affiliateId: string
    offerId: string
    customerEmail?: string | null
    customerValue: number
    commissionAmount: number
    status?: $Enums.ConversionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    commission?: CommissionUncheckedCreateNestedOneWithoutConversionInput
  }

  export type ConversionCreateOrConnectWithoutClickInput = {
    where: ConversionWhereUniqueInput
    create: XOR<ConversionCreateWithoutClickInput, ConversionUncheckedCreateWithoutClickInput>
  }

  export type AffiliateLinkUpsertWithoutClickRecordsInput = {
    update: XOR<AffiliateLinkUpdateWithoutClickRecordsInput, AffiliateLinkUncheckedUpdateWithoutClickRecordsInput>
    create: XOR<AffiliateLinkCreateWithoutClickRecordsInput, AffiliateLinkUncheckedCreateWithoutClickRecordsInput>
    where?: AffiliateLinkWhereInput
  }

  export type AffiliateLinkUpdateToOneWithWhereWithoutClickRecordsInput = {
    where?: AffiliateLinkWhereInput
    data: XOR<AffiliateLinkUpdateWithoutClickRecordsInput, AffiliateLinkUncheckedUpdateWithoutClickRecordsInput>
  }

  export type AffiliateLinkUpdateWithoutClickRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    shortUrl?: StringFieldUpdateOperationsInput | string
    customSlug?: NullableStringFieldUpdateOperationsInput | string | null
    clicks?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    earnings?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliate?: AffiliateProfileUpdateOneRequiredWithoutLinksNestedInput
    offer?: OfferUpdateOneWithoutLinksNestedInput
  }

  export type AffiliateLinkUncheckedUpdateWithoutClickRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliateId?: StringFieldUpdateOperationsInput | string
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    originalUrl?: StringFieldUpdateOperationsInput | string
    shortUrl?: StringFieldUpdateOperationsInput | string
    customSlug?: NullableStringFieldUpdateOperationsInput | string | null
    clicks?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    earnings?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AffiliateProfileUpsertWithoutClicksInput = {
    update: XOR<AffiliateProfileUpdateWithoutClicksInput, AffiliateProfileUncheckedUpdateWithoutClicksInput>
    create: XOR<AffiliateProfileCreateWithoutClicksInput, AffiliateProfileUncheckedCreateWithoutClicksInput>
    where?: AffiliateProfileWhereInput
  }

  export type AffiliateProfileUpdateToOneWithWhereWithoutClicksInput = {
    where?: AffiliateProfileWhereInput
    data: XOR<AffiliateProfileUpdateWithoutClicksInput, AffiliateProfileUncheckedUpdateWithoutClicksInput>
  }

  export type AffiliateProfileUpdateWithoutClicksInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    tier?: EnumAffiliateTierFieldUpdateOperationsInput | $Enums.AffiliateTier
    commissionRate?: FloatFieldUpdateOperationsInput | number
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAffiliateProfileNestedInput
    conversions?: ConversionUpdateManyWithoutAffiliateNestedInput
    commissions?: CommissionUpdateManyWithoutAffiliateNestedInput
    payouts?: PayoutUpdateManyWithoutAffiliateNestedInput
    links?: AffiliateLinkUpdateManyWithoutAffiliateNestedInput
    coupons?: CouponUpdateManyWithoutAffiliateNestedInput
    applications?: OfferApplicationUpdateManyWithoutAffiliateNestedInput
  }

  export type AffiliateProfileUncheckedUpdateWithoutClicksInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    tier?: EnumAffiliateTierFieldUpdateOperationsInput | $Enums.AffiliateTier
    commissionRate?: FloatFieldUpdateOperationsInput | number
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversions?: ConversionUncheckedUpdateManyWithoutAffiliateNestedInput
    commissions?: CommissionUncheckedUpdateManyWithoutAffiliateNestedInput
    payouts?: PayoutUncheckedUpdateManyWithoutAffiliateNestedInput
    links?: AffiliateLinkUncheckedUpdateManyWithoutAffiliateNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutAffiliateNestedInput
    applications?: OfferApplicationUncheckedUpdateManyWithoutAffiliateNestedInput
  }

  export type ConversionUpsertWithoutClickInput = {
    update: XOR<ConversionUpdateWithoutClickInput, ConversionUncheckedUpdateWithoutClickInput>
    create: XOR<ConversionCreateWithoutClickInput, ConversionUncheckedCreateWithoutClickInput>
    where?: ConversionWhereInput
  }

  export type ConversionUpdateToOneWithWhereWithoutClickInput = {
    where?: ConversionWhereInput
    data: XOR<ConversionUpdateWithoutClickInput, ConversionUncheckedUpdateWithoutClickInput>
  }

  export type ConversionUpdateWithoutClickInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerValue?: FloatFieldUpdateOperationsInput | number
    commissionAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumConversionStatusFieldUpdateOperationsInput | $Enums.ConversionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliate?: AffiliateProfileUpdateOneRequiredWithoutConversionsNestedInput
    offer?: OfferUpdateOneRequiredWithoutConversionsNestedInput
    commission?: CommissionUpdateOneWithoutConversionNestedInput
  }

  export type ConversionUncheckedUpdateWithoutClickInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliateId?: StringFieldUpdateOperationsInput | string
    offerId?: StringFieldUpdateOperationsInput | string
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerValue?: FloatFieldUpdateOperationsInput | number
    commissionAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumConversionStatusFieldUpdateOperationsInput | $Enums.ConversionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commission?: CommissionUncheckedUpdateOneWithoutConversionNestedInput
  }

  export type ClickCreateWithoutConversionInput = {
    id?: string
    ipAddress: string
    userAgent: string
    referrer?: string | null
    country?: string | null
    city?: string | null
    device?: string | null
    browser?: string | null
    os?: string | null
    converted?: boolean
    conversionId?: string | null
    createdAt?: Date | string
    link: AffiliateLinkCreateNestedOneWithoutClickRecordsInput
    affiliate: AffiliateProfileCreateNestedOneWithoutClicksInput
  }

  export type ClickUncheckedCreateWithoutConversionInput = {
    id?: string
    linkId: string
    affiliateId: string
    ipAddress: string
    userAgent: string
    referrer?: string | null
    country?: string | null
    city?: string | null
    device?: string | null
    browser?: string | null
    os?: string | null
    converted?: boolean
    conversionId?: string | null
    createdAt?: Date | string
  }

  export type ClickCreateOrConnectWithoutConversionInput = {
    where: ClickWhereUniqueInput
    create: XOR<ClickCreateWithoutConversionInput, ClickUncheckedCreateWithoutConversionInput>
  }

  export type AffiliateProfileCreateWithoutConversionsInput = {
    id?: string
    companyName?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: $Enums.PaymentMethod
    paymentEmail?: string | null
    taxId?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    tier?: $Enums.AffiliateTier
    commissionRate?: number
    totalEarnings?: number
    totalClicks?: number
    totalConversions?: number
    conversionRate?: number
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAffiliateProfileInput
    clicks?: ClickCreateNestedManyWithoutAffiliateInput
    commissions?: CommissionCreateNestedManyWithoutAffiliateInput
    payouts?: PayoutCreateNestedManyWithoutAffiliateInput
    links?: AffiliateLinkCreateNestedManyWithoutAffiliateInput
    coupons?: CouponCreateNestedManyWithoutAffiliateInput
    applications?: OfferApplicationCreateNestedManyWithoutAffiliateInput
  }

  export type AffiliateProfileUncheckedCreateWithoutConversionsInput = {
    id?: string
    userId: string
    companyName?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: $Enums.PaymentMethod
    paymentEmail?: string | null
    taxId?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    tier?: $Enums.AffiliateTier
    commissionRate?: number
    totalEarnings?: number
    totalClicks?: number
    totalConversions?: number
    conversionRate?: number
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clicks?: ClickUncheckedCreateNestedManyWithoutAffiliateInput
    commissions?: CommissionUncheckedCreateNestedManyWithoutAffiliateInput
    payouts?: PayoutUncheckedCreateNestedManyWithoutAffiliateInput
    links?: AffiliateLinkUncheckedCreateNestedManyWithoutAffiliateInput
    coupons?: CouponUncheckedCreateNestedManyWithoutAffiliateInput
    applications?: OfferApplicationUncheckedCreateNestedManyWithoutAffiliateInput
  }

  export type AffiliateProfileCreateOrConnectWithoutConversionsInput = {
    where: AffiliateProfileWhereUniqueInput
    create: XOR<AffiliateProfileCreateWithoutConversionsInput, AffiliateProfileUncheckedCreateWithoutConversionsInput>
  }

  export type OfferCreateWithoutConversionsInput = {
    id?: string
    name: string
    description: string
    category: string
    commissionRate: number
    status?: $Enums.OfferStatus
    startDate: Date | string
    endDate?: Date | string | null
    terms?: string | null
    requirements?: string | null
    totalClicks?: number
    totalConversions?: number
    totalRevenue?: number
    totalCommissions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: OfferApplicationCreateNestedManyWithoutOfferInput
    links?: AffiliateLinkCreateNestedManyWithoutOfferInput
    creatives?: CreativeCreateNestedManyWithoutOfferInput
  }

  export type OfferUncheckedCreateWithoutConversionsInput = {
    id?: string
    name: string
    description: string
    category: string
    commissionRate: number
    status?: $Enums.OfferStatus
    startDate: Date | string
    endDate?: Date | string | null
    terms?: string | null
    requirements?: string | null
    totalClicks?: number
    totalConversions?: number
    totalRevenue?: number
    totalCommissions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: OfferApplicationUncheckedCreateNestedManyWithoutOfferInput
    links?: AffiliateLinkUncheckedCreateNestedManyWithoutOfferInput
    creatives?: CreativeUncheckedCreateNestedManyWithoutOfferInput
  }

  export type OfferCreateOrConnectWithoutConversionsInput = {
    where: OfferWhereUniqueInput
    create: XOR<OfferCreateWithoutConversionsInput, OfferUncheckedCreateWithoutConversionsInput>
  }

  export type CommissionCreateWithoutConversionInput = {
    id?: string
    amount: number
    rate: number
    status?: $Enums.CommissionStatus
    payoutDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    affiliate: AffiliateProfileCreateNestedOneWithoutCommissionsInput
    payout?: PayoutCreateNestedOneWithoutCommissionsInput
  }

  export type CommissionUncheckedCreateWithoutConversionInput = {
    id?: string
    affiliateId: string
    payoutId?: string | null
    amount: number
    rate: number
    status?: $Enums.CommissionStatus
    payoutDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommissionCreateOrConnectWithoutConversionInput = {
    where: CommissionWhereUniqueInput
    create: XOR<CommissionCreateWithoutConversionInput, CommissionUncheckedCreateWithoutConversionInput>
  }

  export type ClickUpsertWithoutConversionInput = {
    update: XOR<ClickUpdateWithoutConversionInput, ClickUncheckedUpdateWithoutConversionInput>
    create: XOR<ClickCreateWithoutConversionInput, ClickUncheckedCreateWithoutConversionInput>
    where?: ClickWhereInput
  }

  export type ClickUpdateToOneWithWhereWithoutConversionInput = {
    where?: ClickWhereInput
    data: XOR<ClickUpdateWithoutConversionInput, ClickUncheckedUpdateWithoutConversionInput>
  }

  export type ClickUpdateWithoutConversionInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    converted?: BoolFieldUpdateOperationsInput | boolean
    conversionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    link?: AffiliateLinkUpdateOneRequiredWithoutClickRecordsNestedInput
    affiliate?: AffiliateProfileUpdateOneRequiredWithoutClicksNestedInput
  }

  export type ClickUncheckedUpdateWithoutConversionInput = {
    id?: StringFieldUpdateOperationsInput | string
    linkId?: StringFieldUpdateOperationsInput | string
    affiliateId?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    converted?: BoolFieldUpdateOperationsInput | boolean
    conversionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AffiliateProfileUpsertWithoutConversionsInput = {
    update: XOR<AffiliateProfileUpdateWithoutConversionsInput, AffiliateProfileUncheckedUpdateWithoutConversionsInput>
    create: XOR<AffiliateProfileCreateWithoutConversionsInput, AffiliateProfileUncheckedCreateWithoutConversionsInput>
    where?: AffiliateProfileWhereInput
  }

  export type AffiliateProfileUpdateToOneWithWhereWithoutConversionsInput = {
    where?: AffiliateProfileWhereInput
    data: XOR<AffiliateProfileUpdateWithoutConversionsInput, AffiliateProfileUncheckedUpdateWithoutConversionsInput>
  }

  export type AffiliateProfileUpdateWithoutConversionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    tier?: EnumAffiliateTierFieldUpdateOperationsInput | $Enums.AffiliateTier
    commissionRate?: FloatFieldUpdateOperationsInput | number
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAffiliateProfileNestedInput
    clicks?: ClickUpdateManyWithoutAffiliateNestedInput
    commissions?: CommissionUpdateManyWithoutAffiliateNestedInput
    payouts?: PayoutUpdateManyWithoutAffiliateNestedInput
    links?: AffiliateLinkUpdateManyWithoutAffiliateNestedInput
    coupons?: CouponUpdateManyWithoutAffiliateNestedInput
    applications?: OfferApplicationUpdateManyWithoutAffiliateNestedInput
  }

  export type AffiliateProfileUncheckedUpdateWithoutConversionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    tier?: EnumAffiliateTierFieldUpdateOperationsInput | $Enums.AffiliateTier
    commissionRate?: FloatFieldUpdateOperationsInput | number
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clicks?: ClickUncheckedUpdateManyWithoutAffiliateNestedInput
    commissions?: CommissionUncheckedUpdateManyWithoutAffiliateNestedInput
    payouts?: PayoutUncheckedUpdateManyWithoutAffiliateNestedInput
    links?: AffiliateLinkUncheckedUpdateManyWithoutAffiliateNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutAffiliateNestedInput
    applications?: OfferApplicationUncheckedUpdateManyWithoutAffiliateNestedInput
  }

  export type OfferUpsertWithoutConversionsInput = {
    update: XOR<OfferUpdateWithoutConversionsInput, OfferUncheckedUpdateWithoutConversionsInput>
    create: XOR<OfferCreateWithoutConversionsInput, OfferUncheckedCreateWithoutConversionsInput>
    where?: OfferWhereInput
  }

  export type OfferUpdateToOneWithWhereWithoutConversionsInput = {
    where?: OfferWhereInput
    data: XOR<OfferUpdateWithoutConversionsInput, OfferUncheckedUpdateWithoutConversionsInput>
  }

  export type OfferUpdateWithoutConversionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    commissionRate?: FloatFieldUpdateOperationsInput | number
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    totalCommissions?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: OfferApplicationUpdateManyWithoutOfferNestedInput
    links?: AffiliateLinkUpdateManyWithoutOfferNestedInput
    creatives?: CreativeUpdateManyWithoutOfferNestedInput
  }

  export type OfferUncheckedUpdateWithoutConversionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    commissionRate?: FloatFieldUpdateOperationsInput | number
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    totalCommissions?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: OfferApplicationUncheckedUpdateManyWithoutOfferNestedInput
    links?: AffiliateLinkUncheckedUpdateManyWithoutOfferNestedInput
    creatives?: CreativeUncheckedUpdateManyWithoutOfferNestedInput
  }

  export type CommissionUpsertWithoutConversionInput = {
    update: XOR<CommissionUpdateWithoutConversionInput, CommissionUncheckedUpdateWithoutConversionInput>
    create: XOR<CommissionCreateWithoutConversionInput, CommissionUncheckedCreateWithoutConversionInput>
    where?: CommissionWhereInput
  }

  export type CommissionUpdateToOneWithWhereWithoutConversionInput = {
    where?: CommissionWhereInput
    data: XOR<CommissionUpdateWithoutConversionInput, CommissionUncheckedUpdateWithoutConversionInput>
  }

  export type CommissionUpdateWithoutConversionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    status?: EnumCommissionStatusFieldUpdateOperationsInput | $Enums.CommissionStatus
    payoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliate?: AffiliateProfileUpdateOneRequiredWithoutCommissionsNestedInput
    payout?: PayoutUpdateOneWithoutCommissionsNestedInput
  }

  export type CommissionUncheckedUpdateWithoutConversionInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliateId?: StringFieldUpdateOperationsInput | string
    payoutId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    status?: EnumCommissionStatusFieldUpdateOperationsInput | $Enums.CommissionStatus
    payoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversionCreateWithoutCommissionInput = {
    id?: string
    customerEmail?: string | null
    customerValue: number
    commissionAmount: number
    status?: $Enums.ConversionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    click: ClickCreateNestedOneWithoutConversionInput
    affiliate: AffiliateProfileCreateNestedOneWithoutConversionsInput
    offer: OfferCreateNestedOneWithoutConversionsInput
  }

  export type ConversionUncheckedCreateWithoutCommissionInput = {
    id?: string
    clickId: string
    affiliateId: string
    offerId: string
    customerEmail?: string | null
    customerValue: number
    commissionAmount: number
    status?: $Enums.ConversionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversionCreateOrConnectWithoutCommissionInput = {
    where: ConversionWhereUniqueInput
    create: XOR<ConversionCreateWithoutCommissionInput, ConversionUncheckedCreateWithoutCommissionInput>
  }

  export type AffiliateProfileCreateWithoutCommissionsInput = {
    id?: string
    companyName?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: $Enums.PaymentMethod
    paymentEmail?: string | null
    taxId?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    tier?: $Enums.AffiliateTier
    commissionRate?: number
    totalEarnings?: number
    totalClicks?: number
    totalConversions?: number
    conversionRate?: number
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAffiliateProfileInput
    clicks?: ClickCreateNestedManyWithoutAffiliateInput
    conversions?: ConversionCreateNestedManyWithoutAffiliateInput
    payouts?: PayoutCreateNestedManyWithoutAffiliateInput
    links?: AffiliateLinkCreateNestedManyWithoutAffiliateInput
    coupons?: CouponCreateNestedManyWithoutAffiliateInput
    applications?: OfferApplicationCreateNestedManyWithoutAffiliateInput
  }

  export type AffiliateProfileUncheckedCreateWithoutCommissionsInput = {
    id?: string
    userId: string
    companyName?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: $Enums.PaymentMethod
    paymentEmail?: string | null
    taxId?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    tier?: $Enums.AffiliateTier
    commissionRate?: number
    totalEarnings?: number
    totalClicks?: number
    totalConversions?: number
    conversionRate?: number
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clicks?: ClickUncheckedCreateNestedManyWithoutAffiliateInput
    conversions?: ConversionUncheckedCreateNestedManyWithoutAffiliateInput
    payouts?: PayoutUncheckedCreateNestedManyWithoutAffiliateInput
    links?: AffiliateLinkUncheckedCreateNestedManyWithoutAffiliateInput
    coupons?: CouponUncheckedCreateNestedManyWithoutAffiliateInput
    applications?: OfferApplicationUncheckedCreateNestedManyWithoutAffiliateInput
  }

  export type AffiliateProfileCreateOrConnectWithoutCommissionsInput = {
    where: AffiliateProfileWhereUniqueInput
    create: XOR<AffiliateProfileCreateWithoutCommissionsInput, AffiliateProfileUncheckedCreateWithoutCommissionsInput>
  }

  export type PayoutCreateWithoutCommissionsInput = {
    id?: string
    amount: number
    method: $Enums.PaymentMethod
    status?: $Enums.PayoutStatus
    referenceId?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    affiliate: AffiliateProfileCreateNestedOneWithoutPayoutsInput
  }

  export type PayoutUncheckedCreateWithoutCommissionsInput = {
    id?: string
    affiliateId: string
    amount: number
    method: $Enums.PaymentMethod
    status?: $Enums.PayoutStatus
    referenceId?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayoutCreateOrConnectWithoutCommissionsInput = {
    where: PayoutWhereUniqueInput
    create: XOR<PayoutCreateWithoutCommissionsInput, PayoutUncheckedCreateWithoutCommissionsInput>
  }

  export type ConversionUpsertWithoutCommissionInput = {
    update: XOR<ConversionUpdateWithoutCommissionInput, ConversionUncheckedUpdateWithoutCommissionInput>
    create: XOR<ConversionCreateWithoutCommissionInput, ConversionUncheckedCreateWithoutCommissionInput>
    where?: ConversionWhereInput
  }

  export type ConversionUpdateToOneWithWhereWithoutCommissionInput = {
    where?: ConversionWhereInput
    data: XOR<ConversionUpdateWithoutCommissionInput, ConversionUncheckedUpdateWithoutCommissionInput>
  }

  export type ConversionUpdateWithoutCommissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerValue?: FloatFieldUpdateOperationsInput | number
    commissionAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumConversionStatusFieldUpdateOperationsInput | $Enums.ConversionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    click?: ClickUpdateOneRequiredWithoutConversionNestedInput
    affiliate?: AffiliateProfileUpdateOneRequiredWithoutConversionsNestedInput
    offer?: OfferUpdateOneRequiredWithoutConversionsNestedInput
  }

  export type ConversionUncheckedUpdateWithoutCommissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    clickId?: StringFieldUpdateOperationsInput | string
    affiliateId?: StringFieldUpdateOperationsInput | string
    offerId?: StringFieldUpdateOperationsInput | string
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerValue?: FloatFieldUpdateOperationsInput | number
    commissionAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumConversionStatusFieldUpdateOperationsInput | $Enums.ConversionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AffiliateProfileUpsertWithoutCommissionsInput = {
    update: XOR<AffiliateProfileUpdateWithoutCommissionsInput, AffiliateProfileUncheckedUpdateWithoutCommissionsInput>
    create: XOR<AffiliateProfileCreateWithoutCommissionsInput, AffiliateProfileUncheckedCreateWithoutCommissionsInput>
    where?: AffiliateProfileWhereInput
  }

  export type AffiliateProfileUpdateToOneWithWhereWithoutCommissionsInput = {
    where?: AffiliateProfileWhereInput
    data: XOR<AffiliateProfileUpdateWithoutCommissionsInput, AffiliateProfileUncheckedUpdateWithoutCommissionsInput>
  }

  export type AffiliateProfileUpdateWithoutCommissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    tier?: EnumAffiliateTierFieldUpdateOperationsInput | $Enums.AffiliateTier
    commissionRate?: FloatFieldUpdateOperationsInput | number
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAffiliateProfileNestedInput
    clicks?: ClickUpdateManyWithoutAffiliateNestedInput
    conversions?: ConversionUpdateManyWithoutAffiliateNestedInput
    payouts?: PayoutUpdateManyWithoutAffiliateNestedInput
    links?: AffiliateLinkUpdateManyWithoutAffiliateNestedInput
    coupons?: CouponUpdateManyWithoutAffiliateNestedInput
    applications?: OfferApplicationUpdateManyWithoutAffiliateNestedInput
  }

  export type AffiliateProfileUncheckedUpdateWithoutCommissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    tier?: EnumAffiliateTierFieldUpdateOperationsInput | $Enums.AffiliateTier
    commissionRate?: FloatFieldUpdateOperationsInput | number
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clicks?: ClickUncheckedUpdateManyWithoutAffiliateNestedInput
    conversions?: ConversionUncheckedUpdateManyWithoutAffiliateNestedInput
    payouts?: PayoutUncheckedUpdateManyWithoutAffiliateNestedInput
    links?: AffiliateLinkUncheckedUpdateManyWithoutAffiliateNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutAffiliateNestedInput
    applications?: OfferApplicationUncheckedUpdateManyWithoutAffiliateNestedInput
  }

  export type PayoutUpsertWithoutCommissionsInput = {
    update: XOR<PayoutUpdateWithoutCommissionsInput, PayoutUncheckedUpdateWithoutCommissionsInput>
    create: XOR<PayoutCreateWithoutCommissionsInput, PayoutUncheckedCreateWithoutCommissionsInput>
    where?: PayoutWhereInput
  }

  export type PayoutUpdateToOneWithWhereWithoutCommissionsInput = {
    where?: PayoutWhereInput
    data: XOR<PayoutUpdateWithoutCommissionsInput, PayoutUncheckedUpdateWithoutCommissionsInput>
  }

  export type PayoutUpdateWithoutCommissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliate?: AffiliateProfileUpdateOneRequiredWithoutPayoutsNestedInput
  }

  export type PayoutUncheckedUpdateWithoutCommissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliateId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AffiliateProfileCreateWithoutPayoutsInput = {
    id?: string
    companyName?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: $Enums.PaymentMethod
    paymentEmail?: string | null
    taxId?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    tier?: $Enums.AffiliateTier
    commissionRate?: number
    totalEarnings?: number
    totalClicks?: number
    totalConversions?: number
    conversionRate?: number
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAffiliateProfileInput
    clicks?: ClickCreateNestedManyWithoutAffiliateInput
    conversions?: ConversionCreateNestedManyWithoutAffiliateInput
    commissions?: CommissionCreateNestedManyWithoutAffiliateInput
    links?: AffiliateLinkCreateNestedManyWithoutAffiliateInput
    coupons?: CouponCreateNestedManyWithoutAffiliateInput
    applications?: OfferApplicationCreateNestedManyWithoutAffiliateInput
  }

  export type AffiliateProfileUncheckedCreateWithoutPayoutsInput = {
    id?: string
    userId: string
    companyName?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: $Enums.PaymentMethod
    paymentEmail?: string | null
    taxId?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    tier?: $Enums.AffiliateTier
    commissionRate?: number
    totalEarnings?: number
    totalClicks?: number
    totalConversions?: number
    conversionRate?: number
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clicks?: ClickUncheckedCreateNestedManyWithoutAffiliateInput
    conversions?: ConversionUncheckedCreateNestedManyWithoutAffiliateInput
    commissions?: CommissionUncheckedCreateNestedManyWithoutAffiliateInput
    links?: AffiliateLinkUncheckedCreateNestedManyWithoutAffiliateInput
    coupons?: CouponUncheckedCreateNestedManyWithoutAffiliateInput
    applications?: OfferApplicationUncheckedCreateNestedManyWithoutAffiliateInput
  }

  export type AffiliateProfileCreateOrConnectWithoutPayoutsInput = {
    where: AffiliateProfileWhereUniqueInput
    create: XOR<AffiliateProfileCreateWithoutPayoutsInput, AffiliateProfileUncheckedCreateWithoutPayoutsInput>
  }

  export type CommissionCreateWithoutPayoutInput = {
    id?: string
    amount: number
    rate: number
    status?: $Enums.CommissionStatus
    payoutDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conversion: ConversionCreateNestedOneWithoutCommissionInput
    affiliate: AffiliateProfileCreateNestedOneWithoutCommissionsInput
  }

  export type CommissionUncheckedCreateWithoutPayoutInput = {
    id?: string
    conversionId: string
    affiliateId: string
    amount: number
    rate: number
    status?: $Enums.CommissionStatus
    payoutDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommissionCreateOrConnectWithoutPayoutInput = {
    where: CommissionWhereUniqueInput
    create: XOR<CommissionCreateWithoutPayoutInput, CommissionUncheckedCreateWithoutPayoutInput>
  }

  export type CommissionCreateManyPayoutInputEnvelope = {
    data: CommissionCreateManyPayoutInput | CommissionCreateManyPayoutInput[]
    skipDuplicates?: boolean
  }

  export type AffiliateProfileUpsertWithoutPayoutsInput = {
    update: XOR<AffiliateProfileUpdateWithoutPayoutsInput, AffiliateProfileUncheckedUpdateWithoutPayoutsInput>
    create: XOR<AffiliateProfileCreateWithoutPayoutsInput, AffiliateProfileUncheckedCreateWithoutPayoutsInput>
    where?: AffiliateProfileWhereInput
  }

  export type AffiliateProfileUpdateToOneWithWhereWithoutPayoutsInput = {
    where?: AffiliateProfileWhereInput
    data: XOR<AffiliateProfileUpdateWithoutPayoutsInput, AffiliateProfileUncheckedUpdateWithoutPayoutsInput>
  }

  export type AffiliateProfileUpdateWithoutPayoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    tier?: EnumAffiliateTierFieldUpdateOperationsInput | $Enums.AffiliateTier
    commissionRate?: FloatFieldUpdateOperationsInput | number
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAffiliateProfileNestedInput
    clicks?: ClickUpdateManyWithoutAffiliateNestedInput
    conversions?: ConversionUpdateManyWithoutAffiliateNestedInput
    commissions?: CommissionUpdateManyWithoutAffiliateNestedInput
    links?: AffiliateLinkUpdateManyWithoutAffiliateNestedInput
    coupons?: CouponUpdateManyWithoutAffiliateNestedInput
    applications?: OfferApplicationUpdateManyWithoutAffiliateNestedInput
  }

  export type AffiliateProfileUncheckedUpdateWithoutPayoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    tier?: EnumAffiliateTierFieldUpdateOperationsInput | $Enums.AffiliateTier
    commissionRate?: FloatFieldUpdateOperationsInput | number
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clicks?: ClickUncheckedUpdateManyWithoutAffiliateNestedInput
    conversions?: ConversionUncheckedUpdateManyWithoutAffiliateNestedInput
    commissions?: CommissionUncheckedUpdateManyWithoutAffiliateNestedInput
    links?: AffiliateLinkUncheckedUpdateManyWithoutAffiliateNestedInput
    coupons?: CouponUncheckedUpdateManyWithoutAffiliateNestedInput
    applications?: OfferApplicationUncheckedUpdateManyWithoutAffiliateNestedInput
  }

  export type CommissionUpsertWithWhereUniqueWithoutPayoutInput = {
    where: CommissionWhereUniqueInput
    update: XOR<CommissionUpdateWithoutPayoutInput, CommissionUncheckedUpdateWithoutPayoutInput>
    create: XOR<CommissionCreateWithoutPayoutInput, CommissionUncheckedCreateWithoutPayoutInput>
  }

  export type CommissionUpdateWithWhereUniqueWithoutPayoutInput = {
    where: CommissionWhereUniqueInput
    data: XOR<CommissionUpdateWithoutPayoutInput, CommissionUncheckedUpdateWithoutPayoutInput>
  }

  export type CommissionUpdateManyWithWhereWithoutPayoutInput = {
    where: CommissionScalarWhereInput
    data: XOR<CommissionUpdateManyMutationInput, CommissionUncheckedUpdateManyWithoutPayoutInput>
  }

  export type OfferCreateWithoutCreativesInput = {
    id?: string
    name: string
    description: string
    category: string
    commissionRate: number
    status?: $Enums.OfferStatus
    startDate: Date | string
    endDate?: Date | string | null
    terms?: string | null
    requirements?: string | null
    totalClicks?: number
    totalConversions?: number
    totalRevenue?: number
    totalCommissions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: OfferApplicationCreateNestedManyWithoutOfferInput
    conversions?: ConversionCreateNestedManyWithoutOfferInput
    links?: AffiliateLinkCreateNestedManyWithoutOfferInput
  }

  export type OfferUncheckedCreateWithoutCreativesInput = {
    id?: string
    name: string
    description: string
    category: string
    commissionRate: number
    status?: $Enums.OfferStatus
    startDate: Date | string
    endDate?: Date | string | null
    terms?: string | null
    requirements?: string | null
    totalClicks?: number
    totalConversions?: number
    totalRevenue?: number
    totalCommissions?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: OfferApplicationUncheckedCreateNestedManyWithoutOfferInput
    conversions?: ConversionUncheckedCreateNestedManyWithoutOfferInput
    links?: AffiliateLinkUncheckedCreateNestedManyWithoutOfferInput
  }

  export type OfferCreateOrConnectWithoutCreativesInput = {
    where: OfferWhereUniqueInput
    create: XOR<OfferCreateWithoutCreativesInput, OfferUncheckedCreateWithoutCreativesInput>
  }

  export type OfferUpsertWithoutCreativesInput = {
    update: XOR<OfferUpdateWithoutCreativesInput, OfferUncheckedUpdateWithoutCreativesInput>
    create: XOR<OfferCreateWithoutCreativesInput, OfferUncheckedCreateWithoutCreativesInput>
    where?: OfferWhereInput
  }

  export type OfferUpdateToOneWithWhereWithoutCreativesInput = {
    where?: OfferWhereInput
    data: XOR<OfferUpdateWithoutCreativesInput, OfferUncheckedUpdateWithoutCreativesInput>
  }

  export type OfferUpdateWithoutCreativesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    commissionRate?: FloatFieldUpdateOperationsInput | number
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    totalCommissions?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: OfferApplicationUpdateManyWithoutOfferNestedInput
    conversions?: ConversionUpdateManyWithoutOfferNestedInput
    links?: AffiliateLinkUpdateManyWithoutOfferNestedInput
  }

  export type OfferUncheckedUpdateWithoutCreativesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    commissionRate?: FloatFieldUpdateOperationsInput | number
    status?: EnumOfferStatusFieldUpdateOperationsInput | $Enums.OfferStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terms?: NullableStringFieldUpdateOperationsInput | string | null
    requirements?: NullableStringFieldUpdateOperationsInput | string | null
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    totalCommissions?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: OfferApplicationUncheckedUpdateManyWithoutOfferNestedInput
    conversions?: ConversionUncheckedUpdateManyWithoutOfferNestedInput
    links?: AffiliateLinkUncheckedUpdateManyWithoutOfferNestedInput
  }

  export type AffiliateProfileCreateWithoutCouponsInput = {
    id?: string
    companyName?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: $Enums.PaymentMethod
    paymentEmail?: string | null
    taxId?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    tier?: $Enums.AffiliateTier
    commissionRate?: number
    totalEarnings?: number
    totalClicks?: number
    totalConversions?: number
    conversionRate?: number
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAffiliateProfileInput
    clicks?: ClickCreateNestedManyWithoutAffiliateInput
    conversions?: ConversionCreateNestedManyWithoutAffiliateInput
    commissions?: CommissionCreateNestedManyWithoutAffiliateInput
    payouts?: PayoutCreateNestedManyWithoutAffiliateInput
    links?: AffiliateLinkCreateNestedManyWithoutAffiliateInput
    applications?: OfferApplicationCreateNestedManyWithoutAffiliateInput
  }

  export type AffiliateProfileUncheckedCreateWithoutCouponsInput = {
    id?: string
    userId: string
    companyName?: string | null
    website?: string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: $Enums.PaymentMethod
    paymentEmail?: string | null
    taxId?: string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    tier?: $Enums.AffiliateTier
    commissionRate?: number
    totalEarnings?: number
    totalClicks?: number
    totalConversions?: number
    conversionRate?: number
    lastActivityAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clicks?: ClickUncheckedCreateNestedManyWithoutAffiliateInput
    conversions?: ConversionUncheckedCreateNestedManyWithoutAffiliateInput
    commissions?: CommissionUncheckedCreateNestedManyWithoutAffiliateInput
    payouts?: PayoutUncheckedCreateNestedManyWithoutAffiliateInput
    links?: AffiliateLinkUncheckedCreateNestedManyWithoutAffiliateInput
    applications?: OfferApplicationUncheckedCreateNestedManyWithoutAffiliateInput
  }

  export type AffiliateProfileCreateOrConnectWithoutCouponsInput = {
    where: AffiliateProfileWhereUniqueInput
    create: XOR<AffiliateProfileCreateWithoutCouponsInput, AffiliateProfileUncheckedCreateWithoutCouponsInput>
  }

  export type AffiliateProfileUpsertWithoutCouponsInput = {
    update: XOR<AffiliateProfileUpdateWithoutCouponsInput, AffiliateProfileUncheckedUpdateWithoutCouponsInput>
    create: XOR<AffiliateProfileCreateWithoutCouponsInput, AffiliateProfileUncheckedCreateWithoutCouponsInput>
    where?: AffiliateProfileWhereInput
  }

  export type AffiliateProfileUpdateToOneWithWhereWithoutCouponsInput = {
    where?: AffiliateProfileWhereInput
    data: XOR<AffiliateProfileUpdateWithoutCouponsInput, AffiliateProfileUncheckedUpdateWithoutCouponsInput>
  }

  export type AffiliateProfileUpdateWithoutCouponsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    tier?: EnumAffiliateTierFieldUpdateOperationsInput | $Enums.AffiliateTier
    commissionRate?: FloatFieldUpdateOperationsInput | number
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAffiliateProfileNestedInput
    clicks?: ClickUpdateManyWithoutAffiliateNestedInput
    conversions?: ConversionUpdateManyWithoutAffiliateNestedInput
    commissions?: CommissionUpdateManyWithoutAffiliateNestedInput
    payouts?: PayoutUpdateManyWithoutAffiliateNestedInput
    links?: AffiliateLinkUpdateManyWithoutAffiliateNestedInput
    applications?: OfferApplicationUpdateManyWithoutAffiliateNestedInput
  }

  export type AffiliateProfileUncheckedUpdateWithoutCouponsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialMedia?: NullableJsonNullValueInput | InputJsonValue
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    paymentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableJsonNullValueInput | InputJsonValue
    tier?: EnumAffiliateTierFieldUpdateOperationsInput | $Enums.AffiliateTier
    commissionRate?: FloatFieldUpdateOperationsInput | number
    totalEarnings?: FloatFieldUpdateOperationsInput | number
    totalClicks?: IntFieldUpdateOperationsInput | number
    totalConversions?: IntFieldUpdateOperationsInput | number
    conversionRate?: FloatFieldUpdateOperationsInput | number
    lastActivityAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clicks?: ClickUncheckedUpdateManyWithoutAffiliateNestedInput
    conversions?: ConversionUncheckedUpdateManyWithoutAffiliateNestedInput
    commissions?: CommissionUncheckedUpdateManyWithoutAffiliateNestedInput
    payouts?: PayoutUncheckedUpdateManyWithoutAffiliateNestedInput
    links?: AffiliateLinkUncheckedUpdateManyWithoutAffiliateNestedInput
    applications?: OfferApplicationUncheckedUpdateManyWithoutAffiliateNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    avatar?: string | null
    phone?: string | null
    timezone?: string
    language?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    affiliateProfile?: AffiliateProfileCreateNestedOneWithoutUserInput
    adminProfile?: AdminProfileCreateNestedOneWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    activities?: ActivityCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    avatar?: string | null
    phone?: string | null
    timezone?: string
    language?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    affiliateProfile?: AffiliateProfileUncheckedCreateNestedOneWithoutUserInput
    adminProfile?: AdminProfileUncheckedCreateNestedOneWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    activities?: ActivityUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateProfile?: AffiliateProfileUpdateOneWithoutUserNestedInput
    adminProfile?: AdminProfileUpdateOneWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    activities?: ActivityUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateProfile?: AffiliateProfileUncheckedUpdateOneWithoutUserNestedInput
    adminProfile?: AdminProfileUncheckedUpdateOneWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    activities?: ActivityUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutActivitiesInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    avatar?: string | null
    phone?: string | null
    timezone?: string
    language?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    affiliateProfile?: AffiliateProfileCreateNestedOneWithoutUserInput
    adminProfile?: AdminProfileCreateNestedOneWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutActivitiesInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    avatar?: string | null
    phone?: string | null
    timezone?: string
    language?: string
    twoFactorEnabled?: boolean
    twoFactorSecret?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    affiliateProfile?: AffiliateProfileUncheckedCreateNestedOneWithoutUserInput
    adminProfile?: AdminProfileUncheckedCreateNestedOneWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutActivitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
  }

  export type UserUpsertWithoutActivitiesInput = {
    update: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
    create: XOR<UserCreateWithoutActivitiesInput, UserUncheckedCreateWithoutActivitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivitiesInput, UserUncheckedUpdateWithoutActivitiesInput>
  }

  export type UserUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateProfile?: AffiliateProfileUpdateOneWithoutUserNestedInput
    adminProfile?: AdminProfileUpdateOneWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    twoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    twoFactorSecret?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affiliateProfile?: AffiliateProfileUncheckedUpdateOneWithoutUserNestedInput
    adminProfile?: AdminProfileUncheckedUpdateOneWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SessionCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    read?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ActivityCreateManyUserInput = {
    id?: string
    action: string
    resource: string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    read?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    read?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    read?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClickCreateManyAffiliateInput = {
    id?: string
    linkId: string
    ipAddress: string
    userAgent: string
    referrer?: string | null
    country?: string | null
    city?: string | null
    device?: string | null
    browser?: string | null
    os?: string | null
    converted?: boolean
    conversionId?: string | null
    createdAt?: Date | string
  }

  export type ConversionCreateManyAffiliateInput = {
    id?: string
    clickId: string
    offerId: string
    customerEmail?: string | null
    customerValue: number
    commissionAmount: number
    status?: $Enums.ConversionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommissionCreateManyAffiliateInput = {
    id?: string
    conversionId: string
    payoutId?: string | null
    amount: number
    rate: number
    status?: $Enums.CommissionStatus
    payoutDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayoutCreateManyAffiliateInput = {
    id?: string
    amount: number
    method: $Enums.PaymentMethod
    status?: $Enums.PayoutStatus
    referenceId?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AffiliateLinkCreateManyAffiliateInput = {
    id?: string
    offerId?: string | null
    originalUrl: string
    shortUrl: string
    customSlug?: string | null
    clicks?: number
    conversions?: number
    earnings?: number
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CouponCreateManyAffiliateInput = {
    id?: string
    code: string
    description: string
    discount: string
    validUntil: Date | string
    usage?: number
    maxUsage?: number | null
    status?: $Enums.CouponStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferApplicationCreateManyAffiliateInput = {
    id?: string
    offerId: string
    status?: $Enums.ApplicationStatus
    message?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClickUpdateWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    converted?: BoolFieldUpdateOperationsInput | boolean
    conversionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    link?: AffiliateLinkUpdateOneRequiredWithoutClickRecordsNestedInput
    conversion?: ConversionUpdateOneWithoutClickNestedInput
  }

  export type ClickUncheckedUpdateWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    linkId?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    converted?: BoolFieldUpdateOperationsInput | boolean
    conversionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversion?: ConversionUncheckedUpdateOneWithoutClickNestedInput
  }

  export type ClickUncheckedUpdateManyWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    linkId?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    converted?: BoolFieldUpdateOperationsInput | boolean
    conversionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversionUpdateWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerValue?: FloatFieldUpdateOperationsInput | number
    commissionAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumConversionStatusFieldUpdateOperationsInput | $Enums.ConversionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    click?: ClickUpdateOneRequiredWithoutConversionNestedInput
    offer?: OfferUpdateOneRequiredWithoutConversionsNestedInput
    commission?: CommissionUpdateOneWithoutConversionNestedInput
  }

  export type ConversionUncheckedUpdateWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clickId?: StringFieldUpdateOperationsInput | string
    offerId?: StringFieldUpdateOperationsInput | string
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerValue?: FloatFieldUpdateOperationsInput | number
    commissionAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumConversionStatusFieldUpdateOperationsInput | $Enums.ConversionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commission?: CommissionUncheckedUpdateOneWithoutConversionNestedInput
  }

  export type ConversionUncheckedUpdateManyWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clickId?: StringFieldUpdateOperationsInput | string
    offerId?: StringFieldUpdateOperationsInput | string
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerValue?: FloatFieldUpdateOperationsInput | number
    commissionAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumConversionStatusFieldUpdateOperationsInput | $Enums.ConversionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionUpdateWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    status?: EnumCommissionStatusFieldUpdateOperationsInput | $Enums.CommissionStatus
    payoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversion?: ConversionUpdateOneRequiredWithoutCommissionNestedInput
    payout?: PayoutUpdateOneWithoutCommissionsNestedInput
  }

  export type CommissionUncheckedUpdateWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversionId?: StringFieldUpdateOperationsInput | string
    payoutId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    status?: EnumCommissionStatusFieldUpdateOperationsInput | $Enums.CommissionStatus
    payoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionUncheckedUpdateManyWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversionId?: StringFieldUpdateOperationsInput | string
    payoutId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    status?: EnumCommissionStatusFieldUpdateOperationsInput | $Enums.CommissionStatus
    payoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayoutUpdateWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commissions?: CommissionUpdateManyWithoutPayoutNestedInput
  }

  export type PayoutUncheckedUpdateWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commissions?: CommissionUncheckedUpdateManyWithoutPayoutNestedInput
  }

  export type PayoutUncheckedUpdateManyWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AffiliateLinkUpdateWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    shortUrl?: StringFieldUpdateOperationsInput | string
    customSlug?: NullableStringFieldUpdateOperationsInput | string | null
    clicks?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    earnings?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offer?: OfferUpdateOneWithoutLinksNestedInput
    clickRecords?: ClickUpdateManyWithoutLinkNestedInput
  }

  export type AffiliateLinkUncheckedUpdateWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    originalUrl?: StringFieldUpdateOperationsInput | string
    shortUrl?: StringFieldUpdateOperationsInput | string
    customSlug?: NullableStringFieldUpdateOperationsInput | string | null
    clicks?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    earnings?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clickRecords?: ClickUncheckedUpdateManyWithoutLinkNestedInput
  }

  export type AffiliateLinkUncheckedUpdateManyWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    offerId?: NullableStringFieldUpdateOperationsInput | string | null
    originalUrl?: StringFieldUpdateOperationsInput | string
    shortUrl?: StringFieldUpdateOperationsInput | string
    customSlug?: NullableStringFieldUpdateOperationsInput | string | null
    clicks?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    earnings?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponUpdateWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    discount?: StringFieldUpdateOperationsInput | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    usage?: IntFieldUpdateOperationsInput | number
    maxUsage?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumCouponStatusFieldUpdateOperationsInput | $Enums.CouponStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponUncheckedUpdateWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    discount?: StringFieldUpdateOperationsInput | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    usage?: IntFieldUpdateOperationsInput | number
    maxUsage?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumCouponStatusFieldUpdateOperationsInput | $Enums.CouponStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponUncheckedUpdateManyWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    discount?: StringFieldUpdateOperationsInput | string
    validUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    usage?: IntFieldUpdateOperationsInput | number
    maxUsage?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumCouponStatusFieldUpdateOperationsInput | $Enums.CouponStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferApplicationUpdateWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offer?: OfferUpdateOneRequiredWithoutApplicationsNestedInput
  }

  export type OfferApplicationUncheckedUpdateWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    offerId?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferApplicationUncheckedUpdateManyWithoutAffiliateInput = {
    id?: StringFieldUpdateOperationsInput | string
    offerId?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferApplicationCreateManyOfferInput = {
    id?: string
    affiliateId: string
    status?: $Enums.ApplicationStatus
    message?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversionCreateManyOfferInput = {
    id?: string
    clickId: string
    affiliateId: string
    customerEmail?: string | null
    customerValue: number
    commissionAmount: number
    status?: $Enums.ConversionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AffiliateLinkCreateManyOfferInput = {
    id?: string
    affiliateId: string
    originalUrl: string
    shortUrl: string
    customSlug?: string | null
    clicks?: number
    conversions?: number
    earnings?: number
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CreativeCreateManyOfferInput = {
    id?: string
    name: string
    type: $Enums.CreativeType
    size: string
    format: string
    url: string
    downloadUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OfferApplicationUpdateWithoutOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliate?: AffiliateProfileUpdateOneRequiredWithoutApplicationsNestedInput
  }

  export type OfferApplicationUncheckedUpdateWithoutOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliateId?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OfferApplicationUncheckedUpdateManyWithoutOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliateId?: StringFieldUpdateOperationsInput | string
    status?: EnumApplicationStatusFieldUpdateOperationsInput | $Enums.ApplicationStatus
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversionUpdateWithoutOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerValue?: FloatFieldUpdateOperationsInput | number
    commissionAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumConversionStatusFieldUpdateOperationsInput | $Enums.ConversionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    click?: ClickUpdateOneRequiredWithoutConversionNestedInput
    affiliate?: AffiliateProfileUpdateOneRequiredWithoutConversionsNestedInput
    commission?: CommissionUpdateOneWithoutConversionNestedInput
  }

  export type ConversionUncheckedUpdateWithoutOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    clickId?: StringFieldUpdateOperationsInput | string
    affiliateId?: StringFieldUpdateOperationsInput | string
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerValue?: FloatFieldUpdateOperationsInput | number
    commissionAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumConversionStatusFieldUpdateOperationsInput | $Enums.ConversionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commission?: CommissionUncheckedUpdateOneWithoutConversionNestedInput
  }

  export type ConversionUncheckedUpdateManyWithoutOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    clickId?: StringFieldUpdateOperationsInput | string
    affiliateId?: StringFieldUpdateOperationsInput | string
    customerEmail?: NullableStringFieldUpdateOperationsInput | string | null
    customerValue?: FloatFieldUpdateOperationsInput | number
    commissionAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumConversionStatusFieldUpdateOperationsInput | $Enums.ConversionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AffiliateLinkUpdateWithoutOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    shortUrl?: StringFieldUpdateOperationsInput | string
    customSlug?: NullableStringFieldUpdateOperationsInput | string | null
    clicks?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    earnings?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliate?: AffiliateProfileUpdateOneRequiredWithoutLinksNestedInput
    clickRecords?: ClickUpdateManyWithoutLinkNestedInput
  }

  export type AffiliateLinkUncheckedUpdateWithoutOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliateId?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    shortUrl?: StringFieldUpdateOperationsInput | string
    customSlug?: NullableStringFieldUpdateOperationsInput | string | null
    clicks?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    earnings?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clickRecords?: ClickUncheckedUpdateManyWithoutLinkNestedInput
  }

  export type AffiliateLinkUncheckedUpdateManyWithoutOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliateId?: StringFieldUpdateOperationsInput | string
    originalUrl?: StringFieldUpdateOperationsInput | string
    shortUrl?: StringFieldUpdateOperationsInput | string
    customSlug?: NullableStringFieldUpdateOperationsInput | string | null
    clicks?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    earnings?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreativeUpdateWithoutOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCreativeTypeFieldUpdateOperationsInput | $Enums.CreativeType
    size?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    downloadUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreativeUncheckedUpdateWithoutOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCreativeTypeFieldUpdateOperationsInput | $Enums.CreativeType
    size?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    downloadUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreativeUncheckedUpdateManyWithoutOfferInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCreativeTypeFieldUpdateOperationsInput | $Enums.CreativeType
    size?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    downloadUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClickCreateManyLinkInput = {
    id?: string
    affiliateId: string
    ipAddress: string
    userAgent: string
    referrer?: string | null
    country?: string | null
    city?: string | null
    device?: string | null
    browser?: string | null
    os?: string | null
    converted?: boolean
    conversionId?: string | null
    createdAt?: Date | string
  }

  export type ClickUpdateWithoutLinkInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    converted?: BoolFieldUpdateOperationsInput | boolean
    conversionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliate?: AffiliateProfileUpdateOneRequiredWithoutClicksNestedInput
    conversion?: ConversionUpdateOneWithoutClickNestedInput
  }

  export type ClickUncheckedUpdateWithoutLinkInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliateId?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    converted?: BoolFieldUpdateOperationsInput | boolean
    conversionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversion?: ConversionUncheckedUpdateOneWithoutClickNestedInput
  }

  export type ClickUncheckedUpdateManyWithoutLinkInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliateId?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    referrer?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    device?: NullableStringFieldUpdateOperationsInput | string | null
    browser?: NullableStringFieldUpdateOperationsInput | string | null
    os?: NullableStringFieldUpdateOperationsInput | string | null
    converted?: BoolFieldUpdateOperationsInput | boolean
    conversionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionCreateManyPayoutInput = {
    id?: string
    conversionId: string
    affiliateId: string
    amount: number
    rate: number
    status?: $Enums.CommissionStatus
    payoutDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommissionUpdateWithoutPayoutInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    status?: EnumCommissionStatusFieldUpdateOperationsInput | $Enums.CommissionStatus
    payoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversion?: ConversionUpdateOneRequiredWithoutCommissionNestedInput
    affiliate?: AffiliateProfileUpdateOneRequiredWithoutCommissionsNestedInput
  }

  export type CommissionUncheckedUpdateWithoutPayoutInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversionId?: StringFieldUpdateOperationsInput | string
    affiliateId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    status?: EnumCommissionStatusFieldUpdateOperationsInput | $Enums.CommissionStatus
    payoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionUncheckedUpdateManyWithoutPayoutInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversionId?: StringFieldUpdateOperationsInput | string
    affiliateId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    status?: EnumCommissionStatusFieldUpdateOperationsInput | $Enums.CommissionStatus
    payoutDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AffiliateProfileCountOutputTypeDefaultArgs instead
     */
    export type AffiliateProfileCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AffiliateProfileCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OfferCountOutputTypeDefaultArgs instead
     */
    export type OfferCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OfferCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AffiliateLinkCountOutputTypeDefaultArgs instead
     */
    export type AffiliateLinkCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AffiliateLinkCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PayoutCountOutputTypeDefaultArgs instead
     */
    export type PayoutCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PayoutCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AffiliateProfileDefaultArgs instead
     */
    export type AffiliateProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AffiliateProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminProfileDefaultArgs instead
     */
    export type AdminProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OfferDefaultArgs instead
     */
    export type OfferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OfferDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OfferApplicationDefaultArgs instead
     */
    export type OfferApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OfferApplicationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AffiliateLinkDefaultArgs instead
     */
    export type AffiliateLinkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AffiliateLinkDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClickDefaultArgs instead
     */
    export type ClickArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClickDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConversionDefaultArgs instead
     */
    export type ConversionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConversionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommissionDefaultArgs instead
     */
    export type CommissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PayoutDefaultArgs instead
     */
    export type PayoutArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PayoutDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CreativeDefaultArgs instead
     */
    export type CreativeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CreativeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CouponDefaultArgs instead
     */
    export type CouponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CouponDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActivityDefaultArgs instead
     */
    export type ActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActivityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WebhookDefaultArgs instead
     */
    export type WebhookArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WebhookDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrafficRuleDefaultArgs instead
     */
    export type TrafficRuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrafficRuleDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}